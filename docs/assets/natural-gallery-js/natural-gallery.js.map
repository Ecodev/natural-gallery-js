{"version":3,"sources":["../../../node_modules/es-toolkit/dist/function/debounce.mjs","../../../node_modules/es-toolkit/dist/object/pick.mjs","../../../node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs","../../../node_modules/es-toolkit/dist/compat/object/defaultsDeep.mjs","../../../src/js/util/util.js","../../../src/js/util/dom-events.js","../../../src/js/util/viewport-size.js","../../../src/js/slide/pan-bounds.js","../../../src/js/slide/zoom-level.js","../../../src/js/slide/slide.js","../../../src/js/gestures/drag-handler.js","../../../src/js/gestures/zoom-handler.js","../../../src/js/gestures/tap-handler.js","../../../src/js/gestures/gestures.js","../../../src/js/main-scroll.js","../../../src/js/keyboard.js","../../../src/js/util/css-animation.js","../../../src/js/util/spring-easer.js","../../../src/js/util/spring-animation.js","../../../src/js/util/animations.js","../../../src/js/scroll-wheel.js","../../../src/js/ui/ui-element.js","../../../src/js/ui/button-arrow.js","../../../src/js/ui/button-close.js","../../../src/js/ui/button-zoom.js","../../../src/js/ui/loading-indicator.js","../../../src/js/ui/counter-indicator.js","../../../src/js/ui/ui.js","../../../src/js/slide/get-thumb-bounds.js","../../../src/js/core/eventable.js","../../../src/js/slide/placeholder.js","../../../src/js/slide/content.js","../../../src/js/slide/loader.js","../../../src/js/core/base.js","../../../src/js/opener.js","../../../src/js/photoswipe.js","../../../src/js/util/util.js","../../../src/js/core/eventable.js","../../../src/js/slide/placeholder.js","../../../src/js/slide/content.js","../../../src/js/util/viewport-size.js","../../../src/js/slide/zoom-level.js","../../../src/js/slide/loader.js","../../../src/js/core/base.js","../../../src/js/lightbox/lightbox.js","../../../src/js/Utility.ts","../../../src/js/Item.ts","../../../src/js/galleries/AbstractGallery.ts","../../../src/js/galleries/AbstractRowGallery.ts","../../../src/js/galleries/Natural.ts","../../../src/js/Column.ts","../../../src/js/galleries/Masonry.ts","../../../src/js/galleries/Square.ts"],"sourcesContent":["function debounce(func, debounceMs, { signal, edges } = {}) {\n    let pendingThis = undefined;\n    let pendingArgs = null;\n    const leading = edges != null && edges.includes('leading');\n    const trailing = edges == null || edges.includes('trailing');\n    const invoke = () => {\n        if (pendingArgs !== null) {\n            func.apply(pendingThis, pendingArgs);\n            pendingThis = undefined;\n            pendingArgs = null;\n        }\n    };\n    const onTimerEnd = () => {\n        if (trailing) {\n            invoke();\n        }\n        cancel();\n    };\n    let timeoutId = null;\n    const schedule = () => {\n        if (timeoutId != null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = null;\n            onTimerEnd();\n        }, debounceMs);\n    };\n    const cancelTimer = () => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n    };\n    const cancel = () => {\n        cancelTimer();\n        pendingThis = undefined;\n        pendingArgs = null;\n    };\n    const flush = () => {\n        cancelTimer();\n        invoke();\n    };\n    const debounced = function (...args) {\n        if (signal?.aborted) {\n            return;\n        }\n        pendingThis = this;\n        pendingArgs = args;\n        const isFirstCall = timeoutId == null;\n        schedule();\n        if (leading && isFirstCall) {\n            invoke();\n        }\n    };\n    debounced.schedule = schedule;\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    signal?.addEventListener('abort', cancel, { once: true });\n    return debounced;\n}\n\nexport { debounce };\n","function pick(obj, keys) {\n    const result = {};\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (Object.hasOwn(obj, key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n\nexport { pick };\n","function isPlainObject(object) {\n    if (typeof object !== 'object') {\n        return false;\n    }\n    if (object == null) {\n        return false;\n    }\n    if (Object.getPrototypeOf(object) === null) {\n        return true;\n    }\n    if (Object.prototype.toString.call(object) !== '[object Object]') {\n        const tag = object[Symbol.toStringTag];\n        if (tag == null) {\n            return false;\n        }\n        const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n        if (isTagReadonly) {\n            return false;\n        }\n        return object.toString() === `[object ${tag}]`;\n    }\n    let proto = object;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(object) === proto;\n}\n\nexport { isPlainObject };\n","import { isPlainObject } from '../predicate/isPlainObject.mjs';\n\nfunction defaultsDeep(target, ...sources) {\n    target = Object(target);\n    for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n        if (source != null) {\n            const stack = new WeakMap();\n            defaultsDeepRecursive(target, source, stack);\n        }\n    }\n    return target;\n}\nfunction defaultsDeepRecursive(target, source, stack) {\n    for (const key in source) {\n        const sourceValue = source[key];\n        const targetValue = target[key];\n        const targetHasKey = Object.hasOwn(target, key);\n        if (!targetHasKey || targetValue === undefined) {\n            if (stack.has(sourceValue)) {\n                target[key] = stack.get(sourceValue);\n            }\n            else if (isPlainObject(sourceValue)) {\n                const newObj = {};\n                stack.set(sourceValue, newObj);\n                target[key] = newObj;\n                defaultsDeepRecursive(newObj, sourceValue, stack);\n            }\n            else {\n                target[key] = sourceValue;\n            }\n        }\n        else if (isPlainObject(targetValue) && isPlainObject(sourceValue)) {\n            const inStack = stack.has(sourceValue);\n            if (!inStack || (inStack && stack.get(sourceValue) !== targetValue)) {\n                stack.set(sourceValue, targetValue);\n                defaultsDeepRecursive(targetValue, sourceValue, stack);\n            }\n        }\n    }\n}\n\nexport { defaultsDeep };\n","/** @typedef {import('../photoswipe.js').Point} Point */\r\n\r\n/**\r\n * @template {keyof HTMLElementTagNameMap} T\r\n * @param {string} className\r\n * @param {T} tagName\r\n * @param {Node} [appendToEl]\r\n * @returns {HTMLElementTagNameMap[T]}\r\n */\r\nexport function createElement(className, tagName, appendToEl) {\r\n  const el = document.createElement(tagName);\r\n  if (className) {\r\n    el.className = className;\r\n  }\r\n  if (appendToEl) {\r\n    appendToEl.appendChild(el);\r\n  }\r\n  return el;\r\n}\r\n\r\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {Point}\r\n */\r\nexport function equalizePoints(p1, p2) {\r\n  p1.x = p2.x;\r\n  p1.y = p2.y;\r\n  if (p2.id !== undefined) {\r\n    p1.id = p2.id;\r\n  }\r\n  return p1;\r\n}\r\n\r\n/**\r\n * @param {Point} p\r\n */\r\nexport function roundPoint(p) {\r\n  p.x = Math.round(p.x);\r\n  p.y = Math.round(p.y);\r\n}\r\n\r\n/**\r\n * Returns distance between two points.\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {number}\r\n */\r\nexport function getDistanceBetween(p1, p2) {\r\n  const x = Math.abs(p1.x - p2.x);\r\n  const y = Math.abs(p1.y - p2.y);\r\n  return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * Whether X and Y positions of points are equal\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {boolean}\r\n */\r\nexport function pointsEqual(p1, p2) {\r\n  return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n\r\n/**\r\n * The float result between the min and max values.\r\n *\r\n * @param {number} val\r\n * @param {number} min\r\n * @param {number} max\r\n * @returns {number}\r\n */\r\nexport function clamp(val, min, max) {\r\n  return Math.min(Math.max(val, min), max);\r\n}\r\n\r\n/**\r\n * Get transform string\r\n *\r\n * @param {number} x\r\n * @param {number} [y]\r\n * @param {number} [scale]\r\n * @returns {string}\r\n */\r\nexport function toTransformString(x, y, scale) {\r\n  let propValue = `translate3d(${x}px,${y || 0}px,0)`;\r\n\r\n  if (scale !== undefined) {\r\n    propValue += ` scale3d(${scale},${scale},1)`;\r\n  }\r\n\r\n  return propValue;\r\n}\r\n\r\n/**\r\n * Apply transform:translate(x, y) scale(scale) to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {number} x\r\n * @param {number} [y]\r\n * @param {number} [scale]\r\n */\r\nexport function setTransform(el, x, y, scale) {\r\n  el.style.transform = toTransformString(x, y, scale);\r\n}\r\n\r\nconst defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';\r\n\r\n/**\r\n * Apply CSS transition to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string} [prop] CSS property to animate\r\n * @param {number} [duration] in ms\r\n * @param {string} [ease] CSS easing function\r\n */\r\nexport function setTransitionStyle(el, prop, duration, ease) {\r\n  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for \"toggle state\" transitions\r\n  // out: 'cubic-bezier(0, 0, .22, 1)', // for \"show\" transitions\r\n  // in: 'cubic-bezier(.4, 0, 1, 1)'// for \"hide\" transitions\r\n  el.style.transition = prop\r\n    ? `${prop} ${duration}ms ${ease || defaultCSSEasing}`\r\n    : 'none';\r\n}\r\n\r\n/**\r\n * Apply width and height CSS properties to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string | number} w\r\n * @param {string | number} h\r\n */\r\nexport function setWidthHeight(el, w, h) {\r\n  el.style.width = (typeof w === 'number') ? `${w}px` : w;\r\n  el.style.height = (typeof h === 'number') ? `${h}px` : h;\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n */\r\nexport function removeTransitionStyle(el) {\r\n  setTransitionStyle(el);\r\n}\r\n\r\n/**\r\n * @param {HTMLImageElement} img\r\n * @returns {Promise<HTMLImageElement | void>}\r\n */\r\nexport function decodeImage(img) {\r\n  if ('decode' in img) {\r\n    return img.decode().catch(() => {});\r\n  }\r\n\r\n  if (img.complete) {\r\n    return Promise.resolve(img);\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n  });\r\n}\r\n\r\n/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */\r\n/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */\r\nexport const LOAD_STATE = {\r\n  IDLE: 'idle',\r\n  LOADING: 'loading',\r\n  LOADED: 'loaded',\r\n  ERROR: 'error',\r\n};\r\n\r\n\r\n/**\r\n * Check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {MouseEvent | KeyboardEvent} e\r\n * @returns {boolean}\r\n */\r\nexport function specialKeyUsed(e) {\r\n  return ('button' in e && e.button === 1) || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;\r\n}\r\n\r\n/**\r\n * Parse `gallery` or `children` options.\r\n *\r\n * @param {import('../photoswipe.js').ElementProvider} [option]\r\n * @param {string} [legacySelector]\r\n * @param {HTMLElement | Document} [parent]\r\n * @returns HTMLElement[]\r\n */\r\nexport function getElementsFromOption(option, legacySelector, parent = document) {\r\n  /** @type {HTMLElement[]} */\r\n  let elements = [];\r\n\r\n  if (option instanceof Element) {\r\n    elements = [option];\r\n  } else if (option instanceof NodeList || Array.isArray(option)) {\r\n    elements = Array.from(option);\r\n  } else {\r\n    const selector = typeof option === 'string' ? option : legacySelector;\r\n    if (selector) {\r\n      elements = Array.from(parent.querySelectorAll(selector));\r\n    }\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\n/**\r\n * Check if variable is PhotoSwipe class\r\n *\r\n * @param {any} fn\r\n * @returns {boolean}\r\n */\r\nexport function isPswpClass(fn) {\r\n  return typeof fn === 'function'\r\n    && fn.prototype\r\n    && fn.prototype.goTo;\r\n}\r\n\r\n/**\r\n * Check if browser is Safari\r\n *\r\n * @returns {boolean}\r\n */\r\nexport function isSafari() {\r\n  return !!(navigator.vendor && navigator.vendor.match(/apple/i));\r\n}\r\n\r\n","// Detect passive event listener support\r\nlet supportsPassive = false;\r\n/* eslint-disable */\r\ntry {\r\n  /* @ts-ignore */\r\n  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n    get: () => {\r\n      supportsPassive = true;\r\n    }\r\n  }));\r\n} catch (e) {}\r\n/* eslint-enable */\r\n\r\n/**\r\n * @typedef {Object} PoolItem\r\n * @prop {HTMLElement | Window | Document | undefined | null} target\r\n * @prop {string} type\r\n * @prop {EventListenerOrEventListenerObject} listener\r\n * @prop {boolean} [passive]\r\n */\r\n\r\nclass DOMEvents {\r\n  constructor() {\r\n    /**\r\n     * @type {PoolItem[]}\r\n     * @private\r\n     */\r\n    this._pool = [];\r\n  }\r\n\r\n  /**\r\n   * Adds event listeners\r\n   *\r\n   * @param {PoolItem['target']} target\r\n   * @param {PoolItem['type']} type Can be multiple, separated by space.\r\n   * @param {PoolItem['listener']} listener\r\n   * @param {PoolItem['passive']} [passive]\r\n   */\r\n  add(target, type, listener, passive) {\r\n    this._toggleListener(target, type, listener, passive);\r\n  }\r\n\r\n  /**\r\n   * Removes event listeners\r\n   *\r\n   * @param {PoolItem['target']} target\r\n   * @param {PoolItem['type']} type\r\n   * @param {PoolItem['listener']} listener\r\n   * @param {PoolItem['passive']} [passive]\r\n   */\r\n  remove(target, type, listener, passive) {\r\n    this._toggleListener(target, type, listener, passive, true);\r\n  }\r\n\r\n  /**\r\n   * Removes all bound events\r\n   */\r\n  removeAll() {\r\n    this._pool.forEach((poolItem) => {\r\n      this._toggleListener(\r\n        poolItem.target,\r\n        poolItem.type,\r\n        poolItem.listener,\r\n        poolItem.passive,\r\n        true,\r\n        true\r\n      );\r\n    });\r\n    this._pool = [];\r\n  }\r\n\r\n  /**\r\n   * Adds or removes event\r\n   *\r\n   * @private\r\n   * @param {PoolItem['target']} target\r\n   * @param {PoolItem['type']} type\r\n   * @param {PoolItem['listener']} listener\r\n   * @param {PoolItem['passive']} [passive]\r\n   * @param {boolean} [unbind] Whether the event should be added or removed\r\n   * @param {boolean} [skipPool] Whether events pool should be skipped\r\n   */\r\n  _toggleListener(target, type, listener, passive, unbind, skipPool) {\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    const methodName = unbind ? 'removeEventListener' : 'addEventListener';\r\n    const types = type.split(' ');\r\n    types.forEach((eType) => {\r\n      if (eType) {\r\n        // Events pool is used to easily unbind all events when PhotoSwipe is closed,\r\n        // so developer doesn't need to do this manually\r\n        if (!skipPool) {\r\n          if (unbind) {\r\n            // Remove from the events pool\r\n            this._pool = this._pool.filter((poolItem) => {\r\n              return poolItem.type !== eType\r\n                || poolItem.listener !== listener\r\n                || poolItem.target !== target;\r\n            });\r\n          } else {\r\n            // Add to the events pool\r\n            this._pool.push({\r\n              target,\r\n              type: eType,\r\n              listener,\r\n              passive\r\n            });\r\n          }\r\n        }\r\n\r\n        // most PhotoSwipe events call preventDefault,\r\n        // and we do not need browser to scroll the page\r\n        const eventOptions = supportsPassive ? { passive: (passive || false) } : false;\r\n\r\n        target[methodName](\r\n          eType,\r\n          listener,\r\n          eventOptions\r\n        );\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default DOMEvents;\r\n","/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\r\n\r\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {PhotoSwipeBase} pswp\r\n * @returns {Point}\r\n */\r\nexport function getViewportSize(options, pswp) {\r\n  if (options.getViewportSizeFn) {\r\n    const newViewportSize = options.getViewportSizeFn(options, pswp);\r\n    if (newViewportSize) {\r\n      return newViewportSize;\r\n    }\r\n  }\r\n\r\n  return {\r\n    x: document.documentElement.clientWidth,\r\n\r\n    // TODO: height on mobile is very incosistent due to toolbar\r\n    // find a way to improve this\r\n    //\r\n    // document.documentElement.clientHeight - doesn't seem to work well\r\n    y: window.innerHeight\r\n  };\r\n}\r\n\r\n/**\r\n * Parses padding option.\r\n * Supported formats:\r\n *\r\n * // Object\r\n * padding: {\r\n *  top: 0,\r\n *  bottom: 0,\r\n *  left: 0,\r\n *  right: 0\r\n * }\r\n *\r\n * // A function that returns the object\r\n * paddingFn: (viewportSize, itemData, index) => {\r\n *  return {\r\n *    top: 0,\r\n *    bottom: 0,\r\n *    left: 0,\r\n *    right: 0\r\n *  };\r\n * }\r\n *\r\n * // Legacy variant\r\n * paddingLeft: 0,\r\n * paddingRight: 0,\r\n * paddingTop: 0,\r\n * paddingBottom: 0,\r\n *\r\n * @param {'left' | 'top' | 'bottom' | 'right'} prop\r\n * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n * @param {Point} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {number} index Slide index\r\n * @returns {number}\r\n */\r\nexport function parsePaddingOption(prop, options, viewportSize, itemData, index) {\r\n  let paddingValue = 0;\r\n\r\n  if (options.paddingFn) {\r\n    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];\r\n  } else if (options.padding) {\r\n    paddingValue = options.padding[prop];\r\n  } else {\r\n    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);\r\n    // @ts-expect-error\r\n    if (options[legacyPropName]) {\r\n      // @ts-expect-error\r\n      paddingValue = options[legacyPropName];\r\n    }\r\n  }\r\n\r\n  return Number(paddingValue) || 0;\r\n}\r\n\r\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {Point} viewportSize\r\n * @param {SlideData} itemData\r\n * @param {number} index\r\n * @returns {Point}\r\n */\r\nexport function getPanAreaSize(options, viewportSize, itemData, index) {\r\n  return {\r\n    x: viewportSize.x\r\n      - parsePaddingOption('left', options, viewportSize, itemData, index)\r\n      - parsePaddingOption('right', options, viewportSize, itemData, index),\r\n    y: viewportSize.y\r\n      - parsePaddingOption('top', options, viewportSize, itemData, index)\r\n      - parsePaddingOption('bottom', options, viewportSize, itemData, index)\r\n  };\r\n}\r\n","import { clamp } from '../util/util.js';\r\nimport { parsePaddingOption } from '../util/viewport-size.js';\r\n\r\n/** @typedef {import('./slide.js').default} Slide */\r\n/** @typedef {Record<Axis, number>} Point */\r\n/** @typedef {'x' | 'y'} Axis */\r\n\r\n/**\r\n * Calculates minimum, maximum and initial (center) bounds of a slide\r\n */\r\nclass PanBounds {\r\n  /**\r\n   * @param {Slide} slide\r\n   */\r\n  constructor(slide) {\r\n    this.slide = slide;\r\n    this.currZoomLevel = 1;\r\n    this.center = /** @type {Point} */ { x: 0, y: 0 };\r\n    this.max = /** @type {Point} */ { x: 0, y: 0 };\r\n    this.min = /** @type {Point} */ { x: 0, y: 0 };\r\n  }\r\n\r\n  /**\r\n   * _getItemBounds\r\n   *\r\n   * @param {number} currZoomLevel\r\n   */\r\n  update(currZoomLevel) {\r\n    this.currZoomLevel = currZoomLevel;\r\n\r\n    if (!this.slide.width) {\r\n      this.reset();\r\n    } else {\r\n      this._updateAxis('x');\r\n      this._updateAxis('y');\r\n      this.slide.pswp.dispatch('calcBounds', { slide: this.slide });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * _calculateItemBoundsForAxis\r\n   *\r\n   * @param {Axis} axis\r\n   */\r\n  _updateAxis(axis) {\r\n    const { pswp } = this.slide;\r\n    const elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;\r\n    const paddingProp = axis === 'x' ? 'left' : 'top';\r\n    const padding = parsePaddingOption(\r\n      paddingProp,\r\n      pswp.options,\r\n      pswp.viewportSize,\r\n      this.slide.data,\r\n      this.slide.index\r\n    );\r\n\r\n    const panAreaSize = this.slide.panAreaSize[axis];\r\n\r\n    // Default position of element.\r\n    // By default, it is center of viewport:\r\n    this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding;\r\n\r\n    // maximum pan position\r\n    this.max[axis] = (elSize > panAreaSize)\r\n      ? Math.round(panAreaSize - elSize) + padding\r\n      : this.center[axis];\r\n\r\n    // minimum pan position\r\n    this.min[axis] = (elSize > panAreaSize)\r\n      ? padding\r\n      : this.center[axis];\r\n  }\r\n\r\n  // _getZeroBounds\r\n  reset() {\r\n    this.center.x = 0;\r\n    this.center.y = 0;\r\n    this.max.x = 0;\r\n    this.max.y = 0;\r\n    this.min.x = 0;\r\n    this.min.y = 0;\r\n  }\r\n\r\n  /**\r\n   * Correct pan position if it's beyond the bounds\r\n   *\r\n   * @param {Axis} axis x or y\r\n   * @param {number} panOffset\r\n   * @returns {number}\r\n   */\r\n  correctPan(axis, panOffset) { // checkPanBounds\r\n    return clamp(panOffset, this.max[axis], this.min[axis]);\r\n  }\r\n}\r\n\r\nexport default PanBounds;\r\n","const MAX_IMAGE_WIDTH = 4000;\r\n\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\r\n\r\n/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */\r\n\r\n/**\r\n * Calculates zoom levels for specific slide.\r\n * Depends on viewport size and image size.\r\n */\r\nclass ZoomLevel {\r\n  /**\r\n   * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {number} index Slide index\r\n   * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet\r\n   */\r\n  constructor(options, itemData, index, pswp) {\r\n    this.pswp = pswp;\r\n    this.options = options;\r\n    this.itemData = itemData;\r\n    this.index = index;\r\n    /** @type { Point | null } */\r\n    this.panAreaSize = null;\r\n    /** @type { Point | null } */\r\n    this.elementSize = null;\r\n    this.fit = 1;\r\n    this.fill = 1;\r\n    this.vFill = 1;\r\n    this.initial = 1;\r\n    this.secondary = 1;\r\n    this.max = 1;\r\n    this.min = 1;\r\n  }\r\n\r\n  /**\r\n   * Calculate initial, secondary and maximum zoom level for the specified slide.\r\n   *\r\n   * It should be called when either image or viewport size changes.\r\n   *\r\n   * @param {number} maxWidth\r\n   * @param {number} maxHeight\r\n   * @param {Point} panAreaSize\r\n   */\r\n  update(maxWidth, maxHeight, panAreaSize) {\r\n    /** @type {Point} */\r\n    const elementSize = { x: maxWidth, y: maxHeight };\r\n    this.elementSize = elementSize;\r\n    this.panAreaSize = panAreaSize;\r\n\r\n    const hRatio = panAreaSize.x / elementSize.x;\r\n    const vRatio = panAreaSize.y / elementSize.y;\r\n\r\n    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);\r\n    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);\r\n\r\n    // zoom.vFill defines zoom level of the image\r\n    // when it has 100% of viewport vertical space (height)\r\n    this.vFill = Math.min(1, vRatio);\r\n\r\n    this.initial = this._getInitial();\r\n    this.secondary = this._getSecondary();\r\n    this.max = Math.max(\r\n      this.initial,\r\n      this.secondary,\r\n      this._getMax()\r\n    );\r\n\r\n    this.min = Math.min(\r\n      this.fit,\r\n      this.initial,\r\n      this.secondary\r\n    );\r\n\r\n    if (this.pswp) {\r\n      this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses user-defined zoom option.\r\n   *\r\n   * @private\r\n   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)\r\n   * @returns { number | undefined }\r\n   */\r\n  _parseZoomLevelOption(optionPrefix) {\r\n    const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (\r\n      optionPrefix + 'ZoomLevel'\r\n    );\r\n    const optionValue = this.options[optionName];\r\n\r\n    if (!optionValue) {\r\n      return;\r\n    }\r\n\r\n    if (typeof optionValue === 'function') {\r\n      return optionValue(this);\r\n    }\r\n\r\n    if (optionValue === 'fill') {\r\n      return this.fill;\r\n    }\r\n\r\n    if (optionValue === 'fit') {\r\n      return this.fit;\r\n    }\r\n\r\n    return Number(optionValue);\r\n  }\r\n\r\n  /**\r\n   * Get zoom level to which image will be zoomed after double-tap gesture,\r\n   * or when user clicks on zoom icon,\r\n   * or mouse-click on image itself.\r\n   * If you return 1 image will be zoomed to its original size.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getSecondary() {\r\n    let currZoomLevel = this._parseZoomLevelOption('secondary');\r\n\r\n    if (currZoomLevel) {\r\n      return currZoomLevel;\r\n    }\r\n\r\n    // 3x of \"fit\" state, but not larger than original\r\n    currZoomLevel = Math.min(1, this.fit * 3);\r\n\r\n    if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {\r\n      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;\r\n    }\r\n\r\n    return currZoomLevel;\r\n  }\r\n\r\n  /**\r\n   * Get initial image zoom level.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getInitial() {\r\n    return this._parseZoomLevelOption('initial') || this.fit;\r\n  }\r\n\r\n  /**\r\n   * Maximum zoom level when user zooms\r\n   * via zoom/pinch gesture,\r\n   * via cmd/ctrl-wheel or via trackpad.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getMax() {\r\n    // max zoom level is x4 from \"fit state\",\r\n    // used for zoom gesture and ctrl/trackpad zoom\r\n    return this._parseZoomLevelOption('max') || Math.max(1, this.fit * 4);\r\n  }\r\n}\r\n\r\nexport default ZoomLevel;\r\n","/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n\r\n/**\r\n * @typedef {_SlideData & Record<string, any>} SlideData\r\n * @typedef {Object} _SlideData\r\n * @prop {HTMLElement} [element] thumbnail element\r\n * @prop {string} [src] image URL\r\n * @prop {string} [srcset] image srcset\r\n * @prop {number} [w] image width (deprecated)\r\n * @prop {number} [h] image height (deprecated)\r\n * @prop {number} [width] image width\r\n * @prop {number} [height] image height\r\n * @prop {string} [msrc] placeholder image URL that's displayed before large image is loaded\r\n * @prop {string} [alt] image alt text\r\n * @prop {boolean} [thumbCropped] whether thumbnail is cropped client-side or not\r\n * @prop {string} [html] html content of a slide\r\n * @prop {'image' | 'html' | string} [type] slide type\r\n */\r\n\r\nimport {\r\n  createElement,\r\n  setTransform,\r\n  equalizePoints,\r\n  roundPoint,\r\n  toTransformString,\r\n  clamp,\r\n} from '../util/util.js';\r\n\r\nimport PanBounds from './pan-bounds.js';\r\nimport ZoomLevel from './zoom-level.js';\r\nimport { getPanAreaSize } from '../util/viewport-size.js';\r\n\r\n/**\r\n * Renders and allows to control a single slide\r\n */\r\nclass Slide {\r\n  /**\r\n   * @param {SlideData} data\r\n   * @param {number} index\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(data, index, pswp) {\r\n    this.data = data;\r\n    this.index = index;\r\n    this.pswp = pswp;\r\n    this.isActive = (index === pswp.currIndex);\r\n    this.currentResolution = 0;\r\n    /** @type {Point} */\r\n    this.panAreaSize = { x: 0, y: 0 };\r\n    /** @type {Point} */\r\n    this.pan = { x: 0, y: 0 };\r\n\r\n    this.isFirstSlide = (this.isActive && !pswp.opener.isOpen);\r\n\r\n    this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);\r\n\r\n    this.pswp.dispatch('gettingData', {\r\n      slide: this,\r\n      data: this.data,\r\n      index\r\n    });\r\n\r\n    this.content = this.pswp.contentLoader.getContentBySlide(this);\r\n    this.container = createElement('pswp__zoom-wrap', 'div');\r\n    /** @type {HTMLElement | null} */\r\n    this.holderElement = null;\r\n\r\n    this.currZoomLevel = 1;\r\n    /** @type {number} */\r\n    this.width = this.content.width;\r\n    /** @type {number} */\r\n    this.height = this.content.height;\r\n    this.heavyAppended = false;\r\n    this.bounds = new PanBounds(this);\r\n\r\n    this.prevDisplayedWidth = -1;\r\n    this.prevDisplayedHeight = -1;\r\n\r\n    this.pswp.dispatch('slideInit', { slide: this });\r\n  }\r\n\r\n  /**\r\n   * If this slide is active/current/visible\r\n   *\r\n   * @param {boolean} isActive\r\n   */\r\n  setIsActive(isActive) {\r\n    if (isActive && !this.isActive) {\r\n      // slide just became active\r\n      this.activate();\r\n    } else if (!isActive && this.isActive) {\r\n      // slide just became non-active\r\n      this.deactivate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Appends slide content to DOM\r\n   *\r\n   * @param {HTMLElement} holderElement\r\n   */\r\n  append(holderElement) {\r\n    this.holderElement = holderElement;\r\n\r\n    this.container.style.transformOrigin = '0 0';\r\n\r\n    // Slide appended to DOM\r\n    if (!this.data) {\r\n      return;\r\n    }\r\n\r\n    this.calculateSize();\r\n\r\n    this.load();\r\n    this.updateContentSize();\r\n    this.appendHeavy();\r\n\r\n    this.holderElement.appendChild(this.container);\r\n\r\n    this.zoomAndPanToInitial();\r\n\r\n    this.pswp.dispatch('firstZoomPan', { slide: this });\r\n\r\n    this.applyCurrentZoomPan();\r\n\r\n    this.pswp.dispatch('afterSetContent', { slide: this });\r\n\r\n    if (this.isActive) {\r\n      this.activate();\r\n    }\r\n  }\r\n\r\n  load() {\r\n    this.content.load(false);\r\n    this.pswp.dispatch('slideLoad', { slide: this });\r\n  }\r\n\r\n  /**\r\n   * Append \"heavy\" DOM elements\r\n   *\r\n   * This may depend on a type of slide,\r\n   * but generally these are large images.\r\n   */\r\n  appendHeavy() {\r\n    const { pswp } = this;\r\n    const appendHeavyNearby = true; // todo\r\n\r\n    // Avoid appending heavy elements during animations\r\n    if (this.heavyAppended\r\n        || !pswp.opener.isOpen\r\n        || pswp.mainScroll.isShifted()\r\n        || (!this.isActive && !appendHeavyNearby)) {\r\n      return;\r\n    }\r\n\r\n    if (this.pswp.dispatch('appendHeavy', { slide: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.heavyAppended = true;\r\n\r\n    this.content.append();\r\n\r\n    this.pswp.dispatch('appendHeavyContent', { slide: this });\r\n  }\r\n\r\n  /**\r\n   * Triggered when this slide is active (selected).\r\n   *\r\n   * If it's part of opening/closing transition -\r\n   * activate() will trigger after the transition is ended.\r\n   */\r\n  activate() {\r\n    this.isActive = true;\r\n    this.appendHeavy();\r\n    this.content.activate();\r\n    this.pswp.dispatch('slideActivate', { slide: this });\r\n  }\r\n\r\n  /**\r\n   * Triggered when this slide becomes inactive.\r\n   *\r\n   * Slide can become inactive only after it was active.\r\n   */\r\n  deactivate() {\r\n    this.isActive = false;\r\n    this.content.deactivate();\r\n\r\n    if (this.currZoomLevel !== this.zoomLevels.initial) {\r\n      // allow filtering\r\n      this.calculateSize();\r\n    }\r\n\r\n    // reset zoom level\r\n    this.currentResolution = 0;\r\n    this.zoomAndPanToInitial();\r\n    this.applyCurrentZoomPan();\r\n    this.updateContentSize();\r\n\r\n    this.pswp.dispatch('slideDeactivate', { slide: this });\r\n  }\r\n\r\n  /**\r\n   * The slide should destroy itself, it will never be used again.\r\n   * (unbind all events and destroy internal components)\r\n   */\r\n  destroy() {\r\n    this.content.hasSlide = false;\r\n    this.content.remove();\r\n    this.container.remove();\r\n    this.pswp.dispatch('slideDestroy', { slide: this });\r\n  }\r\n\r\n  resize() {\r\n    if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {\r\n      // Keep initial zoom level if it was before the resize,\r\n      // as well as when this slide is not active\r\n\r\n      // Reset position and scale to original state\r\n      this.calculateSize();\r\n      this.currentResolution = 0;\r\n      this.zoomAndPanToInitial();\r\n      this.applyCurrentZoomPan();\r\n      this.updateContentSize();\r\n    } else {\r\n      // readjust pan position if it's beyond the bounds\r\n      this.calculateSize();\r\n      this.bounds.update(this.currZoomLevel);\r\n      this.panTo(this.pan.x, this.pan.y);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Apply size to current slide content,\r\n   * based on the current resolution and scale.\r\n   *\r\n   * @param {boolean} [force] if size should be updated even if dimensions weren't changed\r\n   */\r\n  updateContentSize(force) {\r\n    // Use initial zoom level\r\n    // if resolution is not defined (user didn't zoom yet)\r\n    const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;\r\n\r\n    if (!scaleMultiplier) {\r\n      return;\r\n    }\r\n\r\n    const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;\r\n    const height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;\r\n\r\n    if (!this.sizeChanged(width, height) && !force) {\r\n      return;\r\n    }\r\n    this.content.setDisplayedSize(width, height);\r\n  }\r\n\r\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\r\n  sizeChanged(width, height) {\r\n    if (width !== this.prevDisplayedWidth\r\n        || height !== this.prevDisplayedHeight) {\r\n      this.prevDisplayedWidth = width;\r\n      this.prevDisplayedHeight = height;\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @returns {HTMLImageElement | HTMLDivElement | null | undefined} */\r\n  getPlaceholderElement() {\r\n    return this.content.placeholder?.element;\r\n  }\r\n\r\n  /**\r\n   * Zoom current slide image to...\r\n   *\r\n   * @param {number} destZoomLevel Destination zoom level.\r\n   * @param {Point} [centerPoint]\r\n   * Transform origin center point, or false if viewport center should be used.\r\n   * @param {number | false} [transitionDuration] Transition duration, may be set to 0.\r\n   * @param {boolean} [ignoreBounds] Minimum and maximum zoom levels will be ignored.\r\n   */\r\n  zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {\r\n    const { pswp } = this;\r\n    if (!this.isZoomable()\r\n        || pswp.mainScroll.isShifted()) {\r\n      return;\r\n    }\r\n\r\n    pswp.dispatch('beforeZoomTo', {\r\n      destZoomLevel, centerPoint, transitionDuration\r\n    });\r\n\r\n    // stop all pan and zoom transitions\r\n    pswp.animations.stopAllPan();\r\n\r\n    // if (!centerPoint) {\r\n    //   centerPoint = pswp.getViewportCenterPoint();\r\n    // }\r\n\r\n    const prevZoomLevel = this.currZoomLevel;\r\n\r\n    if (!ignoreBounds) {\r\n      destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);\r\n    }\r\n\r\n    // if (transitionDuration === undefined) {\r\n    //   transitionDuration = this.pswp.options.zoomAnimationDuration;\r\n    // }\r\n\r\n    this.setZoomLevel(destZoomLevel);\r\n    this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);\r\n    this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);\r\n    roundPoint(this.pan);\r\n\r\n    const finishTransition = () => {\r\n      this._setResolution(destZoomLevel);\r\n      this.applyCurrentZoomPan();\r\n    };\r\n\r\n    if (!transitionDuration) {\r\n      finishTransition();\r\n    } else {\r\n      pswp.animations.startTransition({\r\n        isPan: true,\r\n        name: 'zoomTo',\r\n        target: this.container,\r\n        transform: this.getCurrentTransform(),\r\n        onComplete: finishTransition,\r\n        duration: transitionDuration,\r\n        easing: pswp.options.easing\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Point} [centerPoint]\r\n   */\r\n  toggleZoom(centerPoint) {\r\n    this.zoomTo(\r\n      this.currZoomLevel === this.zoomLevels.initial\r\n        ? this.zoomLevels.secondary : this.zoomLevels.initial,\r\n      centerPoint,\r\n      this.pswp.options.zoomAnimationDuration\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Updates zoom level property and recalculates new pan bounds,\r\n   * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)\r\n   *\r\n   * @param {number} currZoomLevel\r\n   */\r\n  setZoomLevel(currZoomLevel) {\r\n    this.currZoomLevel = currZoomLevel;\r\n    this.bounds.update(this.currZoomLevel);\r\n  }\r\n\r\n  /**\r\n   * Get pan position after zoom at a given `point`.\r\n   *\r\n   * Always call setZoomLevel(newZoomLevel) beforehand to recalculate\r\n   * pan bounds according to the new zoom level.\r\n   *\r\n   * @param {'x' | 'y'} axis\r\n   * @param {Point} [point]\r\n   * point based on which zoom is performed, usually refers to the current mouse position,\r\n   * if false - viewport center will be used.\r\n   * @param {number} [prevZoomLevel] Zoom level before new zoom was applied.\r\n   * @returns {number}\r\n   */\r\n  calculateZoomToPanOffset(axis, point, prevZoomLevel) {\r\n    const totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];\r\n    if (totalPanDistance === 0) {\r\n      return this.bounds.center[axis];\r\n    }\r\n\r\n    if (!point) {\r\n      point = this.pswp.getViewportCenterPoint();\r\n    }\r\n\r\n    if (!prevZoomLevel) {\r\n      prevZoomLevel = this.zoomLevels.initial;\r\n    }\r\n\r\n    const zoomFactor = this.currZoomLevel / prevZoomLevel;\r\n    return this.bounds.correctPan(\r\n      axis,\r\n      (this.pan[axis] - point[axis]) * zoomFactor + point[axis]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Apply pan and keep it within bounds.\r\n   *\r\n   * @param {number} panX\r\n   * @param {number} panY\r\n   */\r\n  panTo(panX, panY) {\r\n    this.pan.x = this.bounds.correctPan('x', panX);\r\n    this.pan.y = this.bounds.correctPan('y', panY);\r\n    this.applyCurrentZoomPan();\r\n  }\r\n\r\n  /**\r\n   * If the slide in the current state can be panned by the user\r\n   * @returns {boolean}\r\n   */\r\n  isPannable() {\r\n    return Boolean(this.width) && (this.currZoomLevel > this.zoomLevels.fit);\r\n  }\r\n\r\n  /**\r\n   * If the slide can be zoomed\r\n   * @returns {boolean}\r\n   */\r\n  isZoomable() {\r\n    return Boolean(this.width) && this.content.isZoomable();\r\n  }\r\n\r\n  /**\r\n   * Apply transform and scale based on\r\n   * the current pan position (this.pan) and zoom level (this.currZoomLevel)\r\n   */\r\n  applyCurrentZoomPan() {\r\n    this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);\r\n    if (this === this.pswp.currSlide) {\r\n      this.pswp.dispatch('zoomPanUpdate', { slide: this });\r\n    }\r\n  }\r\n\r\n  zoomAndPanToInitial() {\r\n    this.currZoomLevel = this.zoomLevels.initial;\r\n\r\n    // pan according to the zoom level\r\n    this.bounds.update(this.currZoomLevel);\r\n    equalizePoints(this.pan, this.bounds.center);\r\n    this.pswp.dispatch('initialZoomPan', { slide: this });\r\n  }\r\n\r\n  /**\r\n   * Set translate and scale based on current resolution\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} zoom\r\n   * @private\r\n   */\r\n  _applyZoomTransform(x, y, zoom) {\r\n    zoom /= this.currentResolution || this.zoomLevels.initial;\r\n    setTransform(this.container, x, y, zoom);\r\n  }\r\n\r\n  calculateSize() {\r\n    const { pswp } = this;\r\n\r\n    equalizePoints(\r\n      this.panAreaSize,\r\n      getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index)\r\n    );\r\n\r\n    this.zoomLevels.update(this.width, this.height, this.panAreaSize);\r\n\r\n    pswp.dispatch('calcSlideSize', {\r\n      slide: this\r\n    });\r\n  }\r\n\r\n  /** @returns {string} */\r\n  getCurrentTransform() {\r\n    const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);\r\n    return toTransformString(this.pan.x, this.pan.y, scale);\r\n  }\r\n\r\n  /**\r\n   * Set resolution and re-render the image.\r\n   *\r\n   * For example, if the real image size is 2000x1500,\r\n   * and resolution is 0.5 - it will be rendered as 1000x750.\r\n   *\r\n   * Image with zoom level 2 and resolution 0.5 is\r\n   * the same as image with zoom level 1 and resolution 1.\r\n   *\r\n   * Used to optimize animations and make\r\n   * sure that browser renders image in the highest quality.\r\n   * Also used by responsive images to load the correct one.\r\n   *\r\n   * @param {number} newResolution\r\n   */\r\n  _setResolution(newResolution) {\r\n    if (newResolution === this.currentResolution) {\r\n      return;\r\n    }\r\n\r\n    this.currentResolution = newResolution;\r\n    this.updateContentSize();\r\n\r\n    this.pswp.dispatch('resolutionChanged');\r\n  }\r\n}\r\n\r\nexport default Slide;\r\n","import {\r\n  equalizePoints, roundPoint, clamp\r\n} from '../util/util.js';\r\n\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('./gestures.js').default} Gestures */\r\n\r\nconst PAN_END_FRICTION = 0.35;\r\nconst VERTICAL_DRAG_FRICTION = 0.6;\r\n\r\n// 1 corresponds to the third of viewport height\r\nconst MIN_RATIO_TO_CLOSE = 0.4;\r\n\r\n// Minimum speed required to navigate\r\n// to next or previous slide\r\nconst MIN_NEXT_SLIDE_SPEED = 0.5;\r\n\r\n/**\r\n * @param {number} initialVelocity\r\n * @param {number} decelerationRate\r\n * @returns {number}\r\n */\r\nfunction project(initialVelocity, decelerationRate) {\r\n  return initialVelocity * decelerationRate / (1 - decelerationRate);\r\n}\r\n\r\n/**\r\n * Handles single pointer dragging\r\n */\r\nclass DragHandler {\r\n  /**\r\n   * @param {Gestures} gestures\r\n   */\r\n  constructor(gestures) {\r\n    this.gestures = gestures;\r\n    this.pswp = gestures.pswp;\r\n    /** @type {Point} */\r\n    this.startPan = { x: 0, y: 0 };\r\n  }\r\n\r\n  start() {\r\n    if (this.pswp.currSlide) {\r\n      equalizePoints(this.startPan, this.pswp.currSlide.pan);\r\n    }\r\n    this.pswp.animations.stopAll();\r\n  }\r\n\r\n  change() {\r\n    const { p1, prevP1, dragAxis } = this.gestures;\r\n    const { currSlide } = this.pswp;\r\n\r\n    if (dragAxis === 'y'\r\n        && this.pswp.options.closeOnVerticalDrag\r\n        && (currSlide && currSlide.currZoomLevel <= currSlide.zoomLevels.fit)\r\n        && !this.gestures.isMultitouch) {\r\n      // Handle vertical drag to close\r\n      const panY = currSlide.pan.y + (p1.y - prevP1.y);\r\n      if (!this.pswp.dispatch('verticalDrag', { panY }).defaultPrevented) {\r\n        this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);\r\n        const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));\r\n        this.pswp.applyBgOpacity(bgOpacity);\r\n        currSlide.applyCurrentZoomPan();\r\n      }\r\n    } else {\r\n      const mainScrollChanged = this._panOrMoveMainScroll('x');\r\n      if (!mainScrollChanged) {\r\n        this._panOrMoveMainScroll('y');\r\n\r\n        if (currSlide) {\r\n          roundPoint(currSlide.pan);\r\n          currSlide.applyCurrentZoomPan();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  end() {\r\n    const { velocity } = this.gestures;\r\n    const { mainScroll, currSlide } = this.pswp;\r\n    let indexDiff = 0;\r\n\r\n    this.pswp.animations.stopAll();\r\n\r\n    // Handle main scroll if it's shifted\r\n    if (mainScroll.isShifted()) {\r\n      // Position of the main scroll relative to the viewport\r\n      const mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX();\r\n\r\n      // Ratio between 0 and 1:\r\n      // 0 - slide is not visible at all,\r\n      // 0.5 - half of the slide is visible\r\n      // 1 - slide is fully visible\r\n      const currentSlideVisibilityRatio = (mainScrollShiftDiff / this.pswp.viewportSize.x);\r\n\r\n      // Go next slide.\r\n      //\r\n      // - if velocity and its direction is matched,\r\n      //   and we see at least tiny part of the next slide\r\n      //\r\n      // - or if we see less than 50% of the current slide\r\n      //   and velocity is close to 0\r\n      //\r\n      if ((velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0)\r\n          || (velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5)) {\r\n        // Go to next slide\r\n        indexDiff = 1;\r\n        velocity.x = Math.min(velocity.x, 0);\r\n      } else if ((velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0)\r\n          || (velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5)) {\r\n        // Go to prev slide\r\n        indexDiff = -1;\r\n        velocity.x = Math.max(velocity.x, 0);\r\n      }\r\n\r\n      mainScroll.moveIndexBy(indexDiff, true, velocity.x);\r\n    }\r\n\r\n    // Restore zoom level\r\n    if ((currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.max)\r\n        || this.gestures.isMultitouch) {\r\n      this.gestures.zoomLevels.correctZoomPan(true);\r\n    } else {\r\n      // we run two animations instead of one,\r\n      // as each axis has own pan boundaries and thus different spring function\r\n      // (correctZoomPan does not have this functionality,\r\n      //  it animates all properties with single timing function)\r\n      this._finishPanGestureForAxis('x');\r\n      this._finishPanGestureForAxis('y');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   */\r\n  _finishPanGestureForAxis(axis) {\r\n    const { velocity } = this.gestures;\r\n    const { currSlide } = this.pswp;\r\n\r\n    if (!currSlide) {\r\n      return;\r\n    }\r\n\r\n    const { pan, bounds } = currSlide;\r\n    const panPos = pan[axis];\r\n    const restoreBgOpacity = (this.pswp.bgOpacity < 1 && axis === 'y');\r\n\r\n    // 0.995 means - scroll view loses 0.5% of its velocity per millisecond\r\n    // Increasing this number will reduce travel distance\r\n    const decelerationRate = 0.995; // 0.99\r\n\r\n    // Pan position if there is no bounds\r\n    const projectedPosition = panPos + project(velocity[axis], decelerationRate);\r\n\r\n    if (restoreBgOpacity) {\r\n      const vDragRatio = this._getVerticalDragRatio(panPos);\r\n      const projectedVDragRatio = this._getVerticalDragRatio(projectedPosition);\r\n\r\n      // If we are above and moving upwards,\r\n      // or if we are below and moving downwards\r\n      if ((vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE)\r\n          || (vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE)) {\r\n        this.pswp.close();\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Pan position with corrected bounds\r\n    const correctedPanPosition = bounds.correctPan(axis, projectedPosition);\r\n\r\n    // Exit if pan position should not be changed\r\n    // or if speed it too low\r\n    if (panPos === correctedPanPosition) {\r\n      return;\r\n    }\r\n\r\n    // Overshoot if the final position is out of pan bounds\r\n    const dampingRatio = (correctedPanPosition === projectedPosition) ? 1 : 0.82;\r\n\r\n    const initialBgOpacity = this.pswp.bgOpacity;\r\n    const totalPanDist = correctedPanPosition - panPos;\r\n\r\n    this.pswp.animations.startSpring({\r\n      name: 'panGesture' + axis,\r\n      isPan: true,\r\n      start: panPos,\r\n      end: correctedPanPosition,\r\n      velocity: velocity[axis],\r\n      dampingRatio,\r\n      onUpdate: (pos) => {\r\n        // Animate opacity of background relative to Y pan position of an image\r\n        if (restoreBgOpacity && this.pswp.bgOpacity < 1) {\r\n          // 0 - start of animation, 1 - end of animation\r\n          const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist;\r\n\r\n          // We clamp opacity to keep it between 0 and 1.\r\n          // As progress ratio can be larger than 1 due to overshoot,\r\n          // and we do not want to bounce opacity.\r\n          this.pswp.applyBgOpacity(clamp(\r\n            initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio,\r\n            0,\r\n            1\r\n          ));\r\n        }\r\n\r\n        pan[axis] = Math.floor(pos);\r\n        currSlide.applyCurrentZoomPan();\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update position of the main scroll,\r\n   * or/and update pan position of the current slide.\r\n   *\r\n   * Should return true if it changes (or can change) main scroll.\r\n   *\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @returns {boolean}\r\n   */\r\n  _panOrMoveMainScroll(axis) {\r\n    const { p1, dragAxis, prevP1, isMultitouch } = this.gestures;\r\n    const { currSlide, mainScroll } = this.pswp;\r\n    const delta = (p1[axis] - prevP1[axis]);\r\n    const newMainScrollX = mainScroll.x + delta;\r\n\r\n    if (!delta || !currSlide) {\r\n      return false;\r\n    }\r\n\r\n    // Always move main scroll if image can not be panned\r\n    if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {\r\n      mainScroll.moveTo(newMainScrollX, true);\r\n      return true; // changed main scroll\r\n    }\r\n\r\n    const { bounds } = currSlide;\r\n    const newPan = currSlide.pan[axis] + delta;\r\n\r\n    if (this.pswp.options.allowPanToNext\r\n        && dragAxis === 'x'\r\n        && axis === 'x'\r\n        && !isMultitouch) {\r\n      const currSlideMainScrollX = mainScroll.getCurrSlideX();\r\n\r\n      // Position of the main scroll relative to the viewport\r\n      const mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;\r\n\r\n      const isLeftToRight = delta > 0;\r\n      const isRightToLeft = !isLeftToRight;\r\n\r\n      if (newPan > bounds.min[axis] && isLeftToRight) {\r\n        // Panning from left to right, beyond the left edge\r\n\r\n        // Wether the image was at minimum pan position (or less)\r\n        // when this drag gesture started.\r\n        // Minimum pan position refers to the left edge of the image.\r\n        const wasAtMinPanPosition = (bounds.min[axis] <= this.startPan[axis]);\r\n\r\n        if (wasAtMinPanPosition) {\r\n          mainScroll.moveTo(newMainScrollX, true);\r\n          return true;\r\n        } else {\r\n          this._setPanWithFriction(axis, newPan);\r\n          //currSlide.pan[axis] = newPan;\r\n        }\r\n      } else if (newPan < bounds.max[axis] && isRightToLeft) {\r\n        // Paning from right to left, beyond the right edge\r\n\r\n        // Maximum pan position refers to the right edge of the image.\r\n        const wasAtMaxPanPosition = (this.startPan[axis] <= bounds.max[axis]);\r\n\r\n        if (wasAtMaxPanPosition) {\r\n          mainScroll.moveTo(newMainScrollX, true);\r\n          return true;\r\n        } else {\r\n          this._setPanWithFriction(axis, newPan);\r\n          //currSlide.pan[axis] = newPan;\r\n        }\r\n      } else {\r\n        // If main scroll is shifted\r\n        if (mainScrollShiftDiff !== 0) {\r\n          // If main scroll is shifted right\r\n          if (mainScrollShiftDiff > 0 /*&& isRightToLeft*/) {\r\n            mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);\r\n            return true;\r\n          } else if (mainScrollShiftDiff < 0 /*&& isLeftToRight*/) {\r\n            // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)\r\n            mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);\r\n            return true;\r\n          }\r\n        } else {\r\n          // We are within pan bounds, so just pan\r\n          this._setPanWithFriction(axis, newPan);\r\n        }\r\n      }\r\n    } else {\r\n      if (axis === 'y') {\r\n        // Do not pan vertically if main scroll is shifted o\r\n        if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {\r\n          this._setPanWithFriction(axis, newPan);\r\n        }\r\n      } else {\r\n        this._setPanWithFriction(axis, newPan);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // If we move above - the ratio is negative\r\n  // If we move below the ratio is positive\r\n\r\n  /**\r\n   * Relation between pan Y position and third of viewport height.\r\n   *\r\n   * When we are at initial position (center bounds) - the ratio is 0,\r\n   * if position is shifted upwards - the ratio is negative,\r\n   * if position is shifted downwards - the ratio is positive.\r\n   *\r\n   * @private\r\n   * @param {number} panY The current pan Y position.\r\n   * @returns {number}\r\n   */\r\n  _getVerticalDragRatio(panY) {\r\n    return (panY - (this.pswp.currSlide?.bounds.center.y ?? 0)) / (this.pswp.viewportSize.y / 3);\r\n  }\r\n\r\n  /**\r\n   * Set pan position of the current slide.\r\n   * Apply friction if the position is beyond the pan bounds,\r\n   * or if custom friction is defined.\r\n   *\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @param {number} potentialPan\r\n   * @param {number} [customFriction] (0.1 - 1)\r\n   */\r\n  _setPanWithFriction(axis, potentialPan, customFriction) {\r\n    const { currSlide } = this.pswp;\r\n\r\n    if (!currSlide) {\r\n      return;\r\n    }\r\n\r\n    const { pan, bounds } = currSlide;\r\n    const correctedPan = bounds.correctPan(axis, potentialPan);\r\n    // If we are out of pan bounds\r\n    if (correctedPan !== potentialPan || customFriction) {\r\n      const delta = Math.round(potentialPan - pan[axis]);\r\n      pan[axis] += delta * (customFriction || PAN_END_FRICTION);\r\n    } else {\r\n      pan[axis] = potentialPan;\r\n    }\r\n  }\r\n}\r\n\r\nexport default DragHandler;\r\n","import {\r\n  equalizePoints, getDistanceBetween, clamp, pointsEqual\r\n} from '../util/util.js';\r\n\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('./gestures.js').default} Gestures */\r\n\r\nconst UPPER_ZOOM_FRICTION = 0.05;\r\nconst LOWER_ZOOM_FRICTION = 0.15;\r\n\r\n\r\n/**\r\n * Get center point between two points\r\n *\r\n * @param {Point} p\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {Point}\r\n */\r\nfunction getZoomPointsCenter(p, p1, p2) {\r\n  p.x = (p1.x + p2.x) / 2;\r\n  p.y = (p1.y + p2.y) / 2;\r\n  return p;\r\n}\r\n\r\nclass ZoomHandler {\r\n  /**\r\n   * @param {Gestures} gestures\r\n   */\r\n  constructor(gestures) {\r\n    this.gestures = gestures;\r\n    /**\r\n     * @private\r\n     * @type {Point}\r\n     */\r\n    this._startPan = { x: 0, y: 0 };\r\n    /**\r\n     * @private\r\n     * @type {Point}\r\n     */\r\n    this._startZoomPoint = { x: 0, y: 0 };\r\n    /**\r\n     * @private\r\n     * @type {Point}\r\n     */\r\n    this._zoomPoint = { x: 0, y: 0 };\r\n    /** @private */\r\n    this._wasOverFitZoomLevel = false;\r\n    /** @private */\r\n    this._startZoomLevel = 1;\r\n  }\r\n\r\n  start() {\r\n    const { currSlide } = this.gestures.pswp;\r\n    if (currSlide) {\r\n      this._startZoomLevel = currSlide.currZoomLevel;\r\n      equalizePoints(this._startPan, currSlide.pan);\r\n    }\r\n\r\n    this.gestures.pswp.animations.stopAllPan();\r\n    this._wasOverFitZoomLevel = false;\r\n  }\r\n\r\n  change() {\r\n    const { p1, startP1, p2, startP2, pswp } = this.gestures;\r\n    const { currSlide } = pswp;\r\n\r\n    if (!currSlide) {\r\n      return;\r\n    }\r\n\r\n    const minZoomLevel = currSlide.zoomLevels.min;\r\n    const maxZoomLevel = currSlide.zoomLevels.max;\r\n\r\n    if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {\r\n      return;\r\n    }\r\n\r\n    getZoomPointsCenter(this._startZoomPoint, startP1, startP2);\r\n    getZoomPointsCenter(this._zoomPoint, p1, p2);\r\n\r\n    let currZoomLevel = (1 / getDistanceBetween(startP1, startP2))\r\n                      * getDistanceBetween(p1, p2)\r\n                      * this._startZoomLevel;\r\n\r\n    // slightly over the zoom.fit\r\n    if (currZoomLevel > currSlide.zoomLevels.initial + (currSlide.zoomLevels.initial / 15)) {\r\n      this._wasOverFitZoomLevel = true;\r\n    }\r\n\r\n    if (currZoomLevel < minZoomLevel) {\r\n      if (pswp.options.pinchToClose\r\n          && !this._wasOverFitZoomLevel\r\n          && this._startZoomLevel <= currSlide.zoomLevels.initial) {\r\n        // fade out background if zooming out\r\n        const bgOpacity = 1 - ((minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2));\r\n        if (!pswp.dispatch('pinchClose', { bgOpacity }).defaultPrevented) {\r\n          pswp.applyBgOpacity(bgOpacity);\r\n        }\r\n      } else {\r\n        // Apply the friction if zoom level is below the min\r\n        currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;\r\n      }\r\n    } else if (currZoomLevel > maxZoomLevel) {\r\n      // Apply the friction if zoom level is above the max\r\n      currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;\r\n    }\r\n\r\n    currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);\r\n    currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);\r\n\r\n    currSlide.setZoomLevel(currZoomLevel);\r\n    currSlide.applyCurrentZoomPan();\r\n  }\r\n\r\n  end() {\r\n    const { pswp } = this.gestures;\r\n    const { currSlide } = pswp;\r\n    if ((!currSlide || currSlide.currZoomLevel < currSlide.zoomLevels.initial)\r\n        && !this._wasOverFitZoomLevel\r\n        && pswp.options.pinchToClose) {\r\n      pswp.close();\r\n    } else {\r\n      this.correctZoomPan();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @param {number} currZoomLevel\r\n   * @returns {number}\r\n   */\r\n  _calculatePanForZoomLevel(axis, currZoomLevel) {\r\n    const zoomFactor = currZoomLevel / this._startZoomLevel;\r\n    return this._zoomPoint[axis]\r\n            - ((this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor);\r\n  }\r\n\r\n  /**\r\n   * Correct currZoomLevel and pan if they are\r\n   * beyond minimum or maximum values.\r\n   * With animation.\r\n   *\r\n   * @param {boolean} [ignoreGesture]\r\n   * Wether gesture coordinates should be ignored when calculating destination pan position.\r\n   */\r\n  correctZoomPan(ignoreGesture) {\r\n    const { pswp } = this.gestures;\r\n    const { currSlide } = pswp;\r\n\r\n    if (!currSlide?.isZoomable()) {\r\n      return;\r\n    }\r\n\r\n    if (this._zoomPoint.x === 0) {\r\n      ignoreGesture = true;\r\n    }\r\n\r\n    const prevZoomLevel = currSlide.currZoomLevel;\r\n\r\n    /** @type {number} */\r\n    let destinationZoomLevel;\r\n    let currZoomLevelNeedsChange = true;\r\n\r\n    if (prevZoomLevel < currSlide.zoomLevels.initial) {\r\n      destinationZoomLevel = currSlide.zoomLevels.initial;\r\n      // zoom to min\r\n    } else if (prevZoomLevel > currSlide.zoomLevels.max) {\r\n      destinationZoomLevel = currSlide.zoomLevels.max;\r\n      // zoom to max\r\n    } else {\r\n      currZoomLevelNeedsChange = false;\r\n      destinationZoomLevel = prevZoomLevel;\r\n    }\r\n\r\n    const initialBgOpacity = pswp.bgOpacity;\r\n    const restoreBgOpacity = pswp.bgOpacity < 1;\r\n\r\n    const initialPan = equalizePoints({ x: 0, y: 0 }, currSlide.pan);\r\n    let destinationPan = equalizePoints({ x: 0, y: 0 }, initialPan);\r\n\r\n    if (ignoreGesture) {\r\n      this._zoomPoint.x = 0;\r\n      this._zoomPoint.y = 0;\r\n      this._startZoomPoint.x = 0;\r\n      this._startZoomPoint.y = 0;\r\n      this._startZoomLevel = prevZoomLevel;\r\n      equalizePoints(this._startPan, initialPan);\r\n    }\r\n\r\n    if (currZoomLevelNeedsChange) {\r\n      destinationPan = {\r\n        x: this._calculatePanForZoomLevel('x', destinationZoomLevel),\r\n        y: this._calculatePanForZoomLevel('y', destinationZoomLevel)\r\n      };\r\n    }\r\n\r\n    // set zoom level, so pan bounds are updated according to it\r\n    currSlide.setZoomLevel(destinationZoomLevel);\r\n\r\n    destinationPan = {\r\n      x: currSlide.bounds.correctPan('x', destinationPan.x),\r\n      y: currSlide.bounds.correctPan('y', destinationPan.y)\r\n    };\r\n\r\n    // return zoom level and its bounds to initial\r\n    currSlide.setZoomLevel(prevZoomLevel);\r\n\r\n    const panNeedsChange = !pointsEqual(destinationPan, initialPan);\r\n\r\n    if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {\r\n      // update resolution after gesture\r\n      currSlide._setResolution(destinationZoomLevel);\r\n      currSlide.applyCurrentZoomPan();\r\n\r\n      // nothing to animate\r\n      return;\r\n    }\r\n\r\n    pswp.animations.stopAllPan();\r\n\r\n    pswp.animations.startSpring({\r\n      isPan: true,\r\n      start: 0,\r\n      end: 1000,\r\n      velocity: 0,\r\n      dampingRatio: 1,\r\n      naturalFrequency: 40,\r\n      onUpdate: (now) => {\r\n        now /= 1000; // 0 - start, 1 - end\r\n\r\n        if (panNeedsChange || currZoomLevelNeedsChange) {\r\n          if (panNeedsChange) {\r\n            currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;\r\n            currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;\r\n          }\r\n\r\n          if (currZoomLevelNeedsChange) {\r\n            const newZoomLevel = prevZoomLevel\r\n                        + (destinationZoomLevel - prevZoomLevel) * now;\r\n            currSlide.setZoomLevel(newZoomLevel);\r\n          }\r\n\r\n          currSlide.applyCurrentZoomPan();\r\n        }\r\n\r\n        // Restore background opacity\r\n        if (restoreBgOpacity && pswp.bgOpacity < 1) {\r\n          // We clamp opacity to keep it between 0 and 1.\r\n          // As progress ratio can be larger than 1 due to overshoot,\r\n          // and we do not want to bounce opacity.\r\n          pswp.applyBgOpacity(clamp(\r\n            initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1\r\n          ));\r\n        }\r\n      },\r\n      onComplete: () => {\r\n        // update resolution after transition ends\r\n        currSlide._setResolution(destinationZoomLevel);\r\n        currSlide.applyCurrentZoomPan();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default ZoomHandler;\r\n","/**\r\n * @template {string} T\r\n * @template {string} P\r\n * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>\r\n */\r\n\r\n/** @typedef {import('./gestures.js').default} Gestures */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n\r\n/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */\r\n\r\n/**\r\n * Whether the tap was performed on the main slide\r\n * (rather than controls or caption).\r\n *\r\n * @param {PointerEvent} event\r\n * @returns {boolean}\r\n */\r\nfunction didTapOnMainContent(event) {\r\n  return !!(/** @type {HTMLElement} */ (event.target).closest('.pswp__container'));\r\n}\r\n\r\n/**\r\n * Tap, double-tap handler.\r\n */\r\nclass TapHandler {\r\n  /**\r\n   * @param {Gestures} gestures\r\n   */\r\n  constructor(gestures) {\r\n    this.gestures = gestures;\r\n  }\r\n\r\n  /**\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\r\n  click(point, originalEvent) {\r\n    const targetClassList = /** @type {HTMLElement} */ (originalEvent.target).classList;\r\n    const isImageClick = targetClassList.contains('pswp__img');\r\n    const isBackgroundClick = targetClassList.contains('pswp__item')\r\n                              || targetClassList.contains('pswp__zoom-wrap');\r\n\r\n    if (isImageClick) {\r\n      this._doClickOrTapAction('imageClick', point, originalEvent);\r\n    } else if (isBackgroundClick) {\r\n      this._doClickOrTapAction('bgClick', point, originalEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\r\n  tap(point, originalEvent) {\r\n    if (didTapOnMainContent(originalEvent)) {\r\n      this._doClickOrTapAction('tap', point, originalEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\r\n  doubleTap(point, originalEvent) {\r\n    if (didTapOnMainContent(originalEvent)) {\r\n      this._doClickOrTapAction('doubleTap', point, originalEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Actions} actionName\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\r\n  _doClickOrTapAction(actionName, point, originalEvent) {\r\n    const { pswp } = this.gestures;\r\n    const { currSlide } = pswp;\r\n    const actionFullName = /** @type {AddPostfix<Actions, 'Action'>} */ (actionName + 'Action');\r\n    const optionValue = pswp.options[actionFullName];\r\n\r\n    if (pswp.dispatch(actionFullName, { point, originalEvent }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (typeof optionValue === 'function') {\r\n      optionValue.call(pswp, point, originalEvent);\r\n      return;\r\n    }\r\n\r\n    switch (optionValue) {\r\n      case 'close':\r\n      case 'next':\r\n        pswp[optionValue]();\r\n        break;\r\n      case 'zoom':\r\n        currSlide?.toggleZoom(point);\r\n        break;\r\n      case 'zoom-or-close':\r\n        // by default click zooms current image,\r\n        // if it can not be zoomed - gallery will be closed\r\n        if (currSlide?.isZoomable()\r\n            && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {\r\n          currSlide.toggleZoom(point);\r\n        } else if (pswp.options.clickToCloseNonZoomable) {\r\n          pswp.close();\r\n        }\r\n        break;\r\n      case 'toggle-controls':\r\n        this.gestures.pswp.element?.classList.toggle('pswp--ui-visible');\r\n        // if (_controlsVisible) {\r\n        //   _ui.hideControls();\r\n        // } else {\r\n        //   _ui.showControls();\r\n        // }\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nexport default TapHandler;\r\n","import {\r\n  equalizePoints, pointsEqual, getDistanceBetween\r\n} from '../util/util.js';\r\n\r\nimport DragHandler from './drag-handler.js';\r\nimport ZoomHandler from './zoom-handler.js';\r\nimport TapHandler from './tap-handler.js';\r\n\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n\r\n// How far should user should drag\r\n// until we can determine that the gesture is swipe and its direction\r\nconst AXIS_SWIPE_HYSTERISIS = 10;\r\n//const PAN_END_FRICTION = 0.35;\r\n\r\nconst DOUBLE_TAP_DELAY = 300; // ms\r\nconst MIN_TAP_DISTANCE = 25; // px\r\n\r\n/**\r\n * Gestures class bind touch, pointer or mouse events\r\n * and emits drag to drag-handler and zoom events zoom-handler.\r\n *\r\n * Drag and zoom events are emited in requestAnimationFrame,\r\n * and only when one of pointers was actually changed.\r\n */\r\nclass Gestures {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n\r\n    /** @type {'x' | 'y' | null} */\r\n    this.dragAxis = null;\r\n\r\n    // point objects are defined once and reused\r\n    // PhotoSwipe keeps track only of two pointers, others are ignored\r\n    /** @type {Point} */\r\n    this.p1 = { x: 0, y: 0 }; // the first pressed pointer\r\n    /** @type {Point} */\r\n    this.p2 = { x: 0, y: 0 }; // the second pressed pointer\r\n    /** @type {Point} */\r\n    this.prevP1 = { x: 0, y: 0 };\r\n    /** @type {Point} */\r\n    this.prevP2 = { x: 0, y: 0 };\r\n    /** @type {Point} */\r\n    this.startP1 = { x: 0, y: 0 };\r\n    /** @type {Point} */\r\n    this.startP2 = { x: 0, y: 0 };\r\n    /** @type {Point} */\r\n    this.velocity = { x: 0, y: 0 };\r\n\r\n    /** @type {Point}\r\n     * @private\r\n     */\r\n    this._lastStartP1 = { x: 0, y: 0 };\r\n    /** @type {Point}\r\n     * @private\r\n     */\r\n    this._intervalP1 = { x: 0, y: 0 };\r\n    /** @private */\r\n    this._numActivePoints = 0;\r\n    /** @type {Point[]}\r\n     * @private\r\n     */\r\n    this._ongoingPointers = [];\r\n    /** @private */\r\n    this._touchEventEnabled = 'ontouchstart' in window;\r\n    /** @private */\r\n    this._pointerEventEnabled = !!(window.PointerEvent);\r\n    this.supportsTouch = this._touchEventEnabled\r\n                          || (this._pointerEventEnabled && navigator.maxTouchPoints > 1);\r\n    /** @private */\r\n    this._numActivePoints = 0;\r\n    /** @private */\r\n    this._intervalTime = 0;\r\n    /** @private */\r\n    this._velocityCalculated = false;\r\n    this.isMultitouch = false;\r\n    this.isDragging = false;\r\n    this.isZooming = false;\r\n    /** @type {number | null} */\r\n    this.raf = null;\r\n    /** @type {NodeJS.Timeout | null}\r\n     * @private\r\n     */\r\n    this._tapTimer = null;\r\n\r\n    if (!this.supportsTouch) {\r\n      // disable pan to next slide for non-touch devices\r\n      pswp.options.allowPanToNext = false;\r\n    }\r\n\r\n    this.drag = new DragHandler(this);\r\n    this.zoomLevels = new ZoomHandler(this);\r\n    this.tapHandler = new TapHandler(this);\r\n\r\n    pswp.on('bindEvents', () => {\r\n      pswp.events.add(\r\n        pswp.scrollWrap,\r\n        'click',\r\n        /** @type EventListener */(this._onClick.bind(this))\r\n      );\r\n\r\n      if (this._pointerEventEnabled) {\r\n        this._bindEvents('pointer', 'down', 'up', 'cancel');\r\n      } else if (this._touchEventEnabled) {\r\n        this._bindEvents('touch', 'start', 'end', 'cancel');\r\n\r\n        // In previous versions we also bound mouse event here,\r\n        // in case device supports both touch and mouse events,\r\n        // but newer versions of browsers now support PointerEvent.\r\n\r\n        // on iOS10 if you bind touchmove/end after touchstart,\r\n        // and you don't preventDefault touchstart (which PhotoSwipe does),\r\n        // preventDefault will have no effect on touchmove and touchend.\r\n        // Unless you bind it previously.\r\n        if (pswp.scrollWrap) {\r\n          pswp.scrollWrap.ontouchmove = () => {};\r\n          pswp.scrollWrap.ontouchend = () => {};\r\n        }\r\n      } else {\r\n        this._bindEvents('mouse', 'down', 'up');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {'mouse' | 'touch' | 'pointer'} pref\r\n   * @param {'down' | 'start'} down\r\n   * @param {'up' | 'end'} up\r\n   * @param {'cancel'} [cancel]\r\n   */\r\n  _bindEvents(pref, down, up, cancel) {\r\n    const { pswp } = this;\r\n    const { events } = pswp;\r\n\r\n    const cancelEvent = cancel ? pref + cancel : '';\r\n\r\n    events.add(\r\n      pswp.scrollWrap,\r\n      pref + down,\r\n      /** @type EventListener */(this.onPointerDown.bind(this))\r\n    );\r\n    events.add(window, pref + 'move', /** @type EventListener */(this.onPointerMove.bind(this)));\r\n    events.add(window, pref + up, /** @type EventListener */(this.onPointerUp.bind(this)));\r\n    if (cancelEvent) {\r\n      events.add(\r\n        pswp.scrollWrap,\r\n        cancelEvent,\r\n        /** @type EventListener */(this.onPointerUp.bind(this))\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {PointerEvent} e\r\n   */\r\n  onPointerDown(e) {\r\n    // We do not call preventDefault for touch events\r\n    // to allow browser to show native dialog on longpress\r\n    // (the one that allows to save image or open it in new tab).\r\n    //\r\n    // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,\r\n    // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.\r\n    const isMousePointer = e.type === 'mousedown' || e.pointerType === 'mouse';\r\n\r\n    // Allow dragging only via left mouse button.\r\n    // http://www.quirksmode.org/js/events_properties.html\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/event.button\r\n    if (isMousePointer && e.button > 0) {\r\n      return;\r\n    }\r\n\r\n    const { pswp } = this;\r\n\r\n    // if PhotoSwipe is opening or closing\r\n    if (!pswp.opener.isOpen) {\r\n      e.preventDefault();\r\n      return;\r\n    }\r\n\r\n    if (pswp.dispatch('pointerDown', { originalEvent: e }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (isMousePointer) {\r\n      pswp.mouseDetected();\r\n\r\n      // preventDefault mouse event to prevent\r\n      // browser image drag feature\r\n      this._preventPointerEventBehaviour(e, 'down');\r\n    }\r\n\r\n    pswp.animations.stopAll();\r\n\r\n    this._updatePoints(e, 'down');\r\n\r\n    if (this._numActivePoints === 1) {\r\n      this.dragAxis = null;\r\n      // we need to store initial point to determine the main axis,\r\n      // drag is activated only after the axis is determined\r\n      equalizePoints(this.startP1, this.p1);\r\n    }\r\n\r\n    if (this._numActivePoints > 1) {\r\n      // Tap or double tap should not trigger if more than one pointer\r\n      this._clearTapTimer();\r\n      this.isMultitouch = true;\r\n    } else {\r\n      this.isMultitouch = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {PointerEvent} e\r\n   */\r\n  onPointerMove(e) {\r\n    this._preventPointerEventBehaviour(e, 'move');\r\n\r\n    if (!this._numActivePoints) {\r\n      return;\r\n    }\r\n\r\n    this._updatePoints(e, 'move');\r\n\r\n    if (this.pswp.dispatch('pointerMove', { originalEvent: e }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this._numActivePoints === 1 && !this.isDragging) {\r\n      if (!this.dragAxis) {\r\n        this._calculateDragDirection();\r\n      }\r\n\r\n      // Drag axis was detected, emit drag.start\r\n      if (this.dragAxis && !this.isDragging) {\r\n        if (this.isZooming) {\r\n          this.isZooming = false;\r\n          this.zoomLevels.end();\r\n        }\r\n\r\n        this.isDragging = true;\r\n        this._clearTapTimer(); // Tap can not trigger after drag\r\n\r\n        // Adjust starting point\r\n        this._updateStartPoints();\r\n        this._intervalTime = Date.now();\r\n        //this._startTime = this._intervalTime;\r\n        this._velocityCalculated = false;\r\n        equalizePoints(this._intervalP1, this.p1);\r\n        this.velocity.x = 0;\r\n        this.velocity.y = 0;\r\n        this.drag.start();\r\n\r\n        this._rafStopLoop();\r\n        this._rafRenderLoop();\r\n      }\r\n    } else if (this._numActivePoints > 1 && !this.isZooming) {\r\n      this._finishDrag();\r\n\r\n      this.isZooming = true;\r\n\r\n      // Adjust starting points\r\n      this._updateStartPoints();\r\n\r\n      this.zoomLevels.start();\r\n\r\n      this._rafStopLoop();\r\n      this._rafRenderLoop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _finishDrag() {\r\n    if (this.isDragging) {\r\n      this.isDragging = false;\r\n\r\n      // Try to calculate velocity,\r\n      // if it wasn't calculated yet in drag.change\r\n      if (!this._velocityCalculated) {\r\n        this._updateVelocity(true);\r\n      }\r\n\r\n      this.drag.end();\r\n      this.dragAxis = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {PointerEvent} e\r\n   */\r\n  onPointerUp(e) {\r\n    if (!this._numActivePoints) {\r\n      return;\r\n    }\r\n\r\n    this._updatePoints(e, 'up');\r\n\r\n    if (this.pswp.dispatch('pointerUp', { originalEvent: e }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this._numActivePoints === 0) {\r\n      this._rafStopLoop();\r\n\r\n      if (this.isDragging) {\r\n        this._finishDrag();\r\n      } else if (!this.isZooming && !this.isMultitouch) {\r\n        //this.zoomLevels.correctZoomPan();\r\n        this._finishTap(e);\r\n      }\r\n    }\r\n\r\n    if (this._numActivePoints < 2 && this.isZooming) {\r\n      this.isZooming = false;\r\n      this.zoomLevels.end();\r\n\r\n      if (this._numActivePoints === 1) {\r\n        // Since we have 1 point left, we need to reinitiate drag\r\n        this.dragAxis = null;\r\n        this._updateStartPoints();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _rafRenderLoop() {\r\n    if (this.isDragging || this.isZooming) {\r\n      this._updateVelocity();\r\n\r\n      if (this.isDragging) {\r\n        // make sure that pointer moved since the last update\r\n        if (!pointsEqual(this.p1, this.prevP1)) {\r\n          this.drag.change();\r\n        }\r\n      } else /* if (this.isZooming) */ {\r\n        if (!pointsEqual(this.p1, this.prevP1)\r\n            || !pointsEqual(this.p2, this.prevP2)) {\r\n          this.zoomLevels.change();\r\n        }\r\n      }\r\n\r\n      this._updatePrevPoints();\r\n      this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update velocity at 50ms interval\r\n   *\r\n   * @private\r\n   * @param {boolean} [force]\r\n   */\r\n  _updateVelocity(force) {\r\n    const time = Date.now();\r\n    const duration = time - this._intervalTime;\r\n\r\n    if (duration < 50 && !force) {\r\n      return;\r\n    }\r\n\r\n\r\n    this.velocity.x = this._getVelocity('x', duration);\r\n    this.velocity.y = this._getVelocity('y', duration);\r\n\r\n    this._intervalTime = time;\r\n    equalizePoints(this._intervalP1, this.p1);\r\n    this._velocityCalculated = true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {PointerEvent} e\r\n   */\r\n  _finishTap(e) {\r\n    const { mainScroll } = this.pswp;\r\n\r\n    // Do not trigger tap events if main scroll is shifted\r\n    if (mainScroll.isShifted()) {\r\n      // restore main scroll position\r\n      // (usually happens if stopped in the middle of animation)\r\n      mainScroll.moveIndexBy(0, true);\r\n      return;\r\n    }\r\n\r\n    // Do not trigger tap for touchcancel or pointercancel\r\n    if (e.type.indexOf('cancel') > 0) {\r\n      return;\r\n    }\r\n\r\n    // Trigger click instead of tap for mouse events\r\n    if (e.type === 'mouseup' || e.pointerType === 'mouse') {\r\n      this.tapHandler.click(this.startP1, e);\r\n      return;\r\n    }\r\n\r\n    // Disable delay if there is no doubleTapAction\r\n    const tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0;\r\n\r\n    // If tapTimer is defined - we tapped recently,\r\n    // check if the current tap is close to the previous one,\r\n    // if yes - trigger double tap\r\n    if (this._tapTimer) {\r\n      this._clearTapTimer();\r\n      // Check if two taps were more or less on the same place\r\n      if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {\r\n        this.tapHandler.doubleTap(this.startP1, e);\r\n      }\r\n    } else {\r\n      equalizePoints(this._lastStartP1, this.startP1);\r\n      this._tapTimer = setTimeout(() => {\r\n        this.tapHandler.tap(this.startP1, e);\r\n        this._clearTapTimer();\r\n      }, tapDelay);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _clearTapTimer() {\r\n    if (this._tapTimer) {\r\n      clearTimeout(this._tapTimer);\r\n      this._tapTimer = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get velocity for axis\r\n   *\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @param {number} duration\r\n   * @returns {number}\r\n   */\r\n  _getVelocity(axis, duration) {\r\n    // displacement is like distance, but can be negative.\r\n    const displacement = this.p1[axis] - this._intervalP1[axis];\r\n\r\n    if (Math.abs(displacement) > 1 && duration > 5) {\r\n      return displacement / duration;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _rafStopLoop() {\r\n    if (this.raf) {\r\n      cancelAnimationFrame(this.raf);\r\n      this.raf = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {PointerEvent} e\r\n   * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type\r\n   */\r\n  _preventPointerEventBehaviour(e, pointerType) {\r\n    const preventPointerEvent = this.pswp.applyFilters('preventPointerEvent', true, e, pointerType);\r\n    if (preventPointerEvent) {\r\n      e.preventDefault();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses and normalizes points from the touch, mouse or pointer event.\r\n   * Updates p1 and p2.\r\n   *\r\n   * @private\r\n   * @param {PointerEvent | TouchEvent} e\r\n   * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type\r\n   */\r\n  _updatePoints(e, pointerType) {\r\n    if (this._pointerEventEnabled) {\r\n      const pointerEvent = /** @type {PointerEvent} */ (e);\r\n      // Try to find the current pointer in ongoing pointers by its ID\r\n      const pointerIndex = this._ongoingPointers.findIndex((ongoingPointer) => {\r\n        return ongoingPointer.id === pointerEvent.pointerId;\r\n      });\r\n\r\n      if (pointerType === 'up' && pointerIndex > -1) {\r\n        // release the pointer - remove it from ongoing\r\n        this._ongoingPointers.splice(pointerIndex, 1);\r\n      } else if (pointerType === 'down' && pointerIndex === -1) {\r\n        // add new pointer\r\n        this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, { x: 0, y: 0 }));\r\n      } else if (pointerIndex > -1) {\r\n        // update existing pointer\r\n        this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);\r\n      }\r\n\r\n      this._numActivePoints = this._ongoingPointers.length;\r\n\r\n      // update points that PhotoSwipe uses\r\n      // to calculate position and scale\r\n      if (this._numActivePoints > 0) {\r\n        equalizePoints(this.p1, this._ongoingPointers[0]);\r\n      }\r\n\r\n      if (this._numActivePoints > 1) {\r\n        equalizePoints(this.p2, this._ongoingPointers[1]);\r\n      }\r\n    } else {\r\n      const touchEvent = /** @type {TouchEvent} */ (e);\r\n\r\n      this._numActivePoints = 0;\r\n      if (touchEvent.type.indexOf('touch') > -1) {\r\n        // Touch Event\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\r\n        if (touchEvent.touches && touchEvent.touches.length > 0) {\r\n          this._convertEventPosToPoint(touchEvent.touches[0], this.p1);\r\n          this._numActivePoints++;\r\n          if (touchEvent.touches.length > 1) {\r\n            this._convertEventPosToPoint(touchEvent.touches[1], this.p2);\r\n            this._numActivePoints++;\r\n          }\r\n        }\r\n      } else {\r\n        // Mouse Event\r\n        this._convertEventPosToPoint(/** @type {PointerEvent} */ (e), this.p1);\r\n        if (pointerType === 'up') {\r\n          // clear all points on mouseup\r\n          this._numActivePoints = 0;\r\n        } else {\r\n          this._numActivePoints++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** update points that were used during previous rAF tick\r\n   * @private\r\n   */\r\n  _updatePrevPoints() {\r\n    equalizePoints(this.prevP1, this.p1);\r\n    equalizePoints(this.prevP2, this.p2);\r\n  }\r\n\r\n  /** update points at the start of gesture\r\n   * @private\r\n   */\r\n  _updateStartPoints() {\r\n    equalizePoints(this.startP1, this.p1);\r\n    equalizePoints(this.startP2, this.p2);\r\n    this._updatePrevPoints();\r\n  }\r\n\r\n  /** @private */\r\n  _calculateDragDirection() {\r\n    if (this.pswp.mainScroll.isShifted()) {\r\n      // if main scroll position is shifted  direction is always horizontal\r\n      this.dragAxis = 'x';\r\n    } else {\r\n      // calculate delta of the last touchmove tick\r\n      const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);\r\n\r\n      if (diff !== 0) {\r\n        // check if pointer was shifted horizontally or vertically\r\n        const axisToCheck = diff > 0 ? 'x' : 'y';\r\n\r\n        if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {\r\n          this.dragAxis = axisToCheck;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts touch, pointer or mouse event\r\n   * to PhotoSwipe point.\r\n   *\r\n   * @private\r\n   * @param {Touch | PointerEvent} e\r\n   * @param {Point} p\r\n   * @returns {Point}\r\n   */\r\n  _convertEventPosToPoint(e, p) {\r\n    p.x = e.pageX - this.pswp.offset.x;\r\n    p.y = e.pageY - this.pswp.offset.y;\r\n\r\n    if ('pointerId' in e) {\r\n      p.id = e.pointerId;\r\n    } else if (e.identifier !== undefined) {\r\n      p.id = e.identifier;\r\n    }\r\n\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {PointerEvent} e\r\n   */\r\n  _onClick(e) {\r\n    // Do not allow click event to pass through after drag\r\n    if (this.pswp.mainScroll.isShifted()) {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Gestures;\r\n","import {\r\n  setTransform,\r\n  createElement,\r\n} from './util/util.js';\r\n\r\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('./slide/slide.js').default} Slide */\r\n\r\n/** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */\r\n\r\nconst MAIN_SCROLL_END_FRICTION = 0.35;\r\n\r\n\r\n// const MIN_SWIPE_TRANSITION_DURATION = 250;\r\n// const MAX_SWIPE_TRABSITION_DURATION = 500;\r\n// const DEFAULT_SWIPE_TRANSITION_DURATION = 333;\r\n\r\n/**\r\n * Handles movement of the main scrolling container\r\n * (for example, it repositions when user swipes left or right).\r\n *\r\n * Also stores its state.\r\n */\r\nclass MainScroll {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    this.x = 0;\r\n    this.slideWidth = 0;\r\n    /** @private */\r\n    this._currPositionIndex = 0;\r\n    /** @private */\r\n    this._prevPositionIndex = 0;\r\n    /** @private */\r\n    this._containerShiftIndex = -1;\r\n\r\n    /** @type {ItemHolder[]} */\r\n    this.itemHolders = [];\r\n  }\r\n\r\n  /**\r\n   * Position the scroller and slide containers\r\n   * according to viewport size.\r\n   *\r\n   * @param {boolean} [resizeSlides] Whether slides content should resized\r\n   */\r\n  resize(resizeSlides) {\r\n    const { pswp } = this;\r\n    const newSlideWidth = Math.round(\r\n      pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing\r\n    );\r\n    // Mobile browsers might trigger a resize event during a gesture.\r\n    // (due to toolbar appearing or hiding).\r\n    // Avoid re-adjusting main scroll position if width wasn't changed\r\n    const slideWidthChanged = (newSlideWidth !== this.slideWidth);\r\n\r\n    if (slideWidthChanged) {\r\n      this.slideWidth = newSlideWidth;\r\n      this.moveTo(this.getCurrSlideX());\r\n    }\r\n\r\n    this.itemHolders.forEach((itemHolder, index) => {\r\n      if (slideWidthChanged) {\r\n        setTransform(itemHolder.el, (index + this._containerShiftIndex)\r\n                                    * this.slideWidth);\r\n      }\r\n\r\n      if (resizeSlides && itemHolder.slide) {\r\n        itemHolder.slide.resize();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reset X position of the main scroller to zero\r\n   */\r\n  resetPosition() {\r\n    // Position on the main scroller (offset)\r\n    // it is independent from slide index\r\n    this._currPositionIndex = 0;\r\n    this._prevPositionIndex = 0;\r\n\r\n    // This will force recalculation of size on next resize()\r\n    this.slideWidth = 0;\r\n\r\n    // _containerShiftIndex*viewportSize will give you amount of transform of the current slide\r\n    this._containerShiftIndex = -1;\r\n  }\r\n\r\n  /**\r\n   * Create and append array of three items\r\n   * that hold data about slides in DOM\r\n   */\r\n  appendHolders() {\r\n    this.itemHolders = [];\r\n\r\n    // append our three slide holders -\r\n    // previous, current, and next\r\n    for (let i = 0; i < 3; i++) {\r\n      const el = createElement('pswp__item', 'div', this.pswp.container);\r\n      el.setAttribute('role', 'group');\r\n      el.setAttribute('aria-roledescription', 'slide');\r\n      el.setAttribute('aria-hidden', 'true');\r\n\r\n      // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)\r\n      el.style.display = (i === 1) ? 'block' : 'none';\r\n\r\n      this.itemHolders.push({\r\n        el,\r\n        //index: -1\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether the main scroll can be horizontally swiped to the next or previous slide.\r\n   * @returns {boolean}\r\n   */\r\n  canBeSwiped() {\r\n    return this.pswp.getNumItems() > 1;\r\n  }\r\n\r\n  /**\r\n   * Move main scroll by X amount of slides.\r\n   * For example:\r\n   *   `-1` will move to the previous slide,\r\n   *    `0` will reset the scroll position of the current slide,\r\n   *    `3` will move three slides forward\r\n   *\r\n   * If loop option is enabled - index will be automatically looped too,\r\n   * (for example `-1` will move to the last slide of the gallery).\r\n   *\r\n   * @param {number} diff\r\n   * @param {boolean} [animate]\r\n   * @param {number} [velocityX]\r\n   * @returns {boolean} whether index was changed or not\r\n   */\r\n  moveIndexBy(diff, animate, velocityX) {\r\n    const { pswp } = this;\r\n    let newIndex = pswp.potentialIndex + diff;\r\n    const numSlides = pswp.getNumItems();\r\n\r\n    if (pswp.canLoop()) {\r\n      newIndex = pswp.getLoopedIndex(newIndex);\r\n      const distance = (diff + numSlides) % numSlides;\r\n      if (distance <= numSlides / 2) {\r\n        // go forward\r\n        diff = distance;\r\n      } else {\r\n        // go backwards\r\n        diff = distance - numSlides;\r\n      }\r\n    } else {\r\n      if (newIndex < 0) {\r\n        newIndex = 0;\r\n      } else if (newIndex >= numSlides) {\r\n        newIndex = numSlides - 1;\r\n      }\r\n      diff = newIndex - pswp.potentialIndex;\r\n    }\r\n\r\n    pswp.potentialIndex = newIndex;\r\n    this._currPositionIndex -= diff;\r\n\r\n    pswp.animations.stopMainScroll();\r\n\r\n    const destinationX = this.getCurrSlideX();\r\n    if (!animate) {\r\n      this.moveTo(destinationX);\r\n      this.updateCurrItem();\r\n    } else {\r\n      pswp.animations.startSpring({\r\n        isMainScroll: true,\r\n        start: this.x,\r\n        end: destinationX,\r\n        velocity: velocityX || 0,\r\n        naturalFrequency: 30,\r\n        dampingRatio: 1, //0.7,\r\n        onUpdate: (x) => {\r\n          this.moveTo(x);\r\n        },\r\n        onComplete: () => {\r\n          this.updateCurrItem();\r\n          pswp.appendHeavy();\r\n        }\r\n      });\r\n\r\n      let currDiff = pswp.potentialIndex - pswp.currIndex;\r\n      if (pswp.canLoop()) {\r\n        const currDistance = (currDiff + numSlides) % numSlides;\r\n        if (currDistance <= numSlides / 2) {\r\n          // go forward\r\n          currDiff = currDistance;\r\n        } else {\r\n          // go backwards\r\n          currDiff = currDistance - numSlides;\r\n        }\r\n      }\r\n\r\n      // Force-append new slides during transition\r\n      // if difference between slides is more than 1\r\n      if (Math.abs(currDiff) > 1) {\r\n        this.updateCurrItem();\r\n      }\r\n    }\r\n\r\n    return Boolean(diff);\r\n  }\r\n\r\n  /**\r\n   * X position of the main scroll for the current slide\r\n   * (ignores position during dragging)\r\n   * @returns {number}\r\n   */\r\n  getCurrSlideX() {\r\n    return this.slideWidth * this._currPositionIndex;\r\n  }\r\n\r\n  /**\r\n   * Whether scroll position is shifted.\r\n   * For example, it will return true if the scroll is being dragged or animated.\r\n   * @returns {boolean}\r\n   */\r\n  isShifted() {\r\n    return this.x !== this.getCurrSlideX();\r\n  }\r\n\r\n  /**\r\n   * Update slides X positions and set their content\r\n   */\r\n  updateCurrItem() {\r\n    const { pswp } = this;\r\n    const positionDifference = this._prevPositionIndex - this._currPositionIndex;\r\n\r\n    if (!positionDifference) {\r\n      return;\r\n    }\r\n\r\n    this._prevPositionIndex = this._currPositionIndex;\r\n\r\n    pswp.currIndex = pswp.potentialIndex;\r\n\r\n    let diffAbs = Math.abs(positionDifference);\r\n    /** @type {ItemHolder | undefined} */\r\n    let tempHolder;\r\n\r\n    if (diffAbs >= 3) {\r\n      this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);\r\n      diffAbs = 3;\r\n\r\n      // If slides are changed by 3 screens or more - clean up previous slides\r\n      this.itemHolders.forEach((itemHolder) => {\r\n        itemHolder.slide?.destroy();\r\n        itemHolder.slide = undefined;\r\n      });\r\n    }\r\n\r\n    for (let i = 0; i < diffAbs; i++) {\r\n      if (positionDifference > 0) {\r\n        tempHolder = this.itemHolders.shift();\r\n        if (tempHolder) {\r\n          this.itemHolders[2] = tempHolder; // move first to last\r\n\r\n          this._containerShiftIndex++;\r\n\r\n          setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);\r\n\r\n          pswp.setContent(tempHolder, (pswp.currIndex - diffAbs) + i + 2);\r\n        }\r\n      } else {\r\n        tempHolder = this.itemHolders.pop();\r\n        if (tempHolder) {\r\n          this.itemHolders.unshift(tempHolder); // move last to first\r\n\r\n          this._containerShiftIndex--;\r\n\r\n          setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);\r\n\r\n          pswp.setContent(tempHolder, (pswp.currIndex + diffAbs) - i - 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Reset transfrom every 50ish navigations in one direction.\r\n    //\r\n    // Otherwise transform will keep growing indefinitely,\r\n    // which might cause issues as browsers have a maximum transform limit.\r\n    // I wasn't able to reach it, but just to be safe.\r\n    // This should not cause noticable lag.\r\n    if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {\r\n      this.resetPosition();\r\n      this.resize();\r\n    }\r\n\r\n    // Pan transition might be running (and consntantly updating pan position)\r\n    pswp.animations.stopAllPan();\r\n\r\n    this.itemHolders.forEach((itemHolder, i) => {\r\n      if (itemHolder.slide) {\r\n        // Slide in the 2nd holder is always active\r\n        itemHolder.slide.setIsActive(i === 1);\r\n      }\r\n    });\r\n\r\n    pswp.currSlide = this.itemHolders[1]?.slide;\r\n    pswp.contentLoader.updateLazy(positionDifference);\r\n\r\n    if (pswp.currSlide) {\r\n      pswp.currSlide.applyCurrentZoomPan();\r\n    }\r\n\r\n    pswp.dispatch('change');\r\n  }\r\n\r\n  /**\r\n   * Move the X position of the main scroll container\r\n   *\r\n   * @param {number} x\r\n   * @param {boolean} [dragging]\r\n   */\r\n  moveTo(x, dragging) {\r\n    if (!this.pswp.canLoop() && dragging) {\r\n      // Apply friction\r\n      let newSlideIndexOffset = ((this.slideWidth * this._currPositionIndex) - x) / this.slideWidth;\r\n      newSlideIndexOffset += this.pswp.currIndex;\r\n      const delta = Math.round(x - this.x);\r\n\r\n      if ((newSlideIndexOffset < 0 && delta > 0)\r\n          || (newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0)) {\r\n        x = this.x + (delta * MAIN_SCROLL_END_FRICTION);\r\n      }\r\n    }\r\n\r\n    this.x = x;\r\n\r\n    if (this.pswp.container) {\r\n      setTransform(this.pswp.container, x);\r\n    }\r\n\r\n    this.pswp.dispatch('moveMainScroll', { x, dragging: dragging ?? false });\r\n  }\r\n}\r\n\r\nexport default MainScroll;\r\n","import { specialKeyUsed } from './util/util.js';\r\n\r\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\r\n\r\n/**\r\n * @template T\r\n * @typedef {import('./types.js').Methods<T>} Methods<T>\r\n */\r\n\r\nconst KeyboardKeyCodesMap = {\r\n  Escape: 27,\r\n  z: 90,\r\n  ArrowLeft: 37,\r\n  ArrowUp: 38,\r\n  ArrowRight: 39,\r\n  ArrowDown: 40,\r\n  Tab: 9,\r\n};\r\n\r\n/**\r\n * @template {keyof KeyboardKeyCodesMap} T\r\n * @param {T} key\r\n * @param {boolean} isKeySupported\r\n * @returns {T | number | undefined}\r\n */\r\nconst getKeyboardEventKey = (key, isKeySupported) => {\r\n  return isKeySupported ? key : KeyboardKeyCodesMap[key];\r\n};\r\n\r\n/**\r\n * - Manages keyboard shortcuts.\r\n * - Helps trap focus within photoswipe.\r\n */\r\nclass Keyboard {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    /** @private */\r\n    this._wasFocused = false;\r\n\r\n    pswp.on('bindEvents', () => {\r\n      if (pswp.options.trapFocus) {\r\n        // Dialog was likely opened by keyboard if initial point is not defined\r\n        if (!pswp.options.initialPointerPos) {\r\n          // focus causes layout,\r\n          // which causes lag during the animation,\r\n          // that's why we delay it until the opener transition ends\r\n          this._focusRoot();\r\n        }\r\n\r\n        pswp.events.add(\r\n          document,\r\n          'focusin',\r\n          /** @type EventListener */(this._onFocusIn.bind(this))\r\n        );\r\n      }\r\n\r\n      pswp.events.add(document, 'keydown', /** @type EventListener */(this._onKeyDown.bind(this)));\r\n    });\r\n\r\n    const lastActiveElement = /** @type {HTMLElement} */ (document.activeElement);\r\n    pswp.on('destroy', () => {\r\n      if (pswp.options.returnFocus\r\n          && lastActiveElement\r\n          && this._wasFocused) {\r\n        lastActiveElement.focus();\r\n      }\r\n    });\r\n  }\r\n\r\n  /** @private */\r\n  _focusRoot() {\r\n    if (!this._wasFocused && this.pswp.element) {\r\n      this.pswp.element.focus();\r\n      this._wasFocused = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {KeyboardEvent} e\r\n   */\r\n  _onKeyDown(e) {\r\n    const { pswp } = this;\r\n\r\n    if (pswp.dispatch('keydown', { originalEvent: e }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (specialKeyUsed(e)) {\r\n      // don't do anything if special key pressed\r\n      // to prevent from overriding default browser actions\r\n      // for example, in Chrome on Mac cmd+arrow-left returns to previous page\r\n      return;\r\n    }\r\n\r\n    /** @type {Methods<PhotoSwipe> | undefined} */\r\n    let keydownAction;\r\n    /** @type {'x' | 'y' | undefined} */\r\n    let axis;\r\n    let isForward = false;\r\n    const isKeySupported = 'key' in e;\r\n\r\n    switch (isKeySupported ? e.key : e.keyCode) {\r\n      case getKeyboardEventKey('Escape', isKeySupported):\r\n        if (pswp.options.escKey) {\r\n          keydownAction = 'close';\r\n        }\r\n        break;\r\n      case getKeyboardEventKey('z', isKeySupported):\r\n        keydownAction = 'toggleZoom';\r\n        break;\r\n      case getKeyboardEventKey('ArrowLeft', isKeySupported):\r\n        axis = 'x';\r\n        break;\r\n      case getKeyboardEventKey('ArrowUp', isKeySupported):\r\n        axis = 'y';\r\n        break;\r\n      case getKeyboardEventKey('ArrowRight', isKeySupported):\r\n        axis = 'x';\r\n        isForward = true;\r\n        break;\r\n      case getKeyboardEventKey('ArrowDown', isKeySupported):\r\n        isForward = true;\r\n        axis = 'y';\r\n        break;\r\n      case getKeyboardEventKey('Tab', isKeySupported):\r\n        this._focusRoot();\r\n        break;\r\n      default:\r\n    }\r\n\r\n    // if left/right/top/bottom key\r\n    if (axis) {\r\n      // prevent page scroll\r\n      e.preventDefault();\r\n\r\n      const { currSlide } = pswp;\r\n\r\n      if (pswp.options.arrowKeys\r\n          && axis === 'x'\r\n          && pswp.getNumItems() > 1) {\r\n        keydownAction = isForward ? 'next' : 'prev';\r\n      } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {\r\n        // up/down arrow keys pan the image vertically\r\n        // left/right arrow keys pan horizontally.\r\n        // Unless there is only one image,\r\n        // or arrowKeys option is disabled\r\n        currSlide.pan[axis] += isForward ? -80 : 80;\r\n        currSlide.panTo(currSlide.pan.x, currSlide.pan.y);\r\n      }\r\n    }\r\n\r\n    if (keydownAction) {\r\n      e.preventDefault();\r\n      // @ts-ignore\r\n      pswp[keydownAction]();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trap focus inside photoswipe\r\n   *\r\n   * @private\r\n   * @param {FocusEvent} e\r\n   */\r\n  _onFocusIn(e) {\r\n    const { template } = this.pswp;\r\n    if (template\r\n        && document !== e.target\r\n        && template !== e.target\r\n        && !template.contains(/** @type {Node} */ (e.target))) {\r\n      // focus root element\r\n      template.focus();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Keyboard;\r\n","import { setTransitionStyle, removeTransitionStyle } from './util.js';\r\n\r\nconst DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';\r\n\r\n/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */\r\n\r\n/** @typedef {Object} DefaultCssAnimationProps\r\n *\r\n * @prop {HTMLElement} target\r\n * @prop {number} [duration]\r\n * @prop {string} [easing]\r\n * @prop {string} [transform]\r\n * @prop {string} [opacity]\r\n * */\r\n\r\n/** @typedef {SharedAnimationProps & DefaultCssAnimationProps} CssAnimationProps */\r\n\r\n/**\r\n * Runs CSS transition.\r\n */\r\nclass CSSAnimation {\r\n  /**\r\n   * onComplete can be unpredictable, be careful about current state\r\n   *\r\n   * @param {CssAnimationProps} props\r\n   */\r\n  constructor(props) {\r\n    this.props = props;\r\n    const {\r\n      target,\r\n      onComplete,\r\n      transform,\r\n      onFinish = () => {},\r\n      duration = 333,\r\n      easing = DEFAULT_EASING,\r\n    } = props;\r\n\r\n    this.onFinish = onFinish;\r\n\r\n    // support only transform and opacity\r\n    const prop = transform ? 'transform' : 'opacity';\r\n    const propValue = props[prop] ?? '';\r\n\r\n    /** @private */\r\n    this._target = target;\r\n    /** @private */\r\n    this._onComplete = onComplete;\r\n    /** @private */\r\n    this._finished = false;\r\n\r\n    /** @private */\r\n    this._onTransitionEnd = this._onTransitionEnd.bind(this);\r\n\r\n    // Using timeout hack to make sure that animation\r\n    // starts even if the animated property was changed recently,\r\n    // otherwise transitionend might not fire or transition won't start.\r\n    // https://drafts.csswg.org/css-transitions/#starting\r\n    //\r\n    // \\_()_/\r\n    /** @private */\r\n    this._helperTimeout = setTimeout(() => {\r\n      setTransitionStyle(target, prop, duration, easing);\r\n      this._helperTimeout = setTimeout(() => {\r\n        target.addEventListener('transitionend', this._onTransitionEnd, false);\r\n        target.addEventListener('transitioncancel', this._onTransitionEnd, false);\r\n\r\n        // Safari occasionally does not emit transitionend event\r\n        // if element property was modified during the transition,\r\n        // which may be caused by resize or third party component,\r\n        // using timeout as a safety fallback\r\n        this._helperTimeout = setTimeout(() => {\r\n          this._finalizeAnimation();\r\n        }, duration + 500);\r\n        target.style[prop] = propValue;\r\n      }, 30); // Do not reduce this number\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {TransitionEvent} e\r\n   */\r\n  _onTransitionEnd(e) {\r\n    if (e.target === this._target) {\r\n      this._finalizeAnimation();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _finalizeAnimation() {\r\n    if (!this._finished) {\r\n      this._finished = true;\r\n      this.onFinish();\r\n      if (this._onComplete) {\r\n        this._onComplete();\r\n      }\r\n    }\r\n  }\r\n\r\n  // Destroy is called automatically onFinish\r\n  destroy() {\r\n    if (this._helperTimeout) {\r\n      clearTimeout(this._helperTimeout);\r\n    }\r\n    removeTransitionStyle(this._target);\r\n    this._target.removeEventListener('transitionend', this._onTransitionEnd, false);\r\n    this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);\r\n    if (!this._finished) {\r\n      this._finalizeAnimation();\r\n    }\r\n  }\r\n}\r\n\r\nexport default CSSAnimation;\r\n","const DEFAULT_NATURAL_FREQUENCY = 12;\r\nconst DEFAULT_DAMPING_RATIO = 0.75;\r\n\r\n/**\r\n * Spring easing helper\r\n */\r\nclass SpringEaser {\r\n  /**\r\n   * @param {number} initialVelocity Initial velocity, px per ms.\r\n   *\r\n   * @param {number} [dampingRatio]\r\n   * Determines how bouncy animation will be.\r\n   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.\r\n   * \"overshoot\" refers to part of animation that\r\n   * goes beyond the final value.\r\n   *\r\n   * @param {number} [naturalFrequency]\r\n   * Determines how fast animation will slow down.\r\n   * The higher value - the stiffer the transition will be,\r\n   * and the faster it will slow down.\r\n   * Recommended value from 10 to 50\r\n   */\r\n  constructor(initialVelocity, dampingRatio, naturalFrequency) {\r\n    this.velocity = initialVelocity * 1000; // convert to \"pixels per second\"\r\n\r\n    // https://en.wikipedia.org/wiki/Damping_ratio\r\n    this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO;\r\n\r\n    // https://en.wikipedia.org/wiki/Natural_frequency\r\n    this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;\r\n\r\n    this._dampedFrequency = this._naturalFrequency;\r\n\r\n    if (this._dampingRatio < 1) {\r\n      this._dampedFrequency *= Math.sqrt(1 - this._dampingRatio * this._dampingRatio);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} deltaPosition Difference between current and end position of the animation\r\n   * @param {number} deltaTime Frame duration in milliseconds\r\n   *\r\n   * @returns {number} Displacement, relative to the end position.\r\n   */\r\n  easeFrame(deltaPosition, deltaTime) {\r\n    // Inspired by Apple Webkit and Android spring function implementation\r\n    // https://en.wikipedia.org/wiki/Oscillation\r\n    // https://en.wikipedia.org/wiki/Damping_ratio\r\n    // we ignore mass (assume that it's 1kg)\r\n\r\n    let displacement = 0;\r\n    let coeff;\r\n\r\n    deltaTime /= 1000;\r\n\r\n    const naturalDumpingPow = Math.E ** (-this._dampingRatio * this._naturalFrequency * deltaTime);\r\n\r\n    if (this._dampingRatio === 1) {\r\n      coeff = this.velocity + this._naturalFrequency * deltaPosition;\r\n\r\n      displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;\r\n\r\n      this.velocity = displacement\r\n                        * (-this._naturalFrequency) + coeff\r\n                        * naturalDumpingPow;\r\n    } else if (this._dampingRatio < 1) {\r\n      coeff = (1 / this._dampedFrequency)\r\n                * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);\r\n\r\n      const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);\r\n      const dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);\r\n\r\n      displacement = naturalDumpingPow\r\n                       * (deltaPosition * dumpedFCos + coeff * dumpedFSin);\r\n\r\n      this.velocity = displacement\r\n                        * (-this._naturalFrequency)\r\n                        * this._dampingRatio\r\n                        + naturalDumpingPow\r\n                        * (-this._dampedFrequency * deltaPosition * dumpedFSin\r\n                        + this._dampedFrequency * coeff * dumpedFCos);\r\n    }\r\n\r\n    // Overdamped (>1) damping ratio is not supported\r\n\r\n    return displacement;\r\n  }\r\n}\r\n\r\nexport default SpringEaser;\r\n","import SpringEaser from './spring-easer.js';\r\n\r\n/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */\r\n\r\n/**\r\n * @typedef {Object} DefaultSpringAnimationProps\r\n *\r\n * @prop {number} start\r\n * @prop {number} end\r\n * @prop {number} velocity\r\n * @prop {number} [dampingRatio]\r\n * @prop {number} [naturalFrequency]\r\n * @prop {(end: number) => void} onUpdate\r\n */\r\n\r\n/** @typedef {SharedAnimationProps & DefaultSpringAnimationProps} SpringAnimationProps */\r\n\r\nclass SpringAnimation {\r\n  /**\r\n   * @param {SpringAnimationProps} props\r\n   */\r\n  constructor(props) {\r\n    this.props = props;\r\n    this._raf = 0;\r\n\r\n    const {\r\n      start,\r\n      end,\r\n      velocity,\r\n      onUpdate,\r\n      onComplete,\r\n      onFinish = () => {},\r\n      dampingRatio,\r\n      naturalFrequency\r\n    } = props;\r\n\r\n    this.onFinish = onFinish;\r\n\r\n    const easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);\r\n    let prevTime = Date.now();\r\n    let deltaPosition = start - end;\r\n\r\n    const animationLoop = () => {\r\n      if (this._raf) {\r\n        deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime);\r\n\r\n        // Stop the animation if velocity is low and position is close to end\r\n        if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {\r\n          // Finalize the animation\r\n          onUpdate(end);\r\n          if (onComplete) {\r\n            onComplete();\r\n          }\r\n          this.onFinish();\r\n        } else {\r\n          prevTime = Date.now();\r\n          onUpdate(deltaPosition + end);\r\n          this._raf = requestAnimationFrame(animationLoop);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._raf = requestAnimationFrame(animationLoop);\r\n  }\r\n\r\n  // Destroy is called automatically onFinish\r\n  destroy() {\r\n    if (this._raf >= 0) {\r\n      cancelAnimationFrame(this._raf);\r\n    }\r\n    this._raf = 0;\r\n  }\r\n}\r\n\r\nexport default SpringAnimation;\r\n","import CSSAnimation from './css-animation.js';\r\nimport SpringAnimation from './spring-animation.js';\r\n\r\n/** @typedef {import('./css-animation.js').CssAnimationProps} CssAnimationProps */\r\n/** @typedef {import('./spring-animation.js').SpringAnimationProps} SpringAnimationProps */\r\n\r\n/** @typedef {Object} SharedAnimationProps\r\n * @prop {string} [name]\r\n * @prop {boolean} [isPan]\r\n * @prop {boolean} [isMainScroll]\r\n * @prop {VoidFunction} [onComplete]\r\n * @prop {VoidFunction} [onFinish]\r\n */\r\n\r\n/** @typedef {SpringAnimation | CSSAnimation} Animation */\r\n/** @typedef {SpringAnimationProps | CssAnimationProps} AnimationProps */\r\n\r\n/**\r\n * Manages animations\r\n */\r\nclass Animations {\r\n  constructor() {\r\n    /** @type {Animation[]} */\r\n    this.activeAnimations = [];\r\n  }\r\n\r\n  /**\r\n   * @param {SpringAnimationProps} props\r\n   */\r\n  startSpring(props) {\r\n    this._start(props, true);\r\n  }\r\n\r\n  /**\r\n   * @param {CssAnimationProps} props\r\n   */\r\n  startTransition(props) {\r\n    this._start(props);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {AnimationProps} props\r\n   * @param {boolean} [isSpring]\r\n   * @returns {Animation}\r\n   */\r\n  _start(props, isSpring) {\r\n    const animation = isSpring\r\n      ? new SpringAnimation(/** @type SpringAnimationProps */ (props))\r\n      : new CSSAnimation(/** @type CssAnimationProps */ (props));\r\n\r\n    this.activeAnimations.push(animation);\r\n    animation.onFinish = () => this.stop(animation);\r\n\r\n    return animation;\r\n  }\r\n\r\n  /**\r\n   * @param {Animation} animation\r\n   */\r\n  stop(animation) {\r\n    animation.destroy();\r\n    const index = this.activeAnimations.indexOf(animation);\r\n    if (index > -1) {\r\n      this.activeAnimations.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  stopAll() { // _stopAllAnimations\r\n    this.activeAnimations.forEach((animation) => {\r\n      animation.destroy();\r\n    });\r\n    this.activeAnimations = [];\r\n  }\r\n\r\n  /**\r\n   * Stop all pan or zoom transitions\r\n   */\r\n  stopAllPan() {\r\n    this.activeAnimations = this.activeAnimations.filter((animation) => {\r\n      if (animation.props.isPan) {\r\n        animation.destroy();\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  stopMainScroll() {\r\n    this.activeAnimations = this.activeAnimations.filter((animation) => {\r\n      if (animation.props.isMainScroll) {\r\n        animation.destroy();\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns true if main scroll transition is running\r\n   */\r\n  // isMainScrollRunning() {\r\n  //   return this.activeAnimations.some((animation) => {\r\n  //     return animation.props.isMainScroll;\r\n  //   });\r\n  // }\r\n\r\n  /**\r\n   * Returns true if any pan or zoom transition is running\r\n   */\r\n  isPanRunning() {\r\n    return this.activeAnimations.some((animation) => {\r\n      return animation.props.isPan;\r\n    });\r\n  }\r\n}\r\n\r\nexport default Animations;\r\n","/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\r\n\r\n/**\r\n * Handles scroll wheel.\r\n * Can pan and zoom current slide image.\r\n */\r\nclass ScrollWheel {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    pswp.events.add(pswp.element, 'wheel', /** @type EventListener */(this._onWheel.bind(this)));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {WheelEvent} e\r\n   */\r\n  _onWheel(e) {\r\n    e.preventDefault();\r\n    const { currSlide } = this.pswp;\r\n    let { deltaX, deltaY } = e;\r\n\r\n    if (!currSlide) {\r\n      return;\r\n    }\r\n\r\n    if (this.pswp.dispatch('wheel', { originalEvent: e }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (e.ctrlKey || this.pswp.options.wheelToZoom) {\r\n      // zoom\r\n      if (currSlide.isZoomable()) {\r\n        let zoomFactor = -deltaY;\r\n        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {\r\n          zoomFactor *= 0.05;\r\n        } else {\r\n          zoomFactor *= e.deltaMode ? 1 : 0.002;\r\n        }\r\n        zoomFactor = 2 ** zoomFactor;\r\n\r\n        const destZoomLevel = currSlide.currZoomLevel * zoomFactor;\r\n        currSlide.zoomTo(destZoomLevel, {\r\n          x: e.clientX,\r\n          y: e.clientY\r\n        });\r\n      }\r\n    } else {\r\n      // pan\r\n      if (currSlide.isPannable()) {\r\n        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {\r\n          // 18 - average line height\r\n          deltaX *= 18;\r\n          deltaY *= 18;\r\n        }\r\n\r\n        currSlide.panTo(\r\n          currSlide.pan.x - deltaX,\r\n          currSlide.pan.y - deltaY\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ScrollWheel;\r\n","import { createElement } from '../util/util.js';\r\n\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n\r\n/**\r\n * @template T\r\n * @typedef {import('../types.js').Methods<T>} Methods<T>\r\n */\r\n\r\n/**\r\n * @typedef {Object} UIElementMarkupProps\r\n * @prop {boolean} [isCustomSVG]\r\n * @prop {string} inner\r\n * @prop {string} [outlineID]\r\n * @prop {number | string} [size]\r\n */\r\n\r\n/**\r\n * @typedef {Object} UIElementData\r\n * @prop {DefaultUIElements | string} [name]\r\n * @prop {string} [className]\r\n * @prop {UIElementMarkup} [html]\r\n * @prop {boolean} [isButton]\r\n * @prop {keyof HTMLElementTagNameMap} [tagName]\r\n * @prop {string} [title]\r\n * @prop {string} [ariaLabel]\r\n * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]\r\n * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]\r\n * @prop {'bar' | 'wrapper' | 'root'} [appendTo]\r\n * @prop {number} [order]\r\n */\r\n\r\n/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */\r\n\r\n/** @typedef {string | UIElementMarkupProps} UIElementMarkup */\r\n\r\n/**\r\n * @param {UIElementMarkup} [htmlData]\r\n * @returns {string}\r\n */\r\nfunction addElementHTML(htmlData) {\r\n  if (typeof htmlData === 'string') {\r\n    // Allow developers to provide full svg,\r\n    // For example:\r\n    // <svg viewBox=\"0 0 32 32\" width=\"32\" height=\"32\" aria-hidden=\"true\" class=\"pswp__icn\">\r\n    //   <path d=\"...\" />\r\n    //   <circle ... />\r\n    // </svg>\r\n    // Can also be any HTML string.\r\n    return htmlData;\r\n  }\r\n\r\n  if (!htmlData || !htmlData.isCustomSVG) {\r\n    return '';\r\n  }\r\n\r\n  const svgData = htmlData;\r\n  let out = '<svg aria-hidden=\"true\" class=\"pswp__icn\" viewBox=\"0 0 %d %d\" width=\"%d\" height=\"%d\">';\r\n  // replace all %d with size\r\n  out = out.split('%d').join(/** @type {string} */ (svgData.size || 32));\r\n\r\n  // Icons may contain outline/shadow,\r\n  // to make it we \"clone\" base icon shape and add border to it.\r\n  // Icon itself and border are styled via CSS.\r\n  //\r\n  // Property shadowID defines ID of element that should be cloned.\r\n  if (svgData.outlineID) {\r\n    out += '<use class=\"pswp__icn-shadow\" xlink:href=\"#' + svgData.outlineID + '\"/>';\r\n  }\r\n\r\n  out += svgData.inner;\r\n\r\n  out += '</svg>';\r\n\r\n  return out;\r\n}\r\n\r\nclass UIElement {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   * @param {UIElementData} data\r\n   */\r\n  constructor(pswp, data) {\r\n    const name = data.name || data.className;\r\n    let elementHTML = data.html;\r\n\r\n    // @ts-expect-error lookup only by `data.name` maybe?\r\n    if (pswp.options[name] === false) {\r\n      // exit if element is disabled from options\r\n      return;\r\n    }\r\n\r\n    // Allow to override SVG icons from options\r\n    // @ts-expect-error lookup only by `data.name` maybe?\r\n    if (typeof pswp.options[name + 'SVG'] === 'string') {\r\n      // arrowPrevSVG\r\n      // arrowNextSVG\r\n      // closeSVG\r\n      // zoomSVG\r\n      // @ts-expect-error lookup only by `data.name` maybe?\r\n      elementHTML = pswp.options[name + 'SVG'];\r\n    }\r\n\r\n    pswp.dispatch('uiElementCreate', { data });\r\n\r\n    let className = '';\r\n    if (data.isButton) {\r\n      className += 'pswp__button ';\r\n      className += (data.className || `pswp__button--${data.name}`);\r\n    } else {\r\n      className += (data.className || `pswp__${data.name}`);\r\n    }\r\n\r\n    let tagName = data.isButton ? (data.tagName || 'button') : (data.tagName || 'div');\r\n    tagName = /** @type {keyof HTMLElementTagNameMap} */ (tagName.toLowerCase());\r\n    /** @type {HTMLElement} */\r\n    const element = createElement(className, tagName);\r\n\r\n    if (data.isButton) {\r\n      if (tagName === 'button') {\r\n        /** @type {HTMLButtonElement} */ (element).type = 'button';\r\n      }\r\n\r\n      let { title } = data;\r\n      const { ariaLabel } = data;\r\n\r\n      // @ts-expect-error lookup only by `data.name` maybe?\r\n      if (typeof pswp.options[name + 'Title'] === 'string') {\r\n        // @ts-expect-error lookup only by `data.name` maybe?\r\n        title = pswp.options[name + 'Title'];\r\n      }\r\n\r\n      if (title) {\r\n        element.title = title;\r\n      }\r\n\r\n      const ariaText = ariaLabel || title;\r\n      if (ariaText) {\r\n        element.setAttribute('aria-label', ariaText);\r\n      }\r\n    }\r\n\r\n    element.innerHTML = addElementHTML(elementHTML);\r\n\r\n    if (data.onInit) {\r\n      data.onInit(element, pswp);\r\n    }\r\n\r\n    if (data.onClick) {\r\n      element.onclick = (e) => {\r\n        if (typeof data.onClick === 'string') {\r\n          // @ts-ignore\r\n          pswp[data.onClick]();\r\n        } else if (typeof data.onClick === 'function') {\r\n          data.onClick(e, element, pswp);\r\n        }\r\n      };\r\n    }\r\n\r\n    // Top bar is default position\r\n    const appendTo = data.appendTo || 'bar';\r\n    /** @type {HTMLElement | undefined} root element by default */\r\n    let container = pswp.element;\r\n    if (appendTo === 'bar') {\r\n      if (!pswp.topBar) {\r\n        pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);\r\n      }\r\n      container = pswp.topBar;\r\n    } else {\r\n      // element outside of top bar gets a secondary class\r\n      // that makes element fade out on close\r\n      element.classList.add('pswp__hide-on-close');\r\n\r\n      if (appendTo === 'wrapper') {\r\n        container = pswp.scrollWrap;\r\n      }\r\n    }\r\n\r\n    container?.appendChild(pswp.applyFilters('uiElement', element, data));\r\n  }\r\n}\r\n\r\nexport default UIElement;\r\n","/*\r\n  Backward and forward arrow buttons\r\n */\r\n\r\n/** @typedef {import('./ui-element.js').UIElementData} UIElementData */\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n\r\n/**\r\n *\r\n * @param {HTMLElement} element\r\n * @param {PhotoSwipe} pswp\r\n * @param {boolean} [isNextButton]\r\n */\r\nfunction initArrowButton(element, pswp, isNextButton) {\r\n  element.classList.add('pswp__button--arrow');\r\n  // TODO: this should point to a unique id for this instance\r\n  element.setAttribute('aria-controls', 'pswp__items');\r\n  pswp.on('change', () => {\r\n    if (!pswp.options.loop) {\r\n      if (isNextButton) {\r\n        /** @type {HTMLButtonElement} */\r\n        (element).disabled = !(pswp.currIndex < pswp.getNumItems() - 1);\r\n      } else {\r\n        /** @type {HTMLButtonElement} */\r\n        (element).disabled = !(pswp.currIndex > 0);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/** @type {UIElementData} */\r\nexport const arrowPrev = {\r\n  name: 'arrowPrev',\r\n  className: 'pswp__button--arrow--prev',\r\n  title: 'Previous',\r\n  order: 10,\r\n  isButton: true,\r\n  appendTo: 'wrapper',\r\n  html: {\r\n    isCustomSVG: true,\r\n    size: 60,\r\n    inner: '<path d=\"M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z\" id=\"pswp__icn-arrow\"/>',\r\n    outlineID: 'pswp__icn-arrow'\r\n  },\r\n  onClick: 'prev',\r\n  onInit: initArrowButton\r\n};\r\n\r\n/** @type {UIElementData} */\r\nexport const arrowNext = {\r\n  name: 'arrowNext',\r\n  className: 'pswp__button--arrow--next',\r\n  title: 'Next',\r\n  order: 11,\r\n  isButton: true,\r\n  appendTo: 'wrapper',\r\n  html: {\r\n    isCustomSVG: true,\r\n    size: 60,\r\n    inner: '<use xlink:href=\"#pswp__icn-arrow\"/>',\r\n    outlineID: 'pswp__icn-arrow'\r\n  },\r\n  onClick: 'next',\r\n  onInit: (el, pswp) => {\r\n    initArrowButton(el, pswp, true);\r\n  }\r\n};\r\n","/** @type {import('./ui-element.js').UIElementData} UIElementData */\r\nconst closeButton = {\r\n  name: 'close',\r\n  title: 'Close',\r\n  order: 20,\r\n  isButton: true,\r\n  html: {\r\n    isCustomSVG: true,\r\n    inner: '<path d=\"M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z\" id=\"pswp__icn-close\"/>',\r\n    outlineID: 'pswp__icn-close'\r\n  },\r\n  onClick: 'close'\r\n};\r\n\r\nexport default closeButton;\r\n","/** @type {import('./ui-element.js').UIElementData} UIElementData */\r\nconst zoomButton = {\r\n  name: 'zoom',\r\n  title: 'Zoom',\r\n  order: 10,\r\n  isButton: true,\r\n  html: {\r\n    isCustomSVG: true,\r\n    // eslint-disable-next-line max-len\r\n    inner: '<path d=\"M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z\" id=\"pswp__icn-zoom\"/>'\r\n          + '<path fill=\"currentColor\" class=\"pswp__zoom-icn-bar-h\" d=\"M11 16v-2h6v2z\"/>'\r\n          + '<path fill=\"currentColor\" class=\"pswp__zoom-icn-bar-v\" d=\"M13 12h2v6h-2z\"/>',\r\n    outlineID: 'pswp__icn-zoom'\r\n  },\r\n  onClick: 'toggleZoom'\r\n};\r\n\r\nexport default zoomButton;\r\n","/** @type {import('./ui-element.js').UIElementData} UIElementData */\r\nexport const loadingIndicator = {\r\n  name: 'preloader',\r\n  appendTo: 'bar',\r\n  order: 7,\r\n  html: {\r\n    isCustomSVG: true,\r\n    // eslint-disable-next-line max-len\r\n    inner: '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z\" id=\"pswp__icn-loading\"/>',\r\n    outlineID: 'pswp__icn-loading'\r\n  },\r\n  onInit: (indicatorElement, pswp) => {\r\n    /** @type {boolean | undefined} */\r\n    let isVisible;\r\n    /** @type {NodeJS.Timeout | null} */\r\n    let delayTimeout = null;\r\n\r\n    /**\r\n     * @param {string} className\r\n     * @param {boolean} add\r\n     */\r\n    const toggleIndicatorClass = (className, add) => {\r\n      indicatorElement.classList.toggle('pswp__preloader--' + className, add);\r\n    };\r\n\r\n    /**\r\n     * @param {boolean} visible\r\n     */\r\n    const setIndicatorVisibility = (visible) => {\r\n      if (isVisible !== visible) {\r\n        isVisible = visible;\r\n        toggleIndicatorClass('active', visible);\r\n      }\r\n    };\r\n\r\n    const updatePreloaderVisibility = () => {\r\n      if (!pswp.currSlide?.content.isLoading()) {\r\n        setIndicatorVisibility(false);\r\n        if (delayTimeout) {\r\n          clearTimeout(delayTimeout);\r\n          delayTimeout = null;\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (!delayTimeout) {\r\n        // display loading indicator with delay\r\n        delayTimeout = setTimeout(() => {\r\n          setIndicatorVisibility(Boolean(pswp.currSlide?.content.isLoading()));\r\n          delayTimeout = null;\r\n        }, pswp.options.preloaderDelay);\r\n      }\r\n    };\r\n\r\n    pswp.on('change', updatePreloaderVisibility);\r\n\r\n    pswp.on('loadComplete', (e) => {\r\n      if (pswp.currSlide === e.slide) {\r\n        updatePreloaderVisibility();\r\n      }\r\n    });\r\n\r\n    // expose the method\r\n    if (pswp.ui) {\r\n      pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;\r\n    }\r\n  }\r\n};\r\n","/** @type {import('./ui-element.js').UIElementData} UIElementData */\r\nexport const counterIndicator = {\r\n  name: 'counter',\r\n  order: 5,\r\n  onInit: (counterElement, pswp) => {\r\n    pswp.on('change', () => {\r\n      counterElement.innerText = (pswp.currIndex + 1)\r\n                                  + pswp.options.indexIndicatorSep\r\n                                  + pswp.getNumItems();\r\n    });\r\n  }\r\n};\r\n","import UIElement from './ui-element.js';\r\nimport { arrowPrev, arrowNext } from './button-arrow.js';\r\nimport closeButton from './button-close.js';\r\nimport zoomButton from './button-zoom.js';\r\nimport { loadingIndicator } from './loading-indicator.js';\r\nimport { counterIndicator } from './counter-indicator.js';\r\n\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('./ui-element.js').UIElementData} UIElementData */\r\n\r\n/**\r\n * Set special class on element when image is zoomed.\r\n *\r\n * By default, it is used to adjust\r\n * zoom icon and zoom cursor via CSS.\r\n *\r\n * @param {HTMLElement} el\r\n * @param {boolean} isZoomedIn\r\n */\r\nfunction setZoomedIn(el, isZoomedIn) {\r\n  el.classList.toggle('pswp--zoomed-in', isZoomedIn);\r\n}\r\n\r\nclass UI {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    this.isRegistered = false;\r\n    /** @type {UIElementData[]} */\r\n    this.uiElementsData = [];\r\n    /** @type {(UIElement | UIElementData)[]} */\r\n    this.items = [];\r\n    /** @type {() => void} */\r\n    this.updatePreloaderVisibility = () => {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {number | undefined}\r\n     */\r\n    this._lastUpdatedZoomLevel = undefined;\r\n  }\r\n\r\n  init() {\r\n    const { pswp } = this;\r\n    this.isRegistered = false;\r\n    this.uiElementsData = [\r\n      closeButton,\r\n      arrowPrev,\r\n      arrowNext,\r\n      zoomButton,\r\n      loadingIndicator,\r\n      counterIndicator\r\n    ];\r\n\r\n    pswp.dispatch('uiRegister');\r\n\r\n    // sort by order\r\n    this.uiElementsData.sort((a, b) => {\r\n      // default order is 0\r\n      return (a.order || 0) - (b.order || 0);\r\n    });\r\n\r\n    this.items = [];\r\n\r\n    this.isRegistered = true;\r\n    this.uiElementsData.forEach((uiElementData) => {\r\n      this.registerElement(uiElementData);\r\n    });\r\n\r\n    pswp.on('change', () => {\r\n      pswp.element?.classList.toggle('pswp--one-slide', pswp.getNumItems() === 1);\r\n    });\r\n\r\n    pswp.on('zoomPanUpdate', () => this._onZoomPanUpdate());\r\n  }\r\n\r\n  /**\r\n   * @param {UIElementData} elementData\r\n   */\r\n  registerElement(elementData) {\r\n    if (this.isRegistered) {\r\n      this.items.push(\r\n        new UIElement(this.pswp, elementData)\r\n      );\r\n    } else {\r\n      this.uiElementsData.push(elementData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fired each time zoom or pan position is changed.\r\n   * Update classes that control visibility of zoom button and cursor icon.\r\n   *\r\n   * @private\r\n   */\r\n  _onZoomPanUpdate() {\r\n    const { template, currSlide, options } = this.pswp;\r\n\r\n    if (this.pswp.opener.isClosing || !template || !currSlide) {\r\n      return;\r\n    }\r\n\r\n    let { currZoomLevel } = currSlide;\r\n\r\n    // if not open yet - check against initial zoom level\r\n    if (!this.pswp.opener.isOpen) {\r\n      currZoomLevel = currSlide.zoomLevels.initial;\r\n    }\r\n\r\n    if (currZoomLevel === this._lastUpdatedZoomLevel) {\r\n      return;\r\n    }\r\n    this._lastUpdatedZoomLevel = currZoomLevel;\r\n\r\n    const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary;\r\n\r\n    // Initial and secondary zoom levels are almost equal\r\n    if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {\r\n      // disable zoom\r\n      setZoomedIn(template, false);\r\n      template.classList.remove('pswp--zoom-allowed');\r\n      return;\r\n    }\r\n\r\n    template.classList.add('pswp--zoom-allowed');\r\n\r\n    const potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial\r\n      ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;\r\n\r\n    setZoomedIn(template, potentialZoomLevel <= currZoomLevel);\r\n\r\n    if (options.imageClickAction === 'zoom'\r\n        || options.imageClickAction === 'zoom-or-close') {\r\n      template.classList.add('pswp--click-to-zoom');\r\n    }\r\n  }\r\n}\r\n\r\nexport default UI;\r\n","/** @typedef {import('./slide.js').SlideData} SlideData */\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n\r\n/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @returns Bounds\r\n */\r\nfunction getBoundsByElement(el) {\r\n  const thumbAreaRect = el.getBoundingClientRect();\r\n  return {\r\n    x: thumbAreaRect.left,\r\n    y: thumbAreaRect.top,\r\n    w: thumbAreaRect.width\r\n  };\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @param {number} imageWidth\r\n * @param {number} imageHeight\r\n * @returns Bounds\r\n */\r\nfunction getCroppedBoundsByElement(el, imageWidth, imageHeight) {\r\n  const thumbAreaRect = el.getBoundingClientRect();\r\n\r\n  // fill image into the area\r\n  // (do they same as object-fit:cover does to retrieve coordinates)\r\n  const hRatio = thumbAreaRect.width / imageWidth;\r\n  const vRatio = thumbAreaRect.height / imageHeight;\r\n  const fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;\r\n\r\n  const offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;\r\n  const offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;\r\n\r\n  /**\r\n   * Coordinates of the image,\r\n   * as if it was not cropped,\r\n   * height is calculated automatically\r\n   *\r\n   * @type {Bounds}\r\n   */\r\n  const bounds = {\r\n    x: thumbAreaRect.left + offsetX,\r\n    y: thumbAreaRect.top + offsetY,\r\n    w: imageWidth * fillZoomLevel\r\n  };\r\n\r\n  // Coordinates of inner crop area\r\n  // relative to the image\r\n  bounds.innerRect = {\r\n    w: thumbAreaRect.width,\r\n    h: thumbAreaRect.height,\r\n    x: offsetX,\r\n    y: offsetY\r\n  };\r\n\r\n  return bounds;\r\n}\r\n\r\n/**\r\n * Get dimensions of thumbnail image\r\n * (click on which opens photoswipe or closes photoswipe to)\r\n *\r\n * @param {number} index\r\n * @param {SlideData} itemData\r\n * @param {PhotoSwipe} instance PhotoSwipe instance\r\n * @returns {Bounds | undefined}\r\n */\r\nexport function getThumbBounds(index, itemData, instance) {\r\n  // legacy event, before filters were introduced\r\n  const event = instance.dispatch('thumbBounds', {\r\n    index,\r\n    itemData,\r\n    instance\r\n  });\r\n  // @ts-expect-error\r\n  if (event.thumbBounds) {\r\n    // @ts-expect-error\r\n    return event.thumbBounds;\r\n  }\r\n\r\n  const { element } = itemData;\r\n  /** @type {Bounds | undefined} */\r\n  let thumbBounds;\r\n  /** @type {HTMLElement | null | undefined} */\r\n  let thumbnail;\r\n\r\n  if (element && instance.options.thumbSelector !== false) {\r\n    const thumbSelector = instance.options.thumbSelector || 'img';\r\n    thumbnail = element.matches(thumbSelector)\r\n      ? element : /** @type {HTMLElement | null} */ (element.querySelector(thumbSelector));\r\n  }\r\n\r\n  thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);\r\n\r\n  if (thumbnail) {\r\n    if (!itemData.thumbCropped) {\r\n      thumbBounds = getBoundsByElement(thumbnail);\r\n    } else {\r\n      thumbBounds = getCroppedBoundsByElement(\r\n        thumbnail,\r\n        itemData.width || itemData.w || 0,\r\n        itemData.height || itemData.h || 0\r\n      );\r\n    }\r\n  }\r\n\r\n  return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);\r\n}\r\n","/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../photoswipe.js').DataSource} DataSource */\r\n/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */\r\n/** @typedef {import('../slide/content.js').default} ContentDefault */\r\n/** @typedef {import('../slide/slide.js').default} Slide */\r\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\r\n/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */\r\n/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */\r\n\r\n/**\r\n * Allow adding an arbitrary props to the Content\r\n * https://photoswipe.com/custom-content/#using-webp-image-format\r\n * @typedef {ContentDefault & Record<string, any>} Content\r\n */\r\n/** @typedef {{ x?: number; y?: number }} Point */\r\n\r\n/**\r\n * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/\r\n *\r\n *\r\n * https://photoswipe.com/adding-ui-elements/\r\n *\r\n * @prop {undefined} uiRegister\r\n * @prop {{ data: UIElementData }} uiElementCreate\r\n *\r\n *\r\n * https://photoswipe.com/events/#initialization-events\r\n *\r\n * @prop {undefined} beforeOpen\r\n * @prop {undefined} firstUpdate\r\n * @prop {undefined} initialLayout\r\n * @prop {undefined} change\r\n * @prop {undefined} afterInit\r\n * @prop {undefined} bindEvents\r\n *\r\n *\r\n * https://photoswipe.com/events/#opening-or-closing-transition-events\r\n *\r\n * @prop {undefined} openingAnimationStart\r\n * @prop {undefined} openingAnimationEnd\r\n * @prop {undefined} closingAnimationStart\r\n * @prop {undefined} closingAnimationEnd\r\n *\r\n *\r\n * https://photoswipe.com/events/#closing-events\r\n *\r\n * @prop {undefined} close\r\n * @prop {undefined} destroy\r\n *\r\n *\r\n * https://photoswipe.com/events/#pointer-and-gesture-events\r\n *\r\n * @prop {{ originalEvent: PointerEvent }} pointerDown\r\n * @prop {{ originalEvent: PointerEvent }} pointerMove\r\n * @prop {{ originalEvent: PointerEvent }} pointerUp\r\n * @prop {{ bgOpacity: number }} pinchClose can be default prevented\r\n * @prop {{ panY: number }} verticalDrag can be default prevented\r\n *\r\n *\r\n * https://photoswipe.com/events/#slide-content-events\r\n *\r\n * @prop {{ content: Content }} contentInit\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented\r\n * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete\r\n * @prop {{ content: Content; slide: Slide }} loadError\r\n * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented\r\n * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange\r\n * @prop {{ content: Content }} contentLazyLoad can be default prevented\r\n * @prop {{ content: Content }} contentAppend can be default prevented\r\n * @prop {{ content: Content }} contentActivate can be default prevented\r\n * @prop {{ content: Content }} contentDeactivate can be default prevented\r\n * @prop {{ content: Content }} contentRemove can be default prevented\r\n * @prop {{ content: Content }} contentDestroy can be default prevented\r\n *\r\n *\r\n * undocumented\r\n *\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented\r\n *\r\n * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented\r\n * @prop {{ x: number; dragging: boolean }} moveMainScroll\r\n * @prop {{ slide: Slide }} firstZoomPan\r\n * @prop {{ slide: Slide | undefined, data: SlideData, index: number }} gettingData\r\n * @prop {undefined} beforeResize\r\n * @prop {undefined} resize\r\n * @prop {undefined} viewportSize\r\n * @prop {undefined} updateScrollOffset\r\n * @prop {{ slide: Slide }} slideInit\r\n * @prop {{ slide: Slide }} afterSetContent\r\n * @prop {{ slide: Slide }} slideLoad\r\n * @prop {{ slide: Slide }} appendHeavy can be default prevented\r\n * @prop {{ slide: Slide }} appendHeavyContent\r\n * @prop {{ slide: Slide }} slideActivate\r\n * @prop {{ slide: Slide }} slideDeactivate\r\n * @prop {{ slide: Slide }} slideDestroy\r\n * @prop {{ destZoomLevel: number, centerPoint: Point | undefined, transitionDuration: number | false | undefined }} beforeZoomTo\r\n * @prop {{ slide: Slide }} zoomPanUpdate\r\n * @prop {{ slide: Slide }} initialZoomPan\r\n * @prop {{ slide: Slide }} calcSlideSize\r\n * @prop {undefined} resolutionChanged\r\n * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented\r\n * @prop {{ content: Content }} contentAppendImage can be default prevented\r\n * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented\r\n * @prop {undefined} lazyLoad\r\n * @prop {{ slide: Slide }} calcBounds\r\n * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate\r\n *\r\n *\r\n * legacy\r\n *\r\n * @prop {undefined} init\r\n * @prop {undefined} initialZoomIn\r\n * @prop {undefined} initialZoomOut\r\n * @prop {undefined} initialZoomInEnd\r\n * @prop {undefined} initialZoomOutEnd\r\n * @prop {{ dataSource: DataSource | undefined, numItems: number }} numItems\r\n * @prop {{ itemData: SlideData; index: number }} itemData\r\n * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds\r\n */\r\n\r\n/**\r\n * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/\r\n *\r\n * @prop {(numItems: number, dataSource: DataSource | undefined) => number} numItems\r\n * Modify the total amount of slides. Example on Data sources page.\r\n * https://photoswipe.com/filters/#numitems\r\n *\r\n * @prop {(itemData: SlideData, index: number) => SlideData} itemData\r\n * Modify slide item data. Example on Data sources page.\r\n * https://photoswipe.com/filters/#itemdata\r\n *\r\n * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData\r\n * Modify item data when it's parsed from DOM element. Example on Data sources page.\r\n * https://photoswipe.com/filters/#domitemdata\r\n *\r\n * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex\r\n * Modify clicked gallery item index.\r\n * https://photoswipe.com/filters/#clickedindex\r\n *\r\n * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc\r\n * Modify placeholder image source.\r\n * https://photoswipe.com/filters/#placeholdersrc\r\n *\r\n * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading\r\n * Modify if the content is currently loading.\r\n * https://photoswipe.com/filters/#iscontentloading\r\n *\r\n * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable\r\n * Modify if the content can be zoomed.\r\n * https://photoswipe.com/filters/#iscontentzoomable\r\n *\r\n * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder\r\n * Modify if the placeholder should be used for the content.\r\n * https://photoswipe.com/filters/#usecontentplaceholder\r\n *\r\n * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder\r\n * Modify if the placeholder should be kept after the content is loaded.\r\n * https://photoswipe.com/filters/#iskeepingplaceholder\r\n *\r\n *\r\n * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement\r\n * Modify an element when the content has error state (for example, if image cannot be loaded).\r\n * https://photoswipe.com/filters/#contenterrorelement\r\n *\r\n * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement\r\n * Modify a UI element that's being created.\r\n * https://photoswipe.com/filters/#uielement\r\n *\r\n * @prop {(thumbnail: HTMLElement | null | undefined, itemData: SlideData, index: number) => HTMLElement} thumbEl\r\n * Modify the thumbnail element from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbel\r\n *\r\n * @prop {(thumbBounds: Bounds | undefined, itemData: SlideData, index: number) => Bounds} thumbBounds\r\n * Modify the thumbnail bounds from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbbounds\r\n *\r\n * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth\r\n *\r\n * @prop {(preventPointerEvent: boolean, event: PointerEvent, pointerType: string) => boolean} preventPointerEvent\r\n *\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeFiltersMap} T\r\n * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {(event: AugmentedEvent<T>) => void} EventCallback\r\n */\r\n\r\n/**\r\n * Base PhotoSwipe event object\r\n *\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n */\r\nclass PhotoSwipeEvent {\r\n  /**\r\n   * @param {T} type\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   */\r\n  constructor(type, details) {\r\n    this.type = type;\r\n    this.defaultPrevented = false;\r\n    if (details) {\r\n      Object.assign(this, details);\r\n    }\r\n  }\r\n\r\n  preventDefault() {\r\n    this.defaultPrevented = true;\r\n  }\r\n}\r\n\r\n/**\r\n * PhotoSwipe base class that can listen and dispatch for events.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js\r\n */\r\nclass Eventable {\r\n  constructor() {\r\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}\r\n     */\r\n    this._listeners = {};\r\n\r\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}\r\n     */\r\n    this._filters = {};\r\n\r\n    /** @type {PhotoSwipe | undefined} */\r\n    this.pswp = undefined;\r\n\r\n    /** @type {PhotoSwipeOptions | undefined} */\r\n    this.options = undefined;\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   * @param {number} priority\r\n   */\r\n  addFilter(name, fn, priority = 100) {\r\n    if (!this._filters[name]) {\r\n      this._filters[name] = [];\r\n    }\r\n\r\n    this._filters[name]?.push({ fn, priority });\r\n    this._filters[name]?.sort((f1, f2) => f1.priority - f2.priority);\r\n\r\n    this.pswp?.addFilter(name, fn, priority);\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   */\r\n  removeFilter(name, fn) {\r\n    if (this._filters[name]) {\r\n      // @ts-expect-error\r\n      this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));\r\n    }\r\n\r\n    if (this.pswp) {\r\n      this.pswp.removeFilter(name, fn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args\r\n   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}\r\n   */\r\n  applyFilters(name, ...args) {\r\n    this._filters[name]?.forEach((filter) => {\r\n      // @ts-expect-error\r\n      args[0] = filter.fn.apply(this, args);\r\n    });\r\n    return args[0];\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\r\n  on(name, fn) {\r\n    if (!this._listeners[name]) {\r\n      this._listeners[name] = [];\r\n    }\r\n    this._listeners[name]?.push(fn);\r\n\r\n    // When binding events to lightbox,\r\n    // also bind events to PhotoSwipe Core,\r\n    // if it's open.\r\n    this.pswp?.on(name, fn);\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\r\n  off(name, fn) {\r\n    if (this._listeners[name]) {\r\n      // @ts-expect-error\r\n      this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));\r\n    }\r\n\r\n    this.pswp?.off(name, fn);\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   * @returns {AugmentedEvent<T>}\r\n   */\r\n  dispatch(name, details) {\r\n    if (this.pswp) {\r\n      return this.pswp.dispatch(name, details);\r\n    }\r\n\r\n    const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent(name, details));\r\n\r\n    this._listeners[name]?.forEach((listener) => {\r\n      listener.call(this, event);\r\n    });\r\n\r\n    return event;\r\n  }\r\n}\r\n\r\nexport default Eventable;\r\n","import { createElement, setWidthHeight, toTransformString } from '../util/util.js';\r\n\r\nclass Placeholder {\r\n  /**\r\n   * @param {string | false} imageSrc\r\n   * @param {HTMLElement} container\r\n   */\r\n  constructor(imageSrc, container) {\r\n    // Create placeholder\r\n    // (stretched thumbnail or simple div behind the main image)\r\n    /** @type {HTMLImageElement | HTMLDivElement | null} */\r\n    this.element = createElement(\r\n      'pswp__img pswp__img--placeholder',\r\n      imageSrc ? 'img' : 'div',\r\n      container\r\n    );\r\n\r\n    if (imageSrc) {\r\n      const imgEl = /** @type {HTMLImageElement} */ (this.element);\r\n      imgEl.decoding = 'async';\r\n      imgEl.alt = '';\r\n      imgEl.src = imageSrc;\r\n      imgEl.setAttribute('role', 'presentation');\r\n    }\r\n\r\n    this.element.setAttribute('aria-hidden', 'true');\r\n  }\r\n\r\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\r\n  setDisplayedSize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.element.tagName === 'IMG') {\r\n      // Use transform scale() to modify img placeholder size\r\n      // (instead of changing width/height directly).\r\n      // This helps with performance, specifically in iOS15 Safari.\r\n      setWidthHeight(this.element, 250, 'auto');\r\n      this.element.style.transformOrigin = '0 0';\r\n      this.element.style.transform = toTransformString(0, 0, width / 250);\r\n    } else {\r\n      setWidthHeight(this.element, width, height);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    if (this.element?.parentNode) {\r\n      this.element.remove();\r\n    }\r\n    this.element = null;\r\n  }\r\n}\r\n\r\nexport default Placeholder;\r\n","import { createElement, isSafari, LOAD_STATE, setWidthHeight } from '../util/util.js';\r\nimport Placeholder from './placeholder.js';\r\n\r\n/** @typedef {import('./slide.js').default} Slide */\r\n/** @typedef {import('./slide.js').SlideData} SlideData */\r\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\r\n/** @typedef {import('../util/util.js').LoadState} LoadState */\r\n\r\nclass Content {\r\n  /**\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n   * @param {number} index\r\n   */\r\n  constructor(itemData, instance, index) {\r\n    this.instance = instance;\r\n    this.data = itemData;\r\n    this.index = index;\r\n\r\n    /** @type {HTMLImageElement | HTMLDivElement | undefined} */\r\n    this.element = undefined;\r\n    /** @type {Placeholder | undefined} */\r\n    this.placeholder = undefined;\r\n    /** @type {Slide | undefined} */\r\n    this.slide = undefined;\r\n\r\n    this.displayedImageWidth = 0;\r\n    this.displayedImageHeight = 0;\r\n\r\n    this.width = Number(this.data.w) || Number(this.data.width) || 0;\r\n    this.height = Number(this.data.h) || Number(this.data.height) || 0;\r\n\r\n    this.isAttached = false;\r\n    this.hasSlide = false;\r\n    this.isDecoding = false;\r\n    /** @type {LoadState} */\r\n    this.state = LOAD_STATE.IDLE;\r\n\r\n    if (this.data.type) {\r\n      this.type = this.data.type;\r\n    } else if (this.data.src) {\r\n      this.type = 'image';\r\n    } else {\r\n      this.type = 'html';\r\n    }\r\n\r\n    this.instance.dispatch('contentInit', { content: this });\r\n  }\r\n\r\n  removePlaceholder() {\r\n    if (this.placeholder && !this.keepPlaceholder()) {\r\n      // With delay, as image might be loaded, but not rendered\r\n      setTimeout(() => {\r\n        if (this.placeholder) {\r\n          this.placeholder.destroy();\r\n          this.placeholder = undefined;\r\n        }\r\n      }, 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload content\r\n   *\r\n   * @param {boolean} isLazy\r\n   * @param {boolean} [reload]\r\n   */\r\n  load(isLazy, reload) {\r\n    if (this.slide && this.usePlaceholder()) {\r\n      if (!this.placeholder) {\r\n        const placeholderSrc = this.instance.applyFilters(\r\n          'placeholderSrc',\r\n          // use  image-based placeholder only for the first slide,\r\n          // as rendering (even small stretched thumbnail) is an expensive operation\r\n          (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,\r\n          this\r\n        );\r\n        this.placeholder = new Placeholder(\r\n          placeholderSrc,\r\n          this.slide.container\r\n        );\r\n      } else {\r\n        const placeholderEl = this.placeholder.element;\r\n        // Add placeholder to DOM if it was already created\r\n        if (placeholderEl && !placeholderEl.parentElement) {\r\n          this.slide.container.prepend(placeholderEl);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.element && !reload) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.isImageContent()) {\r\n      this.element = createElement('pswp__img', 'img');\r\n      // Start loading only after width is defined, as sizes might depend on it.\r\n      // Due to Safari feature, we must define sizes before srcset.\r\n      if (this.displayedImageWidth) {\r\n        this.loadImage(isLazy);\r\n      }\r\n    } else {\r\n      this.element = createElement('pswp__content', 'div');\r\n      this.element.innerHTML = this.data.html || '';\r\n    }\r\n\r\n    if (reload && this.slide) {\r\n      this.slide.updateContentSize(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload image\r\n   *\r\n   * @param {boolean} isLazy\r\n   */\r\n  loadImage(isLazy) {\r\n    if (!this.isImageContent()\r\n      || !this.element\r\n      || this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const imageElement = /** @type HTMLImageElement */ (this.element);\r\n\r\n    this.updateSrcsetSizes();\r\n\r\n    if (this.data.srcset) {\r\n      imageElement.srcset = this.data.srcset;\r\n    }\r\n\r\n    imageElement.src = this.data.src ?? '';\r\n    imageElement.alt = this.data.alt ?? '';\r\n\r\n    this.state = LOAD_STATE.LOADING;\r\n\r\n    if (imageElement.complete) {\r\n      this.onLoaded();\r\n    } else {\r\n      imageElement.onload = () => {\r\n        this.onLoaded();\r\n      };\r\n\r\n      imageElement.onerror = () => {\r\n        this.onError();\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign slide to content\r\n   *\r\n   * @param {Slide} slide\r\n   */\r\n  setSlide(slide) {\r\n    this.slide = slide;\r\n    this.hasSlide = true;\r\n    this.instance = slide.pswp;\r\n\r\n    // todo: do we need to unset slide?\r\n  }\r\n\r\n  /**\r\n   * Content load success handler\r\n   */\r\n  onLoaded() {\r\n    this.state = LOAD_STATE.LOADED;\r\n\r\n    if (this.slide && this.element) {\r\n      this.instance.dispatch('loadComplete', { slide: this.slide, content: this });\r\n\r\n      // if content is reloaded\r\n      if (this.slide.isActive\r\n          && this.slide.heavyAppended\r\n          && !this.element.parentNode) {\r\n        this.append();\r\n        this.slide.updateContentSize(true);\r\n      }\r\n\r\n      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {\r\n        this.removePlaceholder();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Content load error handler\r\n   */\r\n  onError() {\r\n    this.state = LOAD_STATE.ERROR;\r\n\r\n    if (this.slide) {\r\n      this.displayError();\r\n      this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });\r\n      this.instance.dispatch('loadError', { slide: this.slide, content: this });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {Boolean} If the content is currently loading\r\n   */\r\n  isLoading() {\r\n    return this.instance.applyFilters(\r\n      'isContentLoading',\r\n      this.state === LOAD_STATE.LOADING,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @returns {Boolean} If the content is in error state\r\n   */\r\n  isError() {\r\n    return this.state === LOAD_STATE.ERROR;\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If the content is image\r\n   */\r\n  isImageContent() {\r\n    return this.type === 'image';\r\n  }\r\n\r\n  /**\r\n   * Update content size\r\n   *\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   */\r\n  setDisplayedSize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.placeholder) {\r\n      this.placeholder.setDisplayedSize(width, height);\r\n    }\r\n\r\n    if (this.instance.dispatch(\r\n      'contentResize',\r\n      { content: this, width, height }).defaultPrevented\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    setWidthHeight(this.element, width, height);\r\n\r\n    if (this.isImageContent() && !this.isError()) {\r\n      const isInitialSizeUpdate = (!this.displayedImageWidth && width);\r\n\r\n      this.displayedImageWidth = width;\r\n      this.displayedImageHeight = height;\r\n\r\n      if (isInitialSizeUpdate) {\r\n        this.loadImage(false);\r\n      } else {\r\n        this.updateSrcsetSizes();\r\n      }\r\n\r\n      if (this.slide) {\r\n        this.instance.dispatch(\r\n          'imageSizeChange',\r\n          { slide: this.slide, width, height, content: this }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If the content can be zoomed\r\n   */\r\n  isZoomable() {\r\n    return this.instance.applyFilters(\r\n      'isContentZoomable',\r\n      this.isImageContent() && (this.state !== LOAD_STATE.ERROR),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update image srcset sizes attribute based on width and height\r\n   */\r\n  updateSrcsetSizes() {\r\n    // Handle srcset sizes attribute.\r\n    //\r\n    // Never lower quality, if it was increased previously.\r\n    // Chrome does this automatically, Firefox and Safari do not,\r\n    // so we store largest used size in dataset.\r\n    if (!this.isImageContent() || !this.element || !this.data.srcset) {\r\n      return;\r\n    }\r\n\r\n    const image = /** @type HTMLImageElement */ (this.element);\r\n    const sizesWidth = this.instance.applyFilters(\r\n      'srcsetSizesWidth',\r\n      this.displayedImageWidth,\r\n      this\r\n    );\r\n\r\n    if (\r\n      !image.dataset.largestUsedSize\r\n      || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)\r\n    ) {\r\n      image.sizes = sizesWidth + 'px';\r\n      image.dataset.largestUsedSize = String(sizesWidth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If content should use a placeholder (from msrc by default)\r\n   */\r\n  usePlaceholder() {\r\n    return this.instance.applyFilters(\r\n      'useContentPlaceholder',\r\n      this.isImageContent(),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Preload content with lazy-loading param\r\n   */\r\n  lazyLoad() {\r\n    if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.load(true);\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If placeholder should be kept after content is loaded\r\n   */\r\n  keepPlaceholder() {\r\n    return this.instance.applyFilters(\r\n      'isKeepingPlaceholder',\r\n      this.isLoading(),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy the content\r\n   */\r\n  destroy() {\r\n    this.hasSlide = false;\r\n    this.slide = undefined;\r\n\r\n    if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.remove();\r\n\r\n    if (this.placeholder) {\r\n      this.placeholder.destroy();\r\n      this.placeholder = undefined;\r\n    }\r\n\r\n    if (this.isImageContent() && this.element) {\r\n      this.element.onload = null;\r\n      this.element.onerror = null;\r\n      this.element = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Display error message\r\n   */\r\n  displayError() {\r\n    if (this.slide) {\r\n      let errorMsgEl = createElement('pswp__error-msg', 'div');\r\n      errorMsgEl.innerText = this.instance.options?.errorMsg ?? '';\r\n      errorMsgEl = /** @type {HTMLDivElement} */ (this.instance.applyFilters(\r\n        'contentErrorElement',\r\n        errorMsgEl,\r\n        this\r\n      ));\r\n      this.element = createElement('pswp__content pswp__error-msg-container', 'div');\r\n      this.element.appendChild(errorMsgEl);\r\n      this.slide.container.innerText = '';\r\n      this.slide.container.appendChild(this.element);\r\n      this.slide.updateContentSize(true);\r\n      this.removePlaceholder();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the content\r\n   */\r\n  append() {\r\n    if (this.isAttached || !this.element) {\r\n      return;\r\n    }\r\n\r\n    this.isAttached = true;\r\n\r\n    if (this.state === LOAD_STATE.ERROR) {\r\n      this.displayError();\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const supportsDecode = ('decode' in this.element);\r\n\r\n    if (this.isImageContent()) {\r\n      // Use decode() on nearby slides\r\n      //\r\n      // Nearby slide images are in DOM and not hidden via display:none.\r\n      // However, they are placed offscreen (to the left and right side).\r\n      //\r\n      // Some browsers do not composite the image until it's actually visible,\r\n      // using decode() helps.\r\n      //\r\n      // You might ask \"why dont you just decode() and then append all images\",\r\n      // that's because I want to show image before it's fully loaded,\r\n      // as browser can render parts of image while it is loading.\r\n      // We do not do this in Safari due to partial loading bug.\r\n      if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {\r\n        this.isDecoding = true;\r\n        // purposefully using finally instead of then,\r\n        // as if srcset sizes changes dynamically - it may cause decode error\r\n        /** @type {HTMLImageElement} */\r\n        (this.element).decode().catch(() => {}).finally(() => {\r\n          this.isDecoding = false;\r\n          this.appendImage();\r\n        });\r\n      } else {\r\n        this.appendImage();\r\n      }\r\n    } else if (this.slide && !this.element.parentNode) {\r\n      this.slide.container.appendChild(this.element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate the slide,\r\n   * active slide is generally the current one,\r\n   * meaning the user can see it.\r\n   */\r\n  activate() {\r\n    if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented\r\n      || !this.slide) {\r\n      return;\r\n    }\r\n\r\n    if (this.isImageContent() && this.isDecoding && !isSafari()) {\r\n      // add image to slide when it becomes active,\r\n      // even if it's not finished decoding\r\n      this.appendImage();\r\n    } else if (this.isError()) {\r\n      this.load(false, true); // try to reload\r\n    }\r\n\r\n    if (this.slide.holderElement) {\r\n      this.slide.holderElement.setAttribute('aria-hidden', 'false');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deactivate the content\r\n   */\r\n  deactivate() {\r\n    this.instance.dispatch('contentDeactivate', { content: this });\r\n    if (this.slide && this.slide.holderElement) {\r\n      this.slide.holderElement.setAttribute('aria-hidden', 'true');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Remove the content from DOM\r\n   */\r\n  remove() {\r\n    this.isAttached = false;\r\n\r\n    if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.element && this.element.parentNode) {\r\n      this.element.remove();\r\n    }\r\n\r\n    if (this.placeholder && this.placeholder.element) {\r\n      this.placeholder.element.remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the image content to slide container\r\n   */\r\n  appendImage() {\r\n    if (!this.isAttached) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    // ensure that element exists and is not already appended\r\n    if (this.slide && this.element && !this.element.parentNode) {\r\n      this.slide.container.appendChild(this.element);\r\n    }\r\n\r\n    if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {\r\n      this.removePlaceholder();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Content;\r\n","import { getViewportSize, getPanAreaSize } from '../util/viewport-size.js';\r\nimport ZoomLevel from './zoom-level.js';\r\n\r\n/** @typedef {import('./content.js').default} Content */\r\n/** @typedef {import('./slide.js').default} Slide */\r\n/** @typedef {import('./slide.js').SlideData} SlideData */\r\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n\r\nconst MIN_SLIDES_TO_CACHE = 5;\r\n\r\n/**\r\n * Lazy-load an image\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n * @param {number} index\r\n * @returns {Content} Image that is being decoded or false.\r\n */\r\nexport function lazyLoadData(itemData, instance, index) {\r\n  const content = instance.createContentFromData(itemData, index);\r\n  /** @type {ZoomLevel | undefined} */\r\n  let zoomLevel;\r\n\r\n  const { options } = instance;\r\n\r\n  // We need to know dimensions of the image to preload it,\r\n  // as it might use srcset, and we need to define sizes\r\n  if (options) {\r\n    zoomLevel = new ZoomLevel(options, itemData, -1);\r\n\r\n    let viewportSize;\r\n    if (instance.pswp) {\r\n      viewportSize = instance.pswp.viewportSize;\r\n    } else {\r\n      viewportSize = getViewportSize(options, instance);\r\n    }\r\n\r\n    const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);\r\n    zoomLevel.update(content.width, content.height, panAreaSize);\r\n  }\r\n\r\n  content.lazyLoad();\r\n\r\n  if (zoomLevel) {\r\n    content.setDisplayedSize(\r\n      Math.ceil(content.width * zoomLevel.initial),\r\n      Math.ceil(content.height * zoomLevel.initial)\r\n    );\r\n  }\r\n\r\n  return content;\r\n}\r\n\r\n\r\n/**\r\n * Lazy-loads specific slide.\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * By default, it loads image based on viewport size and initial zoom level.\r\n *\r\n * @param {number} index Slide index\r\n * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox eventable instance\r\n * @returns {Content | undefined}\r\n */\r\nexport function lazyLoadSlide(index, instance) {\r\n  const itemData = instance.getItemData(index);\r\n\r\n  if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {\r\n    return;\r\n  }\r\n\r\n  return lazyLoadData(itemData, instance, index);\r\n}\r\n\r\nclass ContentLoader {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    // Total amount of cached images\r\n    this.limit = Math.max(\r\n      pswp.options.preload[0] + pswp.options.preload[1] + 1,\r\n      MIN_SLIDES_TO_CACHE\r\n    );\r\n    /** @type {Content[]} */\r\n    this._cachedItems = [];\r\n  }\r\n\r\n  /**\r\n   * Lazy load nearby slides based on `preload` option.\r\n   *\r\n   * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.\r\n   */\r\n  updateLazy(diff) {\r\n    const { pswp } = this;\r\n\r\n    if (pswp.dispatch('lazyLoad').defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const { preload } = pswp.options;\r\n    const isForward = diff === undefined ? true : (diff >= 0);\r\n    let i;\r\n\r\n    // preload[1] - num items to preload in forward direction\r\n    for (i = 0; i <= preload[1]; i++) {\r\n      this.loadSlideByIndex(pswp.currIndex + (isForward ? i : (-i)));\r\n    }\r\n\r\n    // preload[0] - num items to preload in backward direction\r\n    for (i = 1; i <= preload[0]; i++) {\r\n      this.loadSlideByIndex(pswp.currIndex + (isForward ? (-i) : i));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} initialIndex\r\n   */\r\n  loadSlideByIndex(initialIndex) {\r\n    const index = this.pswp.getLoopedIndex(initialIndex);\r\n    // try to get cached content\r\n    let content = this.getContentByIndex(index);\r\n    if (!content) {\r\n      // no cached content, so try to load from scratch:\r\n      content = lazyLoadSlide(index, this.pswp);\r\n      // if content can be loaded, add it to cache:\r\n      if (content) {\r\n        this.addToCache(content);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Slide} slide\r\n   * @returns {Content}\r\n   */\r\n  getContentBySlide(slide) {\r\n    let content = this.getContentByIndex(slide.index);\r\n    if (!content) {\r\n      // create content if not found in cache\r\n      content = this.pswp.createContentFromData(slide.data, slide.index);\r\n      this.addToCache(content);\r\n    }\r\n\r\n    // assign slide to content\r\n    content.setSlide(slide);\r\n\r\n    return content;\r\n  }\r\n\r\n  /**\r\n   * @param {Content} content\r\n   */\r\n  addToCache(content) {\r\n    // move to the end of array\r\n    this.removeByIndex(content.index);\r\n    this._cachedItems.push(content);\r\n\r\n    if (this._cachedItems.length > this.limit) {\r\n      // Destroy the first content that's not attached\r\n      const indexToRemove = this._cachedItems.findIndex((item) => {\r\n        return !item.isAttached && !item.hasSlide;\r\n      });\r\n      if (indexToRemove !== -1) {\r\n        const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];\r\n        removedItem.destroy();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an image from cache, does not destroy() it, just removes.\r\n   *\r\n   * @param {number} index\r\n   */\r\n  removeByIndex(index) {\r\n    const indexToRemove = this._cachedItems.findIndex(item => item.index === index);\r\n    if (indexToRemove !== -1) {\r\n      this._cachedItems.splice(indexToRemove, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} index\r\n   * @returns {Content | undefined}\r\n   */\r\n  getContentByIndex(index) {\r\n    return this._cachedItems.find(content => content.index === index);\r\n  }\r\n\r\n  destroy() {\r\n    this._cachedItems.forEach(content => content.destroy());\r\n    this._cachedItems = [];\r\n  }\r\n}\r\n\r\nexport default ContentLoader;\r\n","import Eventable from './eventable.js';\r\nimport { getElementsFromOption } from '../util/util.js';\r\nimport Content from '../slide/content.js';\r\nimport { lazyLoadData } from '../slide/loader.js';\r\n\r\n/** @typedef {import(\"../photoswipe.js\").default} PhotoSwipe */\r\n/** @typedef {import(\"../slide/slide.js\").SlideData} SlideData */\r\n\r\n/**\r\n * PhotoSwipe base class that can retrieve data about every slide.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox\r\n */\r\nclass PhotoSwipeBase extends Eventable {\r\n  /**\r\n   * Get total number of slides\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getNumItems() {\r\n    let numItems = 0;\r\n    const dataSource = this.options?.dataSource;\r\n\r\n    if (dataSource && 'length' in dataSource) {\r\n      // may be an array or just object with length property\r\n      numItems = dataSource.length;\r\n    } else if (dataSource && 'gallery' in dataSource) {\r\n      // query DOM elements\r\n      if (!dataSource.items) {\r\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\r\n      }\r\n\r\n      if (dataSource.items) {\r\n        numItems = dataSource.items.length;\r\n      }\r\n    }\r\n\r\n    // legacy event, before filters were introduced\r\n    const event = this.dispatch('numItems', {\r\n      dataSource,\r\n      numItems\r\n    });\r\n    return this.applyFilters('numItems', event.numItems, dataSource);\r\n  }\r\n\r\n  /**\r\n   * @param {SlideData} slideData\r\n   * @param {number} index\r\n   * @returns {Content}\r\n   */\r\n  createContentFromData(slideData, index) {\r\n    return new Content(slideData, this, index);\r\n  }\r\n\r\n  /**\r\n   * Get item data by index.\r\n   *\r\n   * \"item data\" should contain normalized information that PhotoSwipe needs to generate a slide.\r\n   * For example, it may contain properties like\r\n   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.\r\n   *\r\n   * @param {number} index\r\n   * @returns {SlideData}\r\n   */\r\n  getItemData(index) {\r\n    const dataSource = this.options?.dataSource;\r\n    /** @type {SlideData | HTMLElement} */\r\n    let dataSourceItem = {};\r\n    if (Array.isArray(dataSource)) {\r\n      // Datasource is an array of elements\r\n      dataSourceItem = dataSource[index];\r\n    } else if (dataSource && 'gallery' in dataSource) {\r\n      // dataSource has gallery property,\r\n      // thus it was created by Lightbox, based on\r\n      // gallery and children options\r\n\r\n      // query DOM elements\r\n      if (!dataSource.items) {\r\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\r\n      }\r\n\r\n      dataSourceItem = dataSource.items[index];\r\n    }\r\n\r\n    let itemData = dataSourceItem;\r\n\r\n    if (itemData instanceof Element) {\r\n      itemData = this._domElementToItemData(itemData);\r\n    }\r\n\r\n    // Dispatching the itemData event,\r\n    // it's a legacy verion before filters were introduced\r\n    const event = this.dispatch('itemData', {\r\n      itemData: itemData || {},\r\n      index\r\n    });\r\n\r\n    return this.applyFilters('itemData', event.itemData, index);\r\n  }\r\n\r\n  /**\r\n   * Get array of gallery DOM elements,\r\n   * based on childSelector and gallery element.\r\n   *\r\n   * @param {HTMLElement} galleryElement\r\n   * @returns {HTMLElement[]}\r\n   */\r\n  _getGalleryDOMElements(galleryElement) {\r\n    if (this.options?.children || this.options?.childSelector) {\r\n      return getElementsFromOption(\r\n        this.options.children,\r\n        this.options.childSelector,\r\n        galleryElement\r\n      ) || [];\r\n    }\r\n\r\n    return [galleryElement];\r\n  }\r\n\r\n  /**\r\n   * Converts DOM element to item data object.\r\n   *\r\n   * @param {HTMLElement} element DOM element\r\n   * @returns {SlideData}\r\n   */\r\n  _domElementToItemData(element) {\r\n    /** @type {SlideData} */\r\n    const itemData = {\r\n      element\r\n    };\r\n\r\n    const linkEl = /** @type {HTMLAnchorElement} */ (\r\n      element.tagName === 'A'\r\n        ? element\r\n        : element.querySelector('a')\r\n    );\r\n\r\n    if (linkEl) {\r\n      // src comes from data-pswp-src attribute,\r\n      // if it's empty link href is used\r\n      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;\r\n\r\n      if (linkEl.dataset.pswpSrcset) {\r\n        itemData.srcset = linkEl.dataset.pswpSrcset;\r\n      }\r\n\r\n      itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;\r\n      itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0;\r\n\r\n      // support legacy w & h properties\r\n      itemData.w = itemData.width;\r\n      itemData.h = itemData.height;\r\n\r\n      if (linkEl.dataset.pswpType) {\r\n        itemData.type = linkEl.dataset.pswpType;\r\n      }\r\n\r\n      const thumbnailEl = element.querySelector('img');\r\n\r\n      if (thumbnailEl) {\r\n        // msrc is URL to placeholder image that's displayed before large image is loaded\r\n        // by default it's displayed only for the first slide\r\n        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;\r\n        itemData.alt = thumbnailEl.getAttribute('alt') ?? '';\r\n      }\r\n\r\n      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {\r\n        itemData.thumbCropped = true;\r\n      }\r\n    }\r\n\r\n    return this.applyFilters('domItemData', itemData, element, linkEl);\r\n  }\r\n\r\n  /**\r\n   * Lazy-load by slide data\r\n   *\r\n   * @param {SlideData} itemData Data about the slide\r\n   * @param {number} index\r\n   * @returns {Content} Image that is being decoded or false.\r\n   */\r\n  lazyLoadData(itemData, index) {\r\n    return lazyLoadData(itemData, this, index);\r\n  }\r\n}\r\n\r\nexport default PhotoSwipeBase;\r\n","import {\r\n  setTransform,\r\n  equalizePoints,\r\n  decodeImage,\r\n  toTransformString\r\n} from './util/util.js';\r\n\r\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */\r\n/** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */\r\n\r\n// some browsers do not paint\r\n// elements which opacity is set to 0,\r\n// since we need to pre-render elements for the animation -\r\n// we set it to the minimum amount\r\nconst MIN_OPACITY = 0.003;\r\n\r\n/**\r\n * Manages opening and closing transitions of the PhotoSwipe.\r\n *\r\n * It can perform zoom, fade or no transition.\r\n */\r\nclass Opener {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    this.isClosed = true;\r\n    this.isOpen = false;\r\n    this.isClosing = false;\r\n    this.isOpening = false;\r\n    /**\r\n     * @private\r\n     * @type {number | false | undefined}\r\n     */\r\n    this._duration = undefined;\r\n    /** @private */\r\n    this._useAnimation = false;\r\n    /** @private */\r\n    this._croppedZoom = false;\r\n    /** @private */\r\n    this._animateRootOpacity = false;\r\n    /** @private */\r\n    this._animateBgOpacity = false;\r\n    /**\r\n     * @private\r\n     * @type { HTMLDivElement | HTMLImageElement | null | undefined }\r\n     */\r\n    this._placeholder = undefined;\r\n    /**\r\n     * @private\r\n     * @type { HTMLDivElement | undefined }\r\n     */\r\n    this._opacityElement = undefined;\r\n    /**\r\n     * @private\r\n     * @type { HTMLDivElement | undefined }\r\n     */\r\n    this._cropContainer1 = undefined;\r\n    /**\r\n     * @private\r\n     * @type { HTMLElement | null | undefined }\r\n     */\r\n    this._cropContainer2 = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Bounds | undefined}\r\n     */\r\n    this._thumbBounds = undefined;\r\n\r\n\r\n    this._prepareOpen = this._prepareOpen.bind(this);\r\n\r\n    // Override initial zoom and pan position\r\n    pswp.on('firstZoomPan', this._prepareOpen);\r\n  }\r\n\r\n  open() {\r\n    this._prepareOpen();\r\n    this._start();\r\n  }\r\n\r\n  close() {\r\n    if (this.isClosed || this.isClosing || this.isOpening) {\r\n      // if we close during opening animation\r\n      // for now do nothing,\r\n      // browsers aren't good at changing the direction of the CSS transition\r\n      return;\r\n    }\r\n\r\n    const slide = this.pswp.currSlide;\r\n\r\n    this.isOpen = false;\r\n    this.isOpening = false;\r\n    this.isClosing = true;\r\n    this._duration = this.pswp.options.hideAnimationDuration;\r\n\r\n    if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {\r\n      this._duration = 0;\r\n    }\r\n\r\n    this._applyStartProps();\r\n    setTimeout(() => {\r\n      this._start();\r\n    }, this._croppedZoom ? 30 : 0);\r\n  }\r\n\r\n  /** @private */\r\n  _prepareOpen() {\r\n    this.pswp.off('firstZoomPan', this._prepareOpen);\r\n    if (!this.isOpening) {\r\n      const slide = this.pswp.currSlide;\r\n      this.isOpening = true;\r\n      this.isClosing = false;\r\n      this._duration = this.pswp.options.showAnimationDuration;\r\n      if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {\r\n        this._duration = 0;\r\n      }\r\n      this._applyStartProps();\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _applyStartProps() {\r\n    const { pswp } = this;\r\n    const slide = this.pswp.currSlide;\r\n    const { options } = pswp;\r\n\r\n    if (options.showHideAnimationType === 'fade') {\r\n      options.showHideOpacity = true;\r\n      this._thumbBounds = undefined;\r\n    } else if (options.showHideAnimationType === 'none') {\r\n      options.showHideOpacity = false;\r\n      this._duration = 0;\r\n      this._thumbBounds = undefined;\r\n    } else if (this.isOpening && pswp._initialThumbBounds) {\r\n      // Use initial bounds if defined\r\n      this._thumbBounds = pswp._initialThumbBounds;\r\n    } else {\r\n      this._thumbBounds = this.pswp.getThumbBounds();\r\n    }\r\n\r\n    this._placeholder = slide?.getPlaceholderElement();\r\n\r\n    pswp.animations.stopAll();\r\n\r\n    // Discard animations when duration is less than 50ms\r\n    this._useAnimation = Boolean(this._duration && this._duration > 50);\r\n    this._animateZoom = Boolean(this._thumbBounds)\r\n                        && slide?.content.usePlaceholder()\r\n                        && (!this.isClosing || !pswp.mainScroll.isShifted());\r\n    if (!this._animateZoom) {\r\n      this._animateRootOpacity = true;\r\n\r\n      if (this.isOpening && slide) {\r\n        slide.zoomAndPanToInitial();\r\n        slide.applyCurrentZoomPan();\r\n      }\r\n    } else {\r\n      this._animateRootOpacity = options.showHideOpacity ?? false;\r\n    }\r\n    this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;\r\n    this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;\r\n\r\n    if (!this._useAnimation) {\r\n      this._duration = 0;\r\n      this._animateZoom = false;\r\n      this._animateBgOpacity = false;\r\n      this._animateRootOpacity = true;\r\n      if (this.isOpening) {\r\n        if (pswp.element) {\r\n          pswp.element.style.opacity = String(MIN_OPACITY);\r\n        }\r\n        pswp.applyBgOpacity(1);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {\r\n      // Properties are used when animation from cropped thumbnail\r\n      this._croppedZoom = true;\r\n      this._cropContainer1 = this.pswp.container;\r\n      this._cropContainer2 = this.pswp.currSlide?.holderElement;\r\n\r\n      if (pswp.container) {\r\n        pswp.container.style.overflow = 'hidden';\r\n        pswp.container.style.width = pswp.viewportSize.x + 'px';\r\n      }\r\n    } else {\r\n      this._croppedZoom = false;\r\n    }\r\n\r\n    if (this.isOpening) {\r\n      // Apply styles before opening transition\r\n      if (this._animateRootOpacity) {\r\n        if (pswp.element) {\r\n          pswp.element.style.opacity = String(MIN_OPACITY);\r\n        }\r\n        pswp.applyBgOpacity(1);\r\n      } else {\r\n        if (this._animateBgOpacity && pswp.bg) {\r\n          pswp.bg.style.opacity = String(MIN_OPACITY);\r\n        }\r\n        if (pswp.element) {\r\n          pswp.element.style.opacity = '1';\r\n        }\r\n      }\r\n\r\n      if (this._animateZoom) {\r\n        this._setClosedStateZoomPan();\r\n        if (this._placeholder) {\r\n          // tell browser that we plan to animate the placeholder\r\n          this._placeholder.style.willChange = 'transform';\r\n\r\n          // hide placeholder to allow hiding of\r\n          // elements that overlap it (such as icons over the thumbnail)\r\n          this._placeholder.style.opacity = String(MIN_OPACITY);\r\n        }\r\n      }\r\n    } else if (this.isClosing) {\r\n      // hide nearby slides to make sure that\r\n      // they are not painted during the transition\r\n      if (pswp.mainScroll.itemHolders[0]) {\r\n        pswp.mainScroll.itemHolders[0].el.style.display = 'none';\r\n      }\r\n      if (pswp.mainScroll.itemHolders[2]) {\r\n        pswp.mainScroll.itemHolders[2].el.style.display = 'none';\r\n      }\r\n\r\n      if (this._croppedZoom) {\r\n        if (pswp.mainScroll.x !== 0) {\r\n          // shift the main scroller to zero position\r\n          pswp.mainScroll.resetPosition();\r\n          pswp.mainScroll.resize();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _start() {\r\n    if (this.isOpening\r\n        && this._useAnimation\r\n        && this._placeholder\r\n        && this._placeholder.tagName === 'IMG') {\r\n      // To ensure smooth animation\r\n      // we wait till the current slide image placeholder is decoded,\r\n      // but no longer than 250ms,\r\n      // and no shorter than 50ms\r\n      // (just using requestanimationframe is not enough in Firefox,\r\n      // for some reason)\r\n      new Promise((resolve) => {\r\n        let decoded = false;\r\n        let isDelaying = true;\r\n        decodeImage(/** @type {HTMLImageElement} */ (this._placeholder)).finally(() => {\r\n          decoded = true;\r\n          if (!isDelaying) {\r\n            resolve(true);\r\n          }\r\n        });\r\n        setTimeout(() => {\r\n          isDelaying = false;\r\n          if (decoded) {\r\n            resolve(true);\r\n          }\r\n        }, 50);\r\n        setTimeout(resolve, 250);\r\n      }).finally(() => this._initiate());\r\n    } else {\r\n      this._initiate();\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _initiate() {\r\n    this.pswp.element?.style.setProperty('--pswp-transition-duration', this._duration + 'ms');\r\n\r\n    this.pswp.dispatch(\r\n      this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'\r\n    );\r\n\r\n    // legacy event\r\n    this.pswp.dispatch(\r\n      /** @type {'initialZoomIn' | 'initialZoomOut'} */\r\n      ('initialZoom' + (this.isOpening ? 'In' : 'Out'))\r\n    );\r\n\r\n    this.pswp.element?.classList.toggle('pswp--ui-visible', this.isOpening);\r\n\r\n    if (this.isOpening) {\r\n      if (this._placeholder) {\r\n        // unhide the placeholder\r\n        this._placeholder.style.opacity = '1';\r\n      }\r\n      this._animateToOpenState();\r\n    } else if (this.isClosing) {\r\n      this._animateToClosedState();\r\n    }\r\n\r\n    if (!this._useAnimation) {\r\n      this._onAnimationComplete();\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _onAnimationComplete() {\r\n    const { pswp } = this;\r\n    this.isOpen = this.isOpening;\r\n    this.isClosed = this.isClosing;\r\n    this.isOpening = false;\r\n    this.isClosing = false;\r\n\r\n    pswp.dispatch(\r\n      this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'\r\n    );\r\n\r\n    // legacy event\r\n    pswp.dispatch(\r\n      /** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */\r\n      ('initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'))\r\n    );\r\n\r\n    if (this.isClosed) {\r\n      pswp.destroy();\r\n    } else if (this.isOpen) {\r\n      if (this._animateZoom && pswp.container) {\r\n        pswp.container.style.overflow = 'visible';\r\n        pswp.container.style.width = '100%';\r\n      }\r\n      pswp.currSlide?.applyCurrentZoomPan();\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _animateToOpenState() {\r\n    const { pswp } = this;\r\n    if (this._animateZoom) {\r\n      if (this._croppedZoom && this._cropContainer1 && this._cropContainer2) {\r\n        this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');\r\n        this._animateTo(this._cropContainer2, 'transform', 'none');\r\n      }\r\n\r\n      if (pswp.currSlide) {\r\n        pswp.currSlide.zoomAndPanToInitial();\r\n        this._animateTo(\r\n          pswp.currSlide.container,\r\n          'transform',\r\n          pswp.currSlide.getCurrentTransform()\r\n        );\r\n      }\r\n    }\r\n\r\n    if (this._animateBgOpacity && pswp.bg) {\r\n      this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));\r\n    }\r\n\r\n    if (this._animateRootOpacity && pswp.element) {\r\n      this._animateTo(pswp.element, 'opacity', '1');\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  _animateToClosedState() {\r\n    const { pswp } = this;\r\n\r\n    if (this._animateZoom) {\r\n      this._setClosedStateZoomPan(true);\r\n    }\r\n\r\n    // do not animate opacity if it's already at 0\r\n    if (this._animateBgOpacity && pswp.bgOpacity > 0.01 && pswp.bg) {\r\n      this._animateTo(pswp.bg, 'opacity', '0');\r\n    }\r\n\r\n    if (this._animateRootOpacity && pswp.element) {\r\n      this._animateTo(pswp.element, 'opacity', '0');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {boolean} [animate]\r\n   */\r\n  _setClosedStateZoomPan(animate) {\r\n    if (!this._thumbBounds) return;\r\n\r\n    const { pswp } = this;\r\n    const { innerRect } = this._thumbBounds;\r\n    const { currSlide, viewportSize } = pswp;\r\n\r\n    if (this._croppedZoom && innerRect && this._cropContainer1 && this._cropContainer2) {\r\n      const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;\r\n      const containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;\r\n      const containerTwoPanX = viewportSize.x - innerRect.w;\r\n      const containerTwoPanY = viewportSize.y - innerRect.h;\r\n\r\n\r\n      if (animate) {\r\n        this._animateTo(\r\n          this._cropContainer1,\r\n          'transform',\r\n          toTransformString(containerOnePanX, containerOnePanY)\r\n        );\r\n\r\n        this._animateTo(\r\n          this._cropContainer2,\r\n          'transform',\r\n          toTransformString(containerTwoPanX, containerTwoPanY)\r\n        );\r\n      } else {\r\n        setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);\r\n        setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);\r\n      }\r\n    }\r\n\r\n    if (currSlide) {\r\n      equalizePoints(currSlide.pan, innerRect || this._thumbBounds);\r\n      currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;\r\n      if (animate) {\r\n        this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());\r\n      } else {\r\n        currSlide.applyCurrentZoomPan();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {HTMLElement} target\r\n   * @param {'transform' | 'opacity'} prop\r\n   * @param {string} propValue\r\n   */\r\n  _animateTo(target, prop, propValue) {\r\n    if (!this._duration) {\r\n      target.style[prop] = propValue;\r\n      return;\r\n    }\r\n\r\n    const { animations } = this.pswp;\r\n    /** @type {AnimationProps} */\r\n    const animProps = {\r\n      duration: this._duration,\r\n      easing: this.pswp.options.easing,\r\n      onComplete: () => {\r\n        if (!animations.activeAnimations.length) {\r\n          this._onAnimationComplete();\r\n        }\r\n      },\r\n      target,\r\n    };\r\n    animProps[prop] = propValue;\r\n    animations.startTransition(animProps);\r\n  }\r\n}\r\n\r\nexport default Opener;\r\n","import {\r\n  createElement,\r\n  equalizePoints,\r\n  pointsEqual,\r\n  clamp,\r\n} from './util/util.js';\r\n\r\nimport DOMEvents from './util/dom-events.js';\r\nimport Slide from './slide/slide.js';\r\nimport Gestures from './gestures/gestures.js';\r\nimport MainScroll from './main-scroll.js';\r\n\r\nimport Keyboard from './keyboard.js';\r\nimport Animations from './util/animations.js';\r\nimport ScrollWheel from './scroll-wheel.js';\r\nimport UI from './ui/ui.js';\r\nimport { getViewportSize } from './util/viewport-size.js';\r\nimport { getThumbBounds } from './slide/get-thumb-bounds.js';\r\nimport PhotoSwipeBase from './core/base.js';\r\nimport Opener from './opener.js';\r\nimport ContentLoader from './slide/loader.js';\r\n\r\n/**\r\n * @template T\r\n * @typedef {import('./types.js').Type<T>} Type<T>\r\n */\r\n\r\n/** @typedef {import('./slide/slide.js').SlideData} SlideData */\r\n/** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */\r\n/** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */\r\n/** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */\r\n/** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */\r\n/** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */\r\n/** @typedef {import('./slide/get-thumb-bounds').Bounds} Bounds */\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>\r\n */\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>\r\n */\r\n\r\n/** @typedef {{ x: number; y: number; id?: string | number }} Point */\r\n/** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */\r\n/** @typedef {SlideData[]} DataSourceArray */\r\n/** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */\r\n/** @typedef {DataSourceArray | DataSourceObject} DataSource */\r\n/** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */\r\n/** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */\r\n/** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */\r\n/** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */\r\n\r\n/**\r\n * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider\r\n */\r\n\r\n/** @typedef {Partial<PreparedPhotoSwipeOptions>} PhotoSwipeOptions https://photoswipe.com/options/ */\r\n/**\r\n * @typedef {Object} PreparedPhotoSwipeOptions\r\n *\r\n * @prop {DataSource} [dataSource]\r\n * Pass an array of any items via dataSource option. Its length will determine amount of slides\r\n * (which may be modified further from numItems event).\r\n *\r\n * Each item should contain data that you need to generate slide\r\n * (for image slide it would be src (image URL), width (image width), height, srcset, alt).\r\n *\r\n * If these properties are not present in your initial array, you may \"pre-parse\" each item from itemData filter.\r\n *\r\n * @prop {number} bgOpacity\r\n * Background backdrop opacity, always define it via this option and not via CSS rgba color.\r\n *\r\n * @prop {number} spacing\r\n * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).\r\n *\r\n * @prop {boolean} allowPanToNext\r\n * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.\r\n *\r\n * @prop {boolean} loop\r\n * If set to true you'll be able to swipe from the last to the first image.\r\n * Option is always false when there are less than 3 slides.\r\n *\r\n * @prop {boolean} [wheelToZoom]\r\n * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.\r\n *\r\n * @prop {boolean} pinchToClose\r\n * Pinch touch gesture to close the gallery.\r\n *\r\n * @prop {boolean} closeOnVerticalDrag\r\n * Vertical drag gesture to close the PhotoSwipe.\r\n *\r\n * @prop {Padding} [padding]\r\n * Slide area padding (in pixels).\r\n *\r\n * @prop {(viewportSize: Point, itemData: SlideData, index: number) => Padding} [paddingFn]\r\n * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:\r\n *\r\n * @prop {number | false} hideAnimationDuration\r\n * Transition duration in milliseconds, can be 0.\r\n *\r\n * @prop {number | false} showAnimationDuration\r\n * Transition duration in milliseconds, can be 0.\r\n *\r\n * @prop {number | false} zoomAnimationDuration\r\n * Transition duration in milliseconds, can be 0.\r\n *\r\n * @prop {string} easing\r\n * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.\r\n *\r\n * @prop {boolean} escKey\r\n * Esc key to close.\r\n *\r\n * @prop {boolean} arrowKeys\r\n * Left/right arrow keys for navigation.\r\n *\r\n * @prop {boolean} trapFocus\r\n * Trap focus within PhotoSwipe element while it's open.\r\n *\r\n * @prop {boolean} returnFocus\r\n * Restore focus the last active element after PhotoSwipe is closed.\r\n *\r\n * @prop {boolean} clickToCloseNonZoomable\r\n * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.\r\n *\r\n * @prop {ActionType | ActionFn | false} imageClickAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {ActionType | ActionFn | false} bgClickAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {ActionType | ActionFn | false} tapAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {ActionType | ActionFn | false} doubleTapAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {number} preloaderDelay\r\n * Delay before the loading indicator will be displayed,\r\n * if image is loaded during it - the indicator will not be displayed at all. Can be zero.\r\n *\r\n * @prop {string} indexIndicatorSep\r\n * Used for slide count indicator (\"1 of 10 \").\r\n *\r\n * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipeBase) => Point} [getViewportSizeFn]\r\n * A function that should return slide viewport width and height, in format {x: 100, y: 100}.\r\n *\r\n * @prop {string} errorMsg\r\n * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.\r\n *\r\n * @prop {[number, number]} preload\r\n * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,\r\n * first one - number of items to preload before the current image, second one - after the current image.\r\n * Two nearby images are always loaded.\r\n *\r\n * @prop {string} [mainClass]\r\n * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.\r\n * Example on Styling page.\r\n *\r\n * @prop {HTMLElement} [appendToEl]\r\n * Element to which PhotoSwipe dialog will be appended when it opens.\r\n *\r\n * @prop {number} maxWidthToAnimate\r\n * Maximum width of image to animate, if initial rendered image width\r\n * is larger than this value - the opening/closing transition will be automatically disabled.\r\n *\r\n * @prop {string} [closeTitle]\r\n * Translating\r\n *\r\n * @prop {string} [zoomTitle]\r\n * Translating\r\n *\r\n * @prop {string} [arrowPrevTitle]\r\n * Translating\r\n *\r\n * @prop {string} [arrowNextTitle]\r\n * Translating\r\n *\r\n * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]\r\n * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).\r\n * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.\r\n *\r\n * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.\r\n *\r\n * @prop {number} index\r\n * Defines start slide index.\r\n *\r\n * @prop {(e: MouseEvent) => number} [getClickedIndexFn]\r\n *\r\n * @prop {boolean} [arrowPrev]\r\n * @prop {boolean} [arrowNext]\r\n * @prop {boolean} [zoom]\r\n * @prop {boolean} [close]\r\n * @prop {boolean} [counter]\r\n *\r\n * @prop {string} [arrowPrevSVG]\r\n * @prop {string} [arrowNextSVG]\r\n * @prop {string} [zoomSVG]\r\n * @prop {string} [closeSVG]\r\n * @prop {string} [counterSVG]\r\n *\r\n * @prop {string} [arrowPrevTitle]\r\n * @prop {string} [arrowNextTitle]\r\n * @prop {string} [zoomTitle]\r\n * @prop {string} [closeTitle]\r\n * @prop {string} [counterTitle]\r\n *\r\n * @prop {ZoomLevelOption} [initialZoomLevel]\r\n * @prop {ZoomLevelOption} [secondaryZoomLevel]\r\n * @prop {ZoomLevelOption} [maxZoomLevel]\r\n *\r\n * @prop {boolean} [mouseMovePan]\r\n * @prop {Point | null} [initialPointerPos]\r\n * @prop {boolean} [showHideOpacity]\r\n *\r\n * @prop {PhotoSwipeModuleOption} [pswpModule]\r\n * @prop {() => Promise<any>} [openPromise]\r\n * @prop {boolean} [preloadFirstSlide]\r\n * @prop {ElementProvider} [gallery]\r\n * @prop {string} [gallerySelector]\r\n * @prop {ElementProvider} [children]\r\n * @prop {string} [childSelector]\r\n * @prop {string | false} [thumbSelector]\r\n */\r\n\r\n/** @type {PreparedPhotoSwipeOptions} */\r\nconst defaultOptions = {\r\n  allowPanToNext: true,\r\n  spacing: 0.1,\r\n  loop: true,\r\n  pinchToClose: true,\r\n  closeOnVerticalDrag: true,\r\n  hideAnimationDuration: 333,\r\n  showAnimationDuration: 333,\r\n  zoomAnimationDuration: 333,\r\n  escKey: true,\r\n  arrowKeys: true,\r\n  trapFocus: true,\r\n  returnFocus: true,\r\n  maxWidthToAnimate: 4000,\r\n  clickToCloseNonZoomable: true,\r\n  imageClickAction: 'zoom-or-close',\r\n  bgClickAction: 'close',\r\n  tapAction: 'toggle-controls',\r\n  doubleTapAction: 'zoom',\r\n  indexIndicatorSep: ' / ',\r\n  preloaderDelay: 2000,\r\n  bgOpacity: 0.8,\r\n\r\n  index: 0,\r\n  errorMsg: 'The image cannot be loaded',\r\n  preload: [1, 2],\r\n  easing: 'cubic-bezier(.4,0,.22,1)'\r\n};\r\n\r\n/**\r\n * PhotoSwipe Core\r\n */\r\nclass PhotoSwipe extends PhotoSwipeBase {\r\n  /**\r\n   * @param {PhotoSwipeOptions} [options]\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.options = this._prepareOptions(options || {});\r\n\r\n    /**\r\n     * offset of viewport relative to document\r\n     *\r\n     * @type {Point}\r\n     */\r\n    this.offset = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * @type {Point}\r\n     * @private\r\n     */\r\n    this._prevViewportSize = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Size of scrollable PhotoSwipe viewport\r\n     *\r\n     * @type {Point}\r\n     */\r\n    this.viewportSize = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * background (backdrop) opacity\r\n     */\r\n    this.bgOpacity = 1;\r\n    this.currIndex = 0;\r\n    this.potentialIndex = 0;\r\n    this.isOpen = false;\r\n    this.isDestroying = false;\r\n    this.hasMouse = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {SlideData}\r\n     */\r\n    this._initialItemData = {};\r\n    /** @type {Bounds | undefined} */\r\n    this._initialThumbBounds = undefined;\r\n\r\n    /** @type {HTMLDivElement | undefined} */\r\n    this.topBar = undefined;\r\n    /** @type {HTMLDivElement | undefined} */\r\n    this.element = undefined;\r\n    /** @type {HTMLDivElement | undefined} */\r\n    this.template = undefined;\r\n    /** @type {HTMLDivElement | undefined} */\r\n    this.container = undefined;\r\n    /** @type {HTMLElement | undefined} */\r\n    this.scrollWrap = undefined;\r\n    /** @type {Slide | undefined} */\r\n    this.currSlide = undefined;\r\n\r\n    this.events = new DOMEvents();\r\n    this.animations = new Animations();\r\n    this.mainScroll = new MainScroll(this);\r\n    this.gestures = new Gestures(this);\r\n    this.opener = new Opener(this);\r\n    this.keyboard = new Keyboard(this);\r\n    this.contentLoader = new ContentLoader(this);\r\n  }\r\n\r\n  /** @returns {boolean} */\r\n  init() {\r\n    if (this.isOpen || this.isDestroying) {\r\n      return false;\r\n    }\r\n\r\n    this.isOpen = true;\r\n    this.dispatch('init'); // legacy\r\n    this.dispatch('beforeOpen');\r\n\r\n    this._createMainStructure();\r\n\r\n    // add classes to the root element of PhotoSwipe\r\n    let rootClasses = 'pswp--open';\r\n    if (this.gestures.supportsTouch) {\r\n      rootClasses += ' pswp--touch';\r\n    }\r\n    if (this.options.mainClass) {\r\n      rootClasses += ' ' + this.options.mainClass;\r\n    }\r\n    if (this.element) {\r\n      this.element.className += ' ' + rootClasses;\r\n    }\r\n\r\n    this.currIndex = this.options.index || 0;\r\n    this.potentialIndex = this.currIndex;\r\n    this.dispatch('firstUpdate'); // starting index can be modified here\r\n\r\n    // initialize scroll wheel handler to block the scroll\r\n    this.scrollWheel = new ScrollWheel(this);\r\n\r\n    // sanitize index\r\n    if (Number.isNaN(this.currIndex)\r\n        || this.currIndex < 0\r\n        || this.currIndex >= this.getNumItems()) {\r\n      this.currIndex = 0;\r\n    }\r\n\r\n    if (!this.gestures.supportsTouch) {\r\n      // enable mouse features if no touch support detected\r\n      this.mouseDetected();\r\n    }\r\n\r\n    // causes forced synchronous layout\r\n    this.updateSize();\r\n\r\n    this.offset.y = window.pageYOffset;\r\n\r\n    this._initialItemData = this.getItemData(this.currIndex);\r\n    this.dispatch('gettingData', {\r\n      index: this.currIndex,\r\n      data: this._initialItemData,\r\n      slide: undefined\r\n    });\r\n\r\n    // *Layout* - calculate size and position of elements here\r\n    this._initialThumbBounds = this.getThumbBounds();\r\n    this.dispatch('initialLayout');\r\n\r\n    this.on('openingAnimationEnd', () => {\r\n      const { itemHolders } = this.mainScroll;\r\n\r\n      // Add content to the previous and next slide\r\n      if (itemHolders[0]) {\r\n        itemHolders[0].el.style.display = 'block';\r\n        this.setContent(itemHolders[0], this.currIndex - 1);\r\n      }\r\n      if (itemHolders[2]) {\r\n        itemHolders[2].el.style.display = 'block';\r\n        this.setContent(itemHolders[2], this.currIndex + 1);\r\n      }\r\n\r\n      this.appendHeavy();\r\n\r\n      this.contentLoader.updateLazy();\r\n\r\n      this.events.add(window, 'resize', this._handlePageResize.bind(this));\r\n      this.events.add(window, 'scroll', this._updatePageScrollOffset.bind(this));\r\n      this.dispatch('bindEvents');\r\n    });\r\n\r\n    // set content for center slide (first time)\r\n    if (this.mainScroll.itemHolders[1]) {\r\n      this.setContent(this.mainScroll.itemHolders[1], this.currIndex);\r\n    }\r\n    this.dispatch('change');\r\n\r\n    this.opener.open();\r\n\r\n    this.dispatch('afterInit');\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get looped slide index\r\n   * (for example, -1 will return the last slide)\r\n   *\r\n   * @param {number} index\r\n   * @returns {number}\r\n   */\r\n  getLoopedIndex(index) {\r\n    const numSlides = this.getNumItems();\r\n\r\n    if (this.options.loop) {\r\n      if (index > numSlides - 1) {\r\n        index -= numSlides;\r\n      }\r\n\r\n      if (index < 0) {\r\n        index += numSlides;\r\n      }\r\n    }\r\n\r\n    return clamp(index, 0, numSlides - 1);\r\n  }\r\n\r\n  appendHeavy() {\r\n    this.mainScroll.itemHolders.forEach((itemHolder) => {\r\n      itemHolder.slide?.appendHeavy();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Change the slide\r\n   * @param {number} index New index\r\n   */\r\n  goTo(index) {\r\n    this.mainScroll.moveIndexBy(\r\n      this.getLoopedIndex(index) - this.potentialIndex\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Go to the next slide.\r\n   */\r\n  next() {\r\n    this.goTo(this.potentialIndex + 1);\r\n  }\r\n\r\n  /**\r\n   * Go to the previous slide.\r\n   */\r\n  prev() {\r\n    this.goTo(this.potentialIndex - 1);\r\n  }\r\n\r\n  /**\r\n   * @see slide/slide.js zoomTo\r\n   *\r\n   * @param {Parameters<Slide['zoomTo']>} args\r\n   */\r\n  zoomTo(...args) {\r\n    this.currSlide?.zoomTo(...args);\r\n  }\r\n\r\n  /**\r\n   * @see slide/slide.js toggleZoom\r\n   */\r\n  toggleZoom() {\r\n    this.currSlide?.toggleZoom();\r\n  }\r\n\r\n  /**\r\n   * Close the gallery.\r\n   * After closing transition ends - destroy it\r\n   */\r\n  close() {\r\n    if (!this.opener.isOpen || this.isDestroying) {\r\n      return;\r\n    }\r\n\r\n    this.isDestroying = true;\r\n\r\n    this.dispatch('close');\r\n\r\n    this.events.removeAll();\r\n    this.opener.close();\r\n  }\r\n\r\n  /**\r\n   * Destroys the gallery:\r\n   * - instantly closes the gallery\r\n   * - unbinds events,\r\n   * - cleans intervals and timeouts\r\n   * - removes elements from DOM\r\n   */\r\n  destroy() {\r\n    if (!this.isDestroying) {\r\n      this.options.showHideAnimationType = 'none';\r\n      this.close();\r\n      return;\r\n    }\r\n\r\n    this.dispatch('destroy');\r\n\r\n    this._listeners = {};\r\n\r\n    if (this.scrollWrap) {\r\n      this.scrollWrap.ontouchmove = null;\r\n      this.scrollWrap.ontouchend = null;\r\n    }\r\n\r\n    this.element?.remove();\r\n\r\n    this.mainScroll.itemHolders.forEach((itemHolder) => {\r\n      itemHolder.slide?.destroy();\r\n    });\r\n\r\n    this.contentLoader.destroy();\r\n    this.events.removeAll();\r\n  }\r\n\r\n  /**\r\n   * Refresh/reload content of a slide by its index\r\n   *\r\n   * @param {number} slideIndex\r\n   */\r\n  refreshSlideContent(slideIndex) {\r\n    this.contentLoader.removeByIndex(slideIndex);\r\n    this.mainScroll.itemHolders.forEach((itemHolder, i) => {\r\n      let potentialHolderIndex = (this.currSlide?.index ?? 0) - 1 + i;\r\n      if (this.canLoop()) {\r\n        potentialHolderIndex = this.getLoopedIndex(potentialHolderIndex);\r\n      }\r\n      if (potentialHolderIndex === slideIndex) {\r\n        // set the new slide content\r\n        this.setContent(itemHolder, slideIndex, true);\r\n\r\n        // activate the new slide if it's current\r\n        if (i === 1) {\r\n          this.currSlide = itemHolder.slide;\r\n          itemHolder.slide?.setIsActive(true);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.dispatch('change');\r\n  }\r\n\r\n\r\n  /**\r\n   * Set slide content\r\n   *\r\n   * @param {ItemHolder} holder mainScroll.itemHolders array item\r\n   * @param {number} index Slide index\r\n   * @param {boolean} [force] If content should be set even if index wasn't changed\r\n   */\r\n  setContent(holder, index, force) {\r\n    if (this.canLoop()) {\r\n      index = this.getLoopedIndex(index);\r\n    }\r\n\r\n    if (holder.slide) {\r\n      if (holder.slide.index === index && !force) {\r\n        // exit if holder already contains this slide\r\n        // this could be common when just three slides are used\r\n        return;\r\n      }\r\n\r\n      // destroy previous slide\r\n      holder.slide.destroy();\r\n      holder.slide = undefined;\r\n    }\r\n\r\n    // exit if no loop and index is out of bounds\r\n    if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {\r\n      return;\r\n    }\r\n\r\n    const itemData = this.getItemData(index);\r\n    holder.slide = new Slide(itemData, index, this);\r\n\r\n    // set current slide\r\n    if (index === this.currIndex) {\r\n      this.currSlide = holder.slide;\r\n    }\r\n\r\n    holder.slide.append(holder.el);\r\n  }\r\n\r\n  /** @returns {Point} */\r\n  getViewportCenterPoint() {\r\n    return {\r\n      x: this.viewportSize.x / 2,\r\n      y: this.viewportSize.y / 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update size of all elements.\r\n   * Executed on init and on page resize.\r\n   *\r\n   * @param {boolean} [force] Update size even if size of viewport was not changed.\r\n   */\r\n  updateSize(force) {\r\n    // let item;\r\n    // let itemIndex;\r\n\r\n    if (this.isDestroying) {\r\n      // exit if PhotoSwipe is closed or closing\r\n      // (to avoid errors, as resize event might be delayed)\r\n      return;\r\n    }\r\n\r\n    //const newWidth = this.scrollWrap.clientWidth;\r\n    //const newHeight = this.scrollWrap.clientHeight;\r\n\r\n    const newViewportSize = getViewportSize(this.options, this);\r\n\r\n    if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {\r\n      // Exit if dimensions were not changed\r\n      return;\r\n    }\r\n\r\n    //this._prevViewportSize.x = newWidth;\r\n    //this._prevViewportSize.y = newHeight;\r\n    equalizePoints(this._prevViewportSize, newViewportSize);\r\n\r\n    this.dispatch('beforeResize');\r\n\r\n    equalizePoints(this.viewportSize, this._prevViewportSize);\r\n\r\n    this._updatePageScrollOffset();\r\n\r\n    this.dispatch('viewportSize');\r\n\r\n    // Resize slides only after opener animation is finished\r\n    // and don't re-calculate size on inital size update\r\n    this.mainScroll.resize(this.opener.isOpen);\r\n\r\n    if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {\r\n      this.mouseDetected();\r\n    }\r\n\r\n    this.dispatch('resize');\r\n  }\r\n\r\n  /**\r\n   * @param {number} opacity\r\n   */\r\n  applyBgOpacity(opacity) {\r\n    this.bgOpacity = Math.max(opacity, 0);\r\n    if (this.bg) {\r\n      this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether mouse is detected\r\n   */\r\n  mouseDetected() {\r\n    if (!this.hasMouse) {\r\n      this.hasMouse = true;\r\n      this.element?.classList.add('pswp--has_mouse');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Page resize event handler\r\n   *\r\n   * @private\r\n   */\r\n  _handlePageResize() {\r\n    this.updateSize();\r\n\r\n    // In iOS webview, if element size depends on document size,\r\n    // it'll be measured incorrectly in resize event\r\n    //\r\n    // https://bugs.webkit.org/show_bug.cgi?id=170595\r\n    // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d\r\n    if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {\r\n      setTimeout(() => {\r\n        this.updateSize();\r\n      }, 500);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Page scroll offset is used\r\n   * to get correct coordinates\r\n   * relative to PhotoSwipe viewport.\r\n   *\r\n   * @private\r\n   */\r\n  _updatePageScrollOffset() {\r\n    this.setScrollOffset(0, window.pageYOffset);\r\n  }\r\n\r\n  /**\r\n   * @param {number} x\r\n   * @param {number} y\r\n   */\r\n  setScrollOffset(x, y) {\r\n    this.offset.x = x;\r\n    this.offset.y = y;\r\n    this.dispatch('updateScrollOffset');\r\n  }\r\n\r\n  /**\r\n   * Create main HTML structure of PhotoSwipe,\r\n   * and add it to DOM\r\n   *\r\n   * @private\r\n   */\r\n  _createMainStructure() {\r\n    // root DOM element of PhotoSwipe (.pswp)\r\n    this.element = createElement('pswp', 'div');\r\n    this.element.setAttribute('tabindex', '-1');\r\n    this.element.setAttribute('role', 'dialog');\r\n\r\n    // template is legacy prop\r\n    this.template = this.element;\r\n\r\n    // Background is added as a separate element,\r\n    // as animating opacity is faster than animating rgba()\r\n    this.bg = createElement('pswp__bg', 'div', this.element);\r\n    this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);\r\n    this.container = createElement('pswp__container', 'div', this.scrollWrap);\r\n\r\n    // aria pattern: carousel\r\n    this.scrollWrap.setAttribute('aria-roledescription', 'carousel');\r\n    this.container.setAttribute('aria-live', 'off');\r\n    this.container.setAttribute('id', 'pswp__items');\r\n\r\n    this.mainScroll.appendHolders();\r\n\r\n    this.ui = new UI(this);\r\n    this.ui.init();\r\n\r\n    // append to DOM\r\n    (this.options.appendToEl || document.body).appendChild(this.element);\r\n  }\r\n\r\n\r\n  /**\r\n   * Get position and dimensions of small thumbnail\r\n   *   {x:,y:,w:}\r\n   *\r\n   * Height is optional (calculated based on the large image)\r\n   *\r\n   * @returns {Bounds | undefined}\r\n   */\r\n  getThumbBounds() {\r\n    return getThumbBounds(\r\n      this.currIndex,\r\n      this.currSlide ? this.currSlide.data : this._initialItemData,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * If the PhotoSwipe can have continuous loop\r\n   * @returns Boolean\r\n   */\r\n  canLoop() {\r\n    return (this.options.loop && this.getNumItems() > 2);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {PhotoSwipeOptions} options\r\n   * @returns {PreparedPhotoSwipeOptions}\r\n   */\r\n  _prepareOptions(options) {\r\n    if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {\r\n      options.showHideAnimationType = 'none';\r\n      options.zoomAnimationDuration = 0;\r\n    }\r\n\r\n    /** @type {PreparedPhotoSwipeOptions} */\r\n    return {\r\n      ...defaultOptions,\r\n      ...options\r\n    };\r\n  }\r\n}\r\n\r\nexport default PhotoSwipe;\r\n","/** @typedef {import('../photoswipe.js').Point} Point */\r\n\r\n/**\r\n * @template {keyof HTMLElementTagNameMap} T\r\n * @param {string} className\r\n * @param {T} tagName\r\n * @param {Node} [appendToEl]\r\n * @returns {HTMLElementTagNameMap[T]}\r\n */\r\nexport function createElement(className, tagName, appendToEl) {\r\n  const el = document.createElement(tagName);\r\n  if (className) {\r\n    el.className = className;\r\n  }\r\n  if (appendToEl) {\r\n    appendToEl.appendChild(el);\r\n  }\r\n  return el;\r\n}\r\n\r\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {Point}\r\n */\r\nexport function equalizePoints(p1, p2) {\r\n  p1.x = p2.x;\r\n  p1.y = p2.y;\r\n  if (p2.id !== undefined) {\r\n    p1.id = p2.id;\r\n  }\r\n  return p1;\r\n}\r\n\r\n/**\r\n * @param {Point} p\r\n */\r\nexport function roundPoint(p) {\r\n  p.x = Math.round(p.x);\r\n  p.y = Math.round(p.y);\r\n}\r\n\r\n/**\r\n * Returns distance between two points.\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {number}\r\n */\r\nexport function getDistanceBetween(p1, p2) {\r\n  const x = Math.abs(p1.x - p2.x);\r\n  const y = Math.abs(p1.y - p2.y);\r\n  return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * Whether X and Y positions of points are equal\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {boolean}\r\n */\r\nexport function pointsEqual(p1, p2) {\r\n  return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n\r\n/**\r\n * The float result between the min and max values.\r\n *\r\n * @param {number} val\r\n * @param {number} min\r\n * @param {number} max\r\n * @returns {number}\r\n */\r\nexport function clamp(val, min, max) {\r\n  return Math.min(Math.max(val, min), max);\r\n}\r\n\r\n/**\r\n * Get transform string\r\n *\r\n * @param {number} x\r\n * @param {number} [y]\r\n * @param {number} [scale]\r\n * @returns {string}\r\n */\r\nexport function toTransformString(x, y, scale) {\r\n  let propValue = `translate3d(${x}px,${y || 0}px,0)`;\r\n\r\n  if (scale !== undefined) {\r\n    propValue += ` scale3d(${scale},${scale},1)`;\r\n  }\r\n\r\n  return propValue;\r\n}\r\n\r\n/**\r\n * Apply transform:translate(x, y) scale(scale) to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {number} x\r\n * @param {number} [y]\r\n * @param {number} [scale]\r\n */\r\nexport function setTransform(el, x, y, scale) {\r\n  el.style.transform = toTransformString(x, y, scale);\r\n}\r\n\r\nconst defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';\r\n\r\n/**\r\n * Apply CSS transition to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string} [prop] CSS property to animate\r\n * @param {number} [duration] in ms\r\n * @param {string} [ease] CSS easing function\r\n */\r\nexport function setTransitionStyle(el, prop, duration, ease) {\r\n  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for \"toggle state\" transitions\r\n  // out: 'cubic-bezier(0, 0, .22, 1)', // for \"show\" transitions\r\n  // in: 'cubic-bezier(.4, 0, 1, 1)'// for \"hide\" transitions\r\n  el.style.transition = prop\r\n    ? `${prop} ${duration}ms ${ease || defaultCSSEasing}`\r\n    : 'none';\r\n}\r\n\r\n/**\r\n * Apply width and height CSS properties to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string | number} w\r\n * @param {string | number} h\r\n */\r\nexport function setWidthHeight(el, w, h) {\r\n  el.style.width = (typeof w === 'number') ? `${w}px` : w;\r\n  el.style.height = (typeof h === 'number') ? `${h}px` : h;\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n */\r\nexport function removeTransitionStyle(el) {\r\n  setTransitionStyle(el);\r\n}\r\n\r\n/**\r\n * @param {HTMLImageElement} img\r\n * @returns {Promise<HTMLImageElement | void>}\r\n */\r\nexport function decodeImage(img) {\r\n  if ('decode' in img) {\r\n    return img.decode().catch(() => {});\r\n  }\r\n\r\n  if (img.complete) {\r\n    return Promise.resolve(img);\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n  });\r\n}\r\n\r\n/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */\r\n/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */\r\nexport const LOAD_STATE = {\r\n  IDLE: 'idle',\r\n  LOADING: 'loading',\r\n  LOADED: 'loaded',\r\n  ERROR: 'error',\r\n};\r\n\r\n\r\n/**\r\n * Check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {MouseEvent | KeyboardEvent} e\r\n * @returns {boolean}\r\n */\r\nexport function specialKeyUsed(e) {\r\n  return ('button' in e && e.button === 1) || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;\r\n}\r\n\r\n/**\r\n * Parse `gallery` or `children` options.\r\n *\r\n * @param {import('../photoswipe.js').ElementProvider} [option]\r\n * @param {string} [legacySelector]\r\n * @param {HTMLElement | Document} [parent]\r\n * @returns HTMLElement[]\r\n */\r\nexport function getElementsFromOption(option, legacySelector, parent = document) {\r\n  /** @type {HTMLElement[]} */\r\n  let elements = [];\r\n\r\n  if (option instanceof Element) {\r\n    elements = [option];\r\n  } else if (option instanceof NodeList || Array.isArray(option)) {\r\n    elements = Array.from(option);\r\n  } else {\r\n    const selector = typeof option === 'string' ? option : legacySelector;\r\n    if (selector) {\r\n      elements = Array.from(parent.querySelectorAll(selector));\r\n    }\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\n/**\r\n * Check if variable is PhotoSwipe class\r\n *\r\n * @param {any} fn\r\n * @returns {boolean}\r\n */\r\nexport function isPswpClass(fn) {\r\n  return typeof fn === 'function'\r\n    && fn.prototype\r\n    && fn.prototype.goTo;\r\n}\r\n\r\n/**\r\n * Check if browser is Safari\r\n *\r\n * @returns {boolean}\r\n */\r\nexport function isSafari() {\r\n  return !!(navigator.vendor && navigator.vendor.match(/apple/i));\r\n}\r\n\r\n","/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../photoswipe.js').DataSource} DataSource */\r\n/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */\r\n/** @typedef {import('../slide/content.js').default} ContentDefault */\r\n/** @typedef {import('../slide/slide.js').default} Slide */\r\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\r\n/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */\r\n/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */\r\n\r\n/**\r\n * Allow adding an arbitrary props to the Content\r\n * https://photoswipe.com/custom-content/#using-webp-image-format\r\n * @typedef {ContentDefault & Record<string, any>} Content\r\n */\r\n/** @typedef {{ x?: number; y?: number }} Point */\r\n\r\n/**\r\n * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/\r\n *\r\n *\r\n * https://photoswipe.com/adding-ui-elements/\r\n *\r\n * @prop {undefined} uiRegister\r\n * @prop {{ data: UIElementData }} uiElementCreate\r\n *\r\n *\r\n * https://photoswipe.com/events/#initialization-events\r\n *\r\n * @prop {undefined} beforeOpen\r\n * @prop {undefined} firstUpdate\r\n * @prop {undefined} initialLayout\r\n * @prop {undefined} change\r\n * @prop {undefined} afterInit\r\n * @prop {undefined} bindEvents\r\n *\r\n *\r\n * https://photoswipe.com/events/#opening-or-closing-transition-events\r\n *\r\n * @prop {undefined} openingAnimationStart\r\n * @prop {undefined} openingAnimationEnd\r\n * @prop {undefined} closingAnimationStart\r\n * @prop {undefined} closingAnimationEnd\r\n *\r\n *\r\n * https://photoswipe.com/events/#closing-events\r\n *\r\n * @prop {undefined} close\r\n * @prop {undefined} destroy\r\n *\r\n *\r\n * https://photoswipe.com/events/#pointer-and-gesture-events\r\n *\r\n * @prop {{ originalEvent: PointerEvent }} pointerDown\r\n * @prop {{ originalEvent: PointerEvent }} pointerMove\r\n * @prop {{ originalEvent: PointerEvent }} pointerUp\r\n * @prop {{ bgOpacity: number }} pinchClose can be default prevented\r\n * @prop {{ panY: number }} verticalDrag can be default prevented\r\n *\r\n *\r\n * https://photoswipe.com/events/#slide-content-events\r\n *\r\n * @prop {{ content: Content }} contentInit\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented\r\n * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete\r\n * @prop {{ content: Content; slide: Slide }} loadError\r\n * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented\r\n * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange\r\n * @prop {{ content: Content }} contentLazyLoad can be default prevented\r\n * @prop {{ content: Content }} contentAppend can be default prevented\r\n * @prop {{ content: Content }} contentActivate can be default prevented\r\n * @prop {{ content: Content }} contentDeactivate can be default prevented\r\n * @prop {{ content: Content }} contentRemove can be default prevented\r\n * @prop {{ content: Content }} contentDestroy can be default prevented\r\n *\r\n *\r\n * undocumented\r\n *\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented\r\n *\r\n * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented\r\n * @prop {{ x: number; dragging: boolean }} moveMainScroll\r\n * @prop {{ slide: Slide }} firstZoomPan\r\n * @prop {{ slide: Slide | undefined, data: SlideData, index: number }} gettingData\r\n * @prop {undefined} beforeResize\r\n * @prop {undefined} resize\r\n * @prop {undefined} viewportSize\r\n * @prop {undefined} updateScrollOffset\r\n * @prop {{ slide: Slide }} slideInit\r\n * @prop {{ slide: Slide }} afterSetContent\r\n * @prop {{ slide: Slide }} slideLoad\r\n * @prop {{ slide: Slide }} appendHeavy can be default prevented\r\n * @prop {{ slide: Slide }} appendHeavyContent\r\n * @prop {{ slide: Slide }} slideActivate\r\n * @prop {{ slide: Slide }} slideDeactivate\r\n * @prop {{ slide: Slide }} slideDestroy\r\n * @prop {{ destZoomLevel: number, centerPoint: Point | undefined, transitionDuration: number | false | undefined }} beforeZoomTo\r\n * @prop {{ slide: Slide }} zoomPanUpdate\r\n * @prop {{ slide: Slide }} initialZoomPan\r\n * @prop {{ slide: Slide }} calcSlideSize\r\n * @prop {undefined} resolutionChanged\r\n * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented\r\n * @prop {{ content: Content }} contentAppendImage can be default prevented\r\n * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented\r\n * @prop {undefined} lazyLoad\r\n * @prop {{ slide: Slide }} calcBounds\r\n * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate\r\n *\r\n *\r\n * legacy\r\n *\r\n * @prop {undefined} init\r\n * @prop {undefined} initialZoomIn\r\n * @prop {undefined} initialZoomOut\r\n * @prop {undefined} initialZoomInEnd\r\n * @prop {undefined} initialZoomOutEnd\r\n * @prop {{ dataSource: DataSource | undefined, numItems: number }} numItems\r\n * @prop {{ itemData: SlideData; index: number }} itemData\r\n * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds\r\n */\r\n\r\n/**\r\n * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/\r\n *\r\n * @prop {(numItems: number, dataSource: DataSource | undefined) => number} numItems\r\n * Modify the total amount of slides. Example on Data sources page.\r\n * https://photoswipe.com/filters/#numitems\r\n *\r\n * @prop {(itemData: SlideData, index: number) => SlideData} itemData\r\n * Modify slide item data. Example on Data sources page.\r\n * https://photoswipe.com/filters/#itemdata\r\n *\r\n * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData\r\n * Modify item data when it's parsed from DOM element. Example on Data sources page.\r\n * https://photoswipe.com/filters/#domitemdata\r\n *\r\n * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex\r\n * Modify clicked gallery item index.\r\n * https://photoswipe.com/filters/#clickedindex\r\n *\r\n * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc\r\n * Modify placeholder image source.\r\n * https://photoswipe.com/filters/#placeholdersrc\r\n *\r\n * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading\r\n * Modify if the content is currently loading.\r\n * https://photoswipe.com/filters/#iscontentloading\r\n *\r\n * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable\r\n * Modify if the content can be zoomed.\r\n * https://photoswipe.com/filters/#iscontentzoomable\r\n *\r\n * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder\r\n * Modify if the placeholder should be used for the content.\r\n * https://photoswipe.com/filters/#usecontentplaceholder\r\n *\r\n * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder\r\n * Modify if the placeholder should be kept after the content is loaded.\r\n * https://photoswipe.com/filters/#iskeepingplaceholder\r\n *\r\n *\r\n * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement\r\n * Modify an element when the content has error state (for example, if image cannot be loaded).\r\n * https://photoswipe.com/filters/#contenterrorelement\r\n *\r\n * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement\r\n * Modify a UI element that's being created.\r\n * https://photoswipe.com/filters/#uielement\r\n *\r\n * @prop {(thumbnail: HTMLElement | null | undefined, itemData: SlideData, index: number) => HTMLElement} thumbEl\r\n * Modify the thumbnail element from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbel\r\n *\r\n * @prop {(thumbBounds: Bounds | undefined, itemData: SlideData, index: number) => Bounds} thumbBounds\r\n * Modify the thumbnail bounds from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbbounds\r\n *\r\n * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth\r\n *\r\n * @prop {(preventPointerEvent: boolean, event: PointerEvent, pointerType: string) => boolean} preventPointerEvent\r\n *\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeFiltersMap} T\r\n * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {(event: AugmentedEvent<T>) => void} EventCallback\r\n */\r\n\r\n/**\r\n * Base PhotoSwipe event object\r\n *\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n */\r\nclass PhotoSwipeEvent {\r\n  /**\r\n   * @param {T} type\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   */\r\n  constructor(type, details) {\r\n    this.type = type;\r\n    this.defaultPrevented = false;\r\n    if (details) {\r\n      Object.assign(this, details);\r\n    }\r\n  }\r\n\r\n  preventDefault() {\r\n    this.defaultPrevented = true;\r\n  }\r\n}\r\n\r\n/**\r\n * PhotoSwipe base class that can listen and dispatch for events.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js\r\n */\r\nclass Eventable {\r\n  constructor() {\r\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}\r\n     */\r\n    this._listeners = {};\r\n\r\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}\r\n     */\r\n    this._filters = {};\r\n\r\n    /** @type {PhotoSwipe | undefined} */\r\n    this.pswp = undefined;\r\n\r\n    /** @type {PhotoSwipeOptions | undefined} */\r\n    this.options = undefined;\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   * @param {number} priority\r\n   */\r\n  addFilter(name, fn, priority = 100) {\r\n    if (!this._filters[name]) {\r\n      this._filters[name] = [];\r\n    }\r\n\r\n    this._filters[name]?.push({ fn, priority });\r\n    this._filters[name]?.sort((f1, f2) => f1.priority - f2.priority);\r\n\r\n    this.pswp?.addFilter(name, fn, priority);\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   */\r\n  removeFilter(name, fn) {\r\n    if (this._filters[name]) {\r\n      // @ts-expect-error\r\n      this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));\r\n    }\r\n\r\n    if (this.pswp) {\r\n      this.pswp.removeFilter(name, fn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args\r\n   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}\r\n   */\r\n  applyFilters(name, ...args) {\r\n    this._filters[name]?.forEach((filter) => {\r\n      // @ts-expect-error\r\n      args[0] = filter.fn.apply(this, args);\r\n    });\r\n    return args[0];\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\r\n  on(name, fn) {\r\n    if (!this._listeners[name]) {\r\n      this._listeners[name] = [];\r\n    }\r\n    this._listeners[name]?.push(fn);\r\n\r\n    // When binding events to lightbox,\r\n    // also bind events to PhotoSwipe Core,\r\n    // if it's open.\r\n    this.pswp?.on(name, fn);\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\r\n  off(name, fn) {\r\n    if (this._listeners[name]) {\r\n      // @ts-expect-error\r\n      this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));\r\n    }\r\n\r\n    this.pswp?.off(name, fn);\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   * @returns {AugmentedEvent<T>}\r\n   */\r\n  dispatch(name, details) {\r\n    if (this.pswp) {\r\n      return this.pswp.dispatch(name, details);\r\n    }\r\n\r\n    const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent(name, details));\r\n\r\n    this._listeners[name]?.forEach((listener) => {\r\n      listener.call(this, event);\r\n    });\r\n\r\n    return event;\r\n  }\r\n}\r\n\r\nexport default Eventable;\r\n","import { createElement, setWidthHeight, toTransformString } from '../util/util.js';\r\n\r\nclass Placeholder {\r\n  /**\r\n   * @param {string | false} imageSrc\r\n   * @param {HTMLElement} container\r\n   */\r\n  constructor(imageSrc, container) {\r\n    // Create placeholder\r\n    // (stretched thumbnail or simple div behind the main image)\r\n    /** @type {HTMLImageElement | HTMLDivElement | null} */\r\n    this.element = createElement(\r\n      'pswp__img pswp__img--placeholder',\r\n      imageSrc ? 'img' : 'div',\r\n      container\r\n    );\r\n\r\n    if (imageSrc) {\r\n      const imgEl = /** @type {HTMLImageElement} */ (this.element);\r\n      imgEl.decoding = 'async';\r\n      imgEl.alt = '';\r\n      imgEl.src = imageSrc;\r\n      imgEl.setAttribute('role', 'presentation');\r\n    }\r\n\r\n    this.element.setAttribute('aria-hidden', 'true');\r\n  }\r\n\r\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\r\n  setDisplayedSize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.element.tagName === 'IMG') {\r\n      // Use transform scale() to modify img placeholder size\r\n      // (instead of changing width/height directly).\r\n      // This helps with performance, specifically in iOS15 Safari.\r\n      setWidthHeight(this.element, 250, 'auto');\r\n      this.element.style.transformOrigin = '0 0';\r\n      this.element.style.transform = toTransformString(0, 0, width / 250);\r\n    } else {\r\n      setWidthHeight(this.element, width, height);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    if (this.element?.parentNode) {\r\n      this.element.remove();\r\n    }\r\n    this.element = null;\r\n  }\r\n}\r\n\r\nexport default Placeholder;\r\n","import { createElement, isSafari, LOAD_STATE, setWidthHeight } from '../util/util.js';\r\nimport Placeholder from './placeholder.js';\r\n\r\n/** @typedef {import('./slide.js').default} Slide */\r\n/** @typedef {import('./slide.js').SlideData} SlideData */\r\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\r\n/** @typedef {import('../util/util.js').LoadState} LoadState */\r\n\r\nclass Content {\r\n  /**\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n   * @param {number} index\r\n   */\r\n  constructor(itemData, instance, index) {\r\n    this.instance = instance;\r\n    this.data = itemData;\r\n    this.index = index;\r\n\r\n    /** @type {HTMLImageElement | HTMLDivElement | undefined} */\r\n    this.element = undefined;\r\n    /** @type {Placeholder | undefined} */\r\n    this.placeholder = undefined;\r\n    /** @type {Slide | undefined} */\r\n    this.slide = undefined;\r\n\r\n    this.displayedImageWidth = 0;\r\n    this.displayedImageHeight = 0;\r\n\r\n    this.width = Number(this.data.w) || Number(this.data.width) || 0;\r\n    this.height = Number(this.data.h) || Number(this.data.height) || 0;\r\n\r\n    this.isAttached = false;\r\n    this.hasSlide = false;\r\n    this.isDecoding = false;\r\n    /** @type {LoadState} */\r\n    this.state = LOAD_STATE.IDLE;\r\n\r\n    if (this.data.type) {\r\n      this.type = this.data.type;\r\n    } else if (this.data.src) {\r\n      this.type = 'image';\r\n    } else {\r\n      this.type = 'html';\r\n    }\r\n\r\n    this.instance.dispatch('contentInit', { content: this });\r\n  }\r\n\r\n  removePlaceholder() {\r\n    if (this.placeholder && !this.keepPlaceholder()) {\r\n      // With delay, as image might be loaded, but not rendered\r\n      setTimeout(() => {\r\n        if (this.placeholder) {\r\n          this.placeholder.destroy();\r\n          this.placeholder = undefined;\r\n        }\r\n      }, 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload content\r\n   *\r\n   * @param {boolean} isLazy\r\n   * @param {boolean} [reload]\r\n   */\r\n  load(isLazy, reload) {\r\n    if (this.slide && this.usePlaceholder()) {\r\n      if (!this.placeholder) {\r\n        const placeholderSrc = this.instance.applyFilters(\r\n          'placeholderSrc',\r\n          // use  image-based placeholder only for the first slide,\r\n          // as rendering (even small stretched thumbnail) is an expensive operation\r\n          (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,\r\n          this\r\n        );\r\n        this.placeholder = new Placeholder(\r\n          placeholderSrc,\r\n          this.slide.container\r\n        );\r\n      } else {\r\n        const placeholderEl = this.placeholder.element;\r\n        // Add placeholder to DOM if it was already created\r\n        if (placeholderEl && !placeholderEl.parentElement) {\r\n          this.slide.container.prepend(placeholderEl);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.element && !reload) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.isImageContent()) {\r\n      this.element = createElement('pswp__img', 'img');\r\n      // Start loading only after width is defined, as sizes might depend on it.\r\n      // Due to Safari feature, we must define sizes before srcset.\r\n      if (this.displayedImageWidth) {\r\n        this.loadImage(isLazy);\r\n      }\r\n    } else {\r\n      this.element = createElement('pswp__content', 'div');\r\n      this.element.innerHTML = this.data.html || '';\r\n    }\r\n\r\n    if (reload && this.slide) {\r\n      this.slide.updateContentSize(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload image\r\n   *\r\n   * @param {boolean} isLazy\r\n   */\r\n  loadImage(isLazy) {\r\n    if (!this.isImageContent()\r\n      || !this.element\r\n      || this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const imageElement = /** @type HTMLImageElement */ (this.element);\r\n\r\n    this.updateSrcsetSizes();\r\n\r\n    if (this.data.srcset) {\r\n      imageElement.srcset = this.data.srcset;\r\n    }\r\n\r\n    imageElement.src = this.data.src ?? '';\r\n    imageElement.alt = this.data.alt ?? '';\r\n\r\n    this.state = LOAD_STATE.LOADING;\r\n\r\n    if (imageElement.complete) {\r\n      this.onLoaded();\r\n    } else {\r\n      imageElement.onload = () => {\r\n        this.onLoaded();\r\n      };\r\n\r\n      imageElement.onerror = () => {\r\n        this.onError();\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign slide to content\r\n   *\r\n   * @param {Slide} slide\r\n   */\r\n  setSlide(slide) {\r\n    this.slide = slide;\r\n    this.hasSlide = true;\r\n    this.instance = slide.pswp;\r\n\r\n    // todo: do we need to unset slide?\r\n  }\r\n\r\n  /**\r\n   * Content load success handler\r\n   */\r\n  onLoaded() {\r\n    this.state = LOAD_STATE.LOADED;\r\n\r\n    if (this.slide && this.element) {\r\n      this.instance.dispatch('loadComplete', { slide: this.slide, content: this });\r\n\r\n      // if content is reloaded\r\n      if (this.slide.isActive\r\n          && this.slide.heavyAppended\r\n          && !this.element.parentNode) {\r\n        this.append();\r\n        this.slide.updateContentSize(true);\r\n      }\r\n\r\n      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {\r\n        this.removePlaceholder();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Content load error handler\r\n   */\r\n  onError() {\r\n    this.state = LOAD_STATE.ERROR;\r\n\r\n    if (this.slide) {\r\n      this.displayError();\r\n      this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });\r\n      this.instance.dispatch('loadError', { slide: this.slide, content: this });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {Boolean} If the content is currently loading\r\n   */\r\n  isLoading() {\r\n    return this.instance.applyFilters(\r\n      'isContentLoading',\r\n      this.state === LOAD_STATE.LOADING,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @returns {Boolean} If the content is in error state\r\n   */\r\n  isError() {\r\n    return this.state === LOAD_STATE.ERROR;\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If the content is image\r\n   */\r\n  isImageContent() {\r\n    return this.type === 'image';\r\n  }\r\n\r\n  /**\r\n   * Update content size\r\n   *\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   */\r\n  setDisplayedSize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.placeholder) {\r\n      this.placeholder.setDisplayedSize(width, height);\r\n    }\r\n\r\n    if (this.instance.dispatch(\r\n      'contentResize',\r\n      { content: this, width, height }).defaultPrevented\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    setWidthHeight(this.element, width, height);\r\n\r\n    if (this.isImageContent() && !this.isError()) {\r\n      const isInitialSizeUpdate = (!this.displayedImageWidth && width);\r\n\r\n      this.displayedImageWidth = width;\r\n      this.displayedImageHeight = height;\r\n\r\n      if (isInitialSizeUpdate) {\r\n        this.loadImage(false);\r\n      } else {\r\n        this.updateSrcsetSizes();\r\n      }\r\n\r\n      if (this.slide) {\r\n        this.instance.dispatch(\r\n          'imageSizeChange',\r\n          { slide: this.slide, width, height, content: this }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If the content can be zoomed\r\n   */\r\n  isZoomable() {\r\n    return this.instance.applyFilters(\r\n      'isContentZoomable',\r\n      this.isImageContent() && (this.state !== LOAD_STATE.ERROR),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update image srcset sizes attribute based on width and height\r\n   */\r\n  updateSrcsetSizes() {\r\n    // Handle srcset sizes attribute.\r\n    //\r\n    // Never lower quality, if it was increased previously.\r\n    // Chrome does this automatically, Firefox and Safari do not,\r\n    // so we store largest used size in dataset.\r\n    if (!this.isImageContent() || !this.element || !this.data.srcset) {\r\n      return;\r\n    }\r\n\r\n    const image = /** @type HTMLImageElement */ (this.element);\r\n    const sizesWidth = this.instance.applyFilters(\r\n      'srcsetSizesWidth',\r\n      this.displayedImageWidth,\r\n      this\r\n    );\r\n\r\n    if (\r\n      !image.dataset.largestUsedSize\r\n      || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)\r\n    ) {\r\n      image.sizes = sizesWidth + 'px';\r\n      image.dataset.largestUsedSize = String(sizesWidth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If content should use a placeholder (from msrc by default)\r\n   */\r\n  usePlaceholder() {\r\n    return this.instance.applyFilters(\r\n      'useContentPlaceholder',\r\n      this.isImageContent(),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Preload content with lazy-loading param\r\n   */\r\n  lazyLoad() {\r\n    if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.load(true);\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If placeholder should be kept after content is loaded\r\n   */\r\n  keepPlaceholder() {\r\n    return this.instance.applyFilters(\r\n      'isKeepingPlaceholder',\r\n      this.isLoading(),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy the content\r\n   */\r\n  destroy() {\r\n    this.hasSlide = false;\r\n    this.slide = undefined;\r\n\r\n    if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.remove();\r\n\r\n    if (this.placeholder) {\r\n      this.placeholder.destroy();\r\n      this.placeholder = undefined;\r\n    }\r\n\r\n    if (this.isImageContent() && this.element) {\r\n      this.element.onload = null;\r\n      this.element.onerror = null;\r\n      this.element = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Display error message\r\n   */\r\n  displayError() {\r\n    if (this.slide) {\r\n      let errorMsgEl = createElement('pswp__error-msg', 'div');\r\n      errorMsgEl.innerText = this.instance.options?.errorMsg ?? '';\r\n      errorMsgEl = /** @type {HTMLDivElement} */ (this.instance.applyFilters(\r\n        'contentErrorElement',\r\n        errorMsgEl,\r\n        this\r\n      ));\r\n      this.element = createElement('pswp__content pswp__error-msg-container', 'div');\r\n      this.element.appendChild(errorMsgEl);\r\n      this.slide.container.innerText = '';\r\n      this.slide.container.appendChild(this.element);\r\n      this.slide.updateContentSize(true);\r\n      this.removePlaceholder();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the content\r\n   */\r\n  append() {\r\n    if (this.isAttached || !this.element) {\r\n      return;\r\n    }\r\n\r\n    this.isAttached = true;\r\n\r\n    if (this.state === LOAD_STATE.ERROR) {\r\n      this.displayError();\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const supportsDecode = ('decode' in this.element);\r\n\r\n    if (this.isImageContent()) {\r\n      // Use decode() on nearby slides\r\n      //\r\n      // Nearby slide images are in DOM and not hidden via display:none.\r\n      // However, they are placed offscreen (to the left and right side).\r\n      //\r\n      // Some browsers do not composite the image until it's actually visible,\r\n      // using decode() helps.\r\n      //\r\n      // You might ask \"why dont you just decode() and then append all images\",\r\n      // that's because I want to show image before it's fully loaded,\r\n      // as browser can render parts of image while it is loading.\r\n      // We do not do this in Safari due to partial loading bug.\r\n      if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {\r\n        this.isDecoding = true;\r\n        // purposefully using finally instead of then,\r\n        // as if srcset sizes changes dynamically - it may cause decode error\r\n        /** @type {HTMLImageElement} */\r\n        (this.element).decode().catch(() => {}).finally(() => {\r\n          this.isDecoding = false;\r\n          this.appendImage();\r\n        });\r\n      } else {\r\n        this.appendImage();\r\n      }\r\n    } else if (this.slide && !this.element.parentNode) {\r\n      this.slide.container.appendChild(this.element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate the slide,\r\n   * active slide is generally the current one,\r\n   * meaning the user can see it.\r\n   */\r\n  activate() {\r\n    if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented\r\n      || !this.slide) {\r\n      return;\r\n    }\r\n\r\n    if (this.isImageContent() && this.isDecoding && !isSafari()) {\r\n      // add image to slide when it becomes active,\r\n      // even if it's not finished decoding\r\n      this.appendImage();\r\n    } else if (this.isError()) {\r\n      this.load(false, true); // try to reload\r\n    }\r\n\r\n    if (this.slide.holderElement) {\r\n      this.slide.holderElement.setAttribute('aria-hidden', 'false');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deactivate the content\r\n   */\r\n  deactivate() {\r\n    this.instance.dispatch('contentDeactivate', { content: this });\r\n    if (this.slide && this.slide.holderElement) {\r\n      this.slide.holderElement.setAttribute('aria-hidden', 'true');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Remove the content from DOM\r\n   */\r\n  remove() {\r\n    this.isAttached = false;\r\n\r\n    if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.element && this.element.parentNode) {\r\n      this.element.remove();\r\n    }\r\n\r\n    if (this.placeholder && this.placeholder.element) {\r\n      this.placeholder.element.remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the image content to slide container\r\n   */\r\n  appendImage() {\r\n    if (!this.isAttached) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    // ensure that element exists and is not already appended\r\n    if (this.slide && this.element && !this.element.parentNode) {\r\n      this.slide.container.appendChild(this.element);\r\n    }\r\n\r\n    if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {\r\n      this.removePlaceholder();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Content;\r\n","/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\r\n\r\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {PhotoSwipeBase} pswp\r\n * @returns {Point}\r\n */\r\nexport function getViewportSize(options, pswp) {\r\n  if (options.getViewportSizeFn) {\r\n    const newViewportSize = options.getViewportSizeFn(options, pswp);\r\n    if (newViewportSize) {\r\n      return newViewportSize;\r\n    }\r\n  }\r\n\r\n  return {\r\n    x: document.documentElement.clientWidth,\r\n\r\n    // TODO: height on mobile is very incosistent due to toolbar\r\n    // find a way to improve this\r\n    //\r\n    // document.documentElement.clientHeight - doesn't seem to work well\r\n    y: window.innerHeight\r\n  };\r\n}\r\n\r\n/**\r\n * Parses padding option.\r\n * Supported formats:\r\n *\r\n * // Object\r\n * padding: {\r\n *  top: 0,\r\n *  bottom: 0,\r\n *  left: 0,\r\n *  right: 0\r\n * }\r\n *\r\n * // A function that returns the object\r\n * paddingFn: (viewportSize, itemData, index) => {\r\n *  return {\r\n *    top: 0,\r\n *    bottom: 0,\r\n *    left: 0,\r\n *    right: 0\r\n *  };\r\n * }\r\n *\r\n * // Legacy variant\r\n * paddingLeft: 0,\r\n * paddingRight: 0,\r\n * paddingTop: 0,\r\n * paddingBottom: 0,\r\n *\r\n * @param {'left' | 'top' | 'bottom' | 'right'} prop\r\n * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n * @param {Point} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {number} index Slide index\r\n * @returns {number}\r\n */\r\nexport function parsePaddingOption(prop, options, viewportSize, itemData, index) {\r\n  let paddingValue = 0;\r\n\r\n  if (options.paddingFn) {\r\n    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];\r\n  } else if (options.padding) {\r\n    paddingValue = options.padding[prop];\r\n  } else {\r\n    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);\r\n    // @ts-expect-error\r\n    if (options[legacyPropName]) {\r\n      // @ts-expect-error\r\n      paddingValue = options[legacyPropName];\r\n    }\r\n  }\r\n\r\n  return Number(paddingValue) || 0;\r\n}\r\n\r\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {Point} viewportSize\r\n * @param {SlideData} itemData\r\n * @param {number} index\r\n * @returns {Point}\r\n */\r\nexport function getPanAreaSize(options, viewportSize, itemData, index) {\r\n  return {\r\n    x: viewportSize.x\r\n      - parsePaddingOption('left', options, viewportSize, itemData, index)\r\n      - parsePaddingOption('right', options, viewportSize, itemData, index),\r\n    y: viewportSize.y\r\n      - parsePaddingOption('top', options, viewportSize, itemData, index)\r\n      - parsePaddingOption('bottom', options, viewportSize, itemData, index)\r\n  };\r\n}\r\n","const MAX_IMAGE_WIDTH = 4000;\r\n\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\r\n\r\n/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */\r\n\r\n/**\r\n * Calculates zoom levels for specific slide.\r\n * Depends on viewport size and image size.\r\n */\r\nclass ZoomLevel {\r\n  /**\r\n   * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {number} index Slide index\r\n   * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet\r\n   */\r\n  constructor(options, itemData, index, pswp) {\r\n    this.pswp = pswp;\r\n    this.options = options;\r\n    this.itemData = itemData;\r\n    this.index = index;\r\n    /** @type { Point | null } */\r\n    this.panAreaSize = null;\r\n    /** @type { Point | null } */\r\n    this.elementSize = null;\r\n    this.fit = 1;\r\n    this.fill = 1;\r\n    this.vFill = 1;\r\n    this.initial = 1;\r\n    this.secondary = 1;\r\n    this.max = 1;\r\n    this.min = 1;\r\n  }\r\n\r\n  /**\r\n   * Calculate initial, secondary and maximum zoom level for the specified slide.\r\n   *\r\n   * It should be called when either image or viewport size changes.\r\n   *\r\n   * @param {number} maxWidth\r\n   * @param {number} maxHeight\r\n   * @param {Point} panAreaSize\r\n   */\r\n  update(maxWidth, maxHeight, panAreaSize) {\r\n    /** @type {Point} */\r\n    const elementSize = { x: maxWidth, y: maxHeight };\r\n    this.elementSize = elementSize;\r\n    this.panAreaSize = panAreaSize;\r\n\r\n    const hRatio = panAreaSize.x / elementSize.x;\r\n    const vRatio = panAreaSize.y / elementSize.y;\r\n\r\n    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);\r\n    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);\r\n\r\n    // zoom.vFill defines zoom level of the image\r\n    // when it has 100% of viewport vertical space (height)\r\n    this.vFill = Math.min(1, vRatio);\r\n\r\n    this.initial = this._getInitial();\r\n    this.secondary = this._getSecondary();\r\n    this.max = Math.max(\r\n      this.initial,\r\n      this.secondary,\r\n      this._getMax()\r\n    );\r\n\r\n    this.min = Math.min(\r\n      this.fit,\r\n      this.initial,\r\n      this.secondary\r\n    );\r\n\r\n    if (this.pswp) {\r\n      this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses user-defined zoom option.\r\n   *\r\n   * @private\r\n   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)\r\n   * @returns { number | undefined }\r\n   */\r\n  _parseZoomLevelOption(optionPrefix) {\r\n    const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (\r\n      optionPrefix + 'ZoomLevel'\r\n    );\r\n    const optionValue = this.options[optionName];\r\n\r\n    if (!optionValue) {\r\n      return;\r\n    }\r\n\r\n    if (typeof optionValue === 'function') {\r\n      return optionValue(this);\r\n    }\r\n\r\n    if (optionValue === 'fill') {\r\n      return this.fill;\r\n    }\r\n\r\n    if (optionValue === 'fit') {\r\n      return this.fit;\r\n    }\r\n\r\n    return Number(optionValue);\r\n  }\r\n\r\n  /**\r\n   * Get zoom level to which image will be zoomed after double-tap gesture,\r\n   * or when user clicks on zoom icon,\r\n   * or mouse-click on image itself.\r\n   * If you return 1 image will be zoomed to its original size.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getSecondary() {\r\n    let currZoomLevel = this._parseZoomLevelOption('secondary');\r\n\r\n    if (currZoomLevel) {\r\n      return currZoomLevel;\r\n    }\r\n\r\n    // 3x of \"fit\" state, but not larger than original\r\n    currZoomLevel = Math.min(1, this.fit * 3);\r\n\r\n    if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {\r\n      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;\r\n    }\r\n\r\n    return currZoomLevel;\r\n  }\r\n\r\n  /**\r\n   * Get initial image zoom level.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getInitial() {\r\n    return this._parseZoomLevelOption('initial') || this.fit;\r\n  }\r\n\r\n  /**\r\n   * Maximum zoom level when user zooms\r\n   * via zoom/pinch gesture,\r\n   * via cmd/ctrl-wheel or via trackpad.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getMax() {\r\n    // max zoom level is x4 from \"fit state\",\r\n    // used for zoom gesture and ctrl/trackpad zoom\r\n    return this._parseZoomLevelOption('max') || Math.max(1, this.fit * 4);\r\n  }\r\n}\r\n\r\nexport default ZoomLevel;\r\n","import { getViewportSize, getPanAreaSize } from '../util/viewport-size.js';\r\nimport ZoomLevel from './zoom-level.js';\r\n\r\n/** @typedef {import('./content.js').default} Content */\r\n/** @typedef {import('./slide.js').default} Slide */\r\n/** @typedef {import('./slide.js').SlideData} SlideData */\r\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n\r\nconst MIN_SLIDES_TO_CACHE = 5;\r\n\r\n/**\r\n * Lazy-load an image\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n * @param {number} index\r\n * @returns {Content} Image that is being decoded or false.\r\n */\r\nexport function lazyLoadData(itemData, instance, index) {\r\n  const content = instance.createContentFromData(itemData, index);\r\n  /** @type {ZoomLevel | undefined} */\r\n  let zoomLevel;\r\n\r\n  const { options } = instance;\r\n\r\n  // We need to know dimensions of the image to preload it,\r\n  // as it might use srcset, and we need to define sizes\r\n  if (options) {\r\n    zoomLevel = new ZoomLevel(options, itemData, -1);\r\n\r\n    let viewportSize;\r\n    if (instance.pswp) {\r\n      viewportSize = instance.pswp.viewportSize;\r\n    } else {\r\n      viewportSize = getViewportSize(options, instance);\r\n    }\r\n\r\n    const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);\r\n    zoomLevel.update(content.width, content.height, panAreaSize);\r\n  }\r\n\r\n  content.lazyLoad();\r\n\r\n  if (zoomLevel) {\r\n    content.setDisplayedSize(\r\n      Math.ceil(content.width * zoomLevel.initial),\r\n      Math.ceil(content.height * zoomLevel.initial)\r\n    );\r\n  }\r\n\r\n  return content;\r\n}\r\n\r\n\r\n/**\r\n * Lazy-loads specific slide.\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * By default, it loads image based on viewport size and initial zoom level.\r\n *\r\n * @param {number} index Slide index\r\n * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox eventable instance\r\n * @returns {Content | undefined}\r\n */\r\nexport function lazyLoadSlide(index, instance) {\r\n  const itemData = instance.getItemData(index);\r\n\r\n  if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {\r\n    return;\r\n  }\r\n\r\n  return lazyLoadData(itemData, instance, index);\r\n}\r\n\r\nclass ContentLoader {\r\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\r\n  constructor(pswp) {\r\n    this.pswp = pswp;\r\n    // Total amount of cached images\r\n    this.limit = Math.max(\r\n      pswp.options.preload[0] + pswp.options.preload[1] + 1,\r\n      MIN_SLIDES_TO_CACHE\r\n    );\r\n    /** @type {Content[]} */\r\n    this._cachedItems = [];\r\n  }\r\n\r\n  /**\r\n   * Lazy load nearby slides based on `preload` option.\r\n   *\r\n   * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.\r\n   */\r\n  updateLazy(diff) {\r\n    const { pswp } = this;\r\n\r\n    if (pswp.dispatch('lazyLoad').defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    const { preload } = pswp.options;\r\n    const isForward = diff === undefined ? true : (diff >= 0);\r\n    let i;\r\n\r\n    // preload[1] - num items to preload in forward direction\r\n    for (i = 0; i <= preload[1]; i++) {\r\n      this.loadSlideByIndex(pswp.currIndex + (isForward ? i : (-i)));\r\n    }\r\n\r\n    // preload[0] - num items to preload in backward direction\r\n    for (i = 1; i <= preload[0]; i++) {\r\n      this.loadSlideByIndex(pswp.currIndex + (isForward ? (-i) : i));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} initialIndex\r\n   */\r\n  loadSlideByIndex(initialIndex) {\r\n    const index = this.pswp.getLoopedIndex(initialIndex);\r\n    // try to get cached content\r\n    let content = this.getContentByIndex(index);\r\n    if (!content) {\r\n      // no cached content, so try to load from scratch:\r\n      content = lazyLoadSlide(index, this.pswp);\r\n      // if content can be loaded, add it to cache:\r\n      if (content) {\r\n        this.addToCache(content);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Slide} slide\r\n   * @returns {Content}\r\n   */\r\n  getContentBySlide(slide) {\r\n    let content = this.getContentByIndex(slide.index);\r\n    if (!content) {\r\n      // create content if not found in cache\r\n      content = this.pswp.createContentFromData(slide.data, slide.index);\r\n      this.addToCache(content);\r\n    }\r\n\r\n    // assign slide to content\r\n    content.setSlide(slide);\r\n\r\n    return content;\r\n  }\r\n\r\n  /**\r\n   * @param {Content} content\r\n   */\r\n  addToCache(content) {\r\n    // move to the end of array\r\n    this.removeByIndex(content.index);\r\n    this._cachedItems.push(content);\r\n\r\n    if (this._cachedItems.length > this.limit) {\r\n      // Destroy the first content that's not attached\r\n      const indexToRemove = this._cachedItems.findIndex((item) => {\r\n        return !item.isAttached && !item.hasSlide;\r\n      });\r\n      if (indexToRemove !== -1) {\r\n        const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];\r\n        removedItem.destroy();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an image from cache, does not destroy() it, just removes.\r\n   *\r\n   * @param {number} index\r\n   */\r\n  removeByIndex(index) {\r\n    const indexToRemove = this._cachedItems.findIndex(item => item.index === index);\r\n    if (indexToRemove !== -1) {\r\n      this._cachedItems.splice(indexToRemove, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} index\r\n   * @returns {Content | undefined}\r\n   */\r\n  getContentByIndex(index) {\r\n    return this._cachedItems.find(content => content.index === index);\r\n  }\r\n\r\n  destroy() {\r\n    this._cachedItems.forEach(content => content.destroy());\r\n    this._cachedItems = [];\r\n  }\r\n}\r\n\r\nexport default ContentLoader;\r\n","import Eventable from './eventable.js';\r\nimport { getElementsFromOption } from '../util/util.js';\r\nimport Content from '../slide/content.js';\r\nimport { lazyLoadData } from '../slide/loader.js';\r\n\r\n/** @typedef {import(\"../photoswipe.js\").default} PhotoSwipe */\r\n/** @typedef {import(\"../slide/slide.js\").SlideData} SlideData */\r\n\r\n/**\r\n * PhotoSwipe base class that can retrieve data about every slide.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox\r\n */\r\nclass PhotoSwipeBase extends Eventable {\r\n  /**\r\n   * Get total number of slides\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getNumItems() {\r\n    let numItems = 0;\r\n    const dataSource = this.options?.dataSource;\r\n\r\n    if (dataSource && 'length' in dataSource) {\r\n      // may be an array or just object with length property\r\n      numItems = dataSource.length;\r\n    } else if (dataSource && 'gallery' in dataSource) {\r\n      // query DOM elements\r\n      if (!dataSource.items) {\r\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\r\n      }\r\n\r\n      if (dataSource.items) {\r\n        numItems = dataSource.items.length;\r\n      }\r\n    }\r\n\r\n    // legacy event, before filters were introduced\r\n    const event = this.dispatch('numItems', {\r\n      dataSource,\r\n      numItems\r\n    });\r\n    return this.applyFilters('numItems', event.numItems, dataSource);\r\n  }\r\n\r\n  /**\r\n   * @param {SlideData} slideData\r\n   * @param {number} index\r\n   * @returns {Content}\r\n   */\r\n  createContentFromData(slideData, index) {\r\n    return new Content(slideData, this, index);\r\n  }\r\n\r\n  /**\r\n   * Get item data by index.\r\n   *\r\n   * \"item data\" should contain normalized information that PhotoSwipe needs to generate a slide.\r\n   * For example, it may contain properties like\r\n   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.\r\n   *\r\n   * @param {number} index\r\n   * @returns {SlideData}\r\n   */\r\n  getItemData(index) {\r\n    const dataSource = this.options?.dataSource;\r\n    /** @type {SlideData | HTMLElement} */\r\n    let dataSourceItem = {};\r\n    if (Array.isArray(dataSource)) {\r\n      // Datasource is an array of elements\r\n      dataSourceItem = dataSource[index];\r\n    } else if (dataSource && 'gallery' in dataSource) {\r\n      // dataSource has gallery property,\r\n      // thus it was created by Lightbox, based on\r\n      // gallery and children options\r\n\r\n      // query DOM elements\r\n      if (!dataSource.items) {\r\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\r\n      }\r\n\r\n      dataSourceItem = dataSource.items[index];\r\n    }\r\n\r\n    let itemData = dataSourceItem;\r\n\r\n    if (itemData instanceof Element) {\r\n      itemData = this._domElementToItemData(itemData);\r\n    }\r\n\r\n    // Dispatching the itemData event,\r\n    // it's a legacy verion before filters were introduced\r\n    const event = this.dispatch('itemData', {\r\n      itemData: itemData || {},\r\n      index\r\n    });\r\n\r\n    return this.applyFilters('itemData', event.itemData, index);\r\n  }\r\n\r\n  /**\r\n   * Get array of gallery DOM elements,\r\n   * based on childSelector and gallery element.\r\n   *\r\n   * @param {HTMLElement} galleryElement\r\n   * @returns {HTMLElement[]}\r\n   */\r\n  _getGalleryDOMElements(galleryElement) {\r\n    if (this.options?.children || this.options?.childSelector) {\r\n      return getElementsFromOption(\r\n        this.options.children,\r\n        this.options.childSelector,\r\n        galleryElement\r\n      ) || [];\r\n    }\r\n\r\n    return [galleryElement];\r\n  }\r\n\r\n  /**\r\n   * Converts DOM element to item data object.\r\n   *\r\n   * @param {HTMLElement} element DOM element\r\n   * @returns {SlideData}\r\n   */\r\n  _domElementToItemData(element) {\r\n    /** @type {SlideData} */\r\n    const itemData = {\r\n      element\r\n    };\r\n\r\n    const linkEl = /** @type {HTMLAnchorElement} */ (\r\n      element.tagName === 'A'\r\n        ? element\r\n        : element.querySelector('a')\r\n    );\r\n\r\n    if (linkEl) {\r\n      // src comes from data-pswp-src attribute,\r\n      // if it's empty link href is used\r\n      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;\r\n\r\n      if (linkEl.dataset.pswpSrcset) {\r\n        itemData.srcset = linkEl.dataset.pswpSrcset;\r\n      }\r\n\r\n      itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;\r\n      itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0;\r\n\r\n      // support legacy w & h properties\r\n      itemData.w = itemData.width;\r\n      itemData.h = itemData.height;\r\n\r\n      if (linkEl.dataset.pswpType) {\r\n        itemData.type = linkEl.dataset.pswpType;\r\n      }\r\n\r\n      const thumbnailEl = element.querySelector('img');\r\n\r\n      if (thumbnailEl) {\r\n        // msrc is URL to placeholder image that's displayed before large image is loaded\r\n        // by default it's displayed only for the first slide\r\n        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;\r\n        itemData.alt = thumbnailEl.getAttribute('alt') ?? '';\r\n      }\r\n\r\n      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {\r\n        itemData.thumbCropped = true;\r\n      }\r\n    }\r\n\r\n    return this.applyFilters('domItemData', itemData, element, linkEl);\r\n  }\r\n\r\n  /**\r\n   * Lazy-load by slide data\r\n   *\r\n   * @param {SlideData} itemData Data about the slide\r\n   * @param {number} index\r\n   * @returns {Content} Image that is being decoded or false.\r\n   */\r\n  lazyLoadData(itemData, index) {\r\n    return lazyLoadData(itemData, this, index);\r\n  }\r\n}\r\n\r\nexport default PhotoSwipeBase;\r\n","import {\r\n  specialKeyUsed,\r\n  getElementsFromOption,\r\n  isPswpClass\r\n} from '../util/util.js';\r\n\r\nimport PhotoSwipeBase from '../core/base.js';\r\nimport { lazyLoadSlide } from '../slide/loader.js';\r\n\r\n/**\r\n * @template T\r\n * @typedef {import('../types.js').Type<T>} Type<T>\r\n */\r\n\r\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\r\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import('../photoswipe.js').DataSource} DataSource */\r\n/** @typedef {import('../photoswipe.js').Point} Point */\r\n/** @typedef {import('../slide/content.js').default} Content */\r\n/** @typedef {import('../core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */\r\n/** @typedef {import('../core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {import('../core/eventable.js').EventCallback<T>} EventCallback<T>\r\n */\r\n\r\n/**\r\n * PhotoSwipe Lightbox\r\n *\r\n * - If user has unsupported browser it falls back to default browser action (just opens URL)\r\n * - Binds click event to links that should open PhotoSwipe\r\n * - parses DOM strcture for PhotoSwipe (retrieves large image URLs and sizes)\r\n * - Initializes PhotoSwipe\r\n *\r\n *\r\n * Loader options use the same object as PhotoSwipe, and supports such options:\r\n *\r\n * gallery - Element | Element[] | NodeList | string selector for the gallery element\r\n * children - Element | Element[] | NodeList | string selector for the gallery children\r\n *\r\n */\r\nclass PhotoSwipeLightbox extends PhotoSwipeBase {\r\n  /**\r\n   * @param {PhotoSwipeOptions} [options]\r\n   */\r\n  constructor(options) {\r\n    super();\r\n    /** @type {PhotoSwipeOptions} */\r\n    this.options = options || {};\r\n    this._uid = 0;\r\n    this.shouldOpen = false;\r\n    /**\r\n     * @private\r\n     * @type {Content | undefined}\r\n     */\r\n    this._preloadedContent = undefined;\r\n\r\n    this.onThumbnailsClick = this.onThumbnailsClick.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Initialize lightbox, should be called only once.\r\n   * It's not included in the main constructor, so you may bind events before it.\r\n   */\r\n  init() {\r\n    // Bind click events to each gallery\r\n    getElementsFromOption(this.options.gallery, this.options.gallerySelector)\r\n      .forEach((galleryElement) => {\r\n        galleryElement.addEventListener('click', this.onThumbnailsClick, false);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @param {MouseEvent} e\r\n   */\r\n  onThumbnailsClick(e) {\r\n    // Exit and allow default browser action if:\r\n    if (specialKeyUsed(e) // ... if clicked with a special key (ctrl/cmd...)\r\n        || window.pswp) { // ... if PhotoSwipe is already open\r\n      return;\r\n    }\r\n\r\n    // If both clientX and clientY are 0 or not defined,\r\n    // the event is likely triggered by keyboard,\r\n    // so we do not pass the initialPoint\r\n    //\r\n    // Note that some screen readers emulate the mouse position,\r\n    // so it's not the ideal way to detect them.\r\n    //\r\n    /** @type {Point | null} */\r\n    let initialPoint = { x: e.clientX, y: e.clientY };\r\n\r\n    if (!initialPoint.x && !initialPoint.y) {\r\n      initialPoint = null;\r\n    }\r\n\r\n    let clickedIndex = this.getClickedIndex(e);\r\n    clickedIndex = this.applyFilters('clickedIndex', clickedIndex, e, this);\r\n    /** @type {DataSource} */\r\n    const dataSource = {\r\n      gallery: /** @type {HTMLElement} */ (e.currentTarget)\r\n    };\r\n\r\n    if (clickedIndex >= 0) {\r\n      e.preventDefault();\r\n      this.loadAndOpen(clickedIndex, dataSource, initialPoint);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get index of gallery item that was clicked.\r\n   *\r\n   * @param {MouseEvent} e click event\r\n   * @returns {number}\r\n   */\r\n  getClickedIndex(e) {\r\n    // legacy option\r\n    if (this.options.getClickedIndexFn) {\r\n      return this.options.getClickedIndexFn.call(this, e);\r\n    }\r\n\r\n    const clickedTarget = /** @type {HTMLElement} */ (e.target);\r\n    const childElements = getElementsFromOption(\r\n      this.options.children,\r\n      this.options.childSelector,\r\n      /** @type {HTMLElement} */ (e.currentTarget)\r\n    );\r\n    const clickedChildIndex = childElements.findIndex(\r\n      child => child === clickedTarget || child.contains(clickedTarget)\r\n    );\r\n\r\n    if (clickedChildIndex !== -1) {\r\n      return clickedChildIndex;\r\n    } else if (this.options.children || this.options.childSelector) {\r\n      // click wasn't on a child element\r\n      return -1;\r\n    }\r\n\r\n    // There is only one item (which is the gallery)\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Load and open PhotoSwipe\r\n   *\r\n   * @param {number} index\r\n   * @param {DataSource} [dataSource]\r\n   * @param {Point | null} [initialPoint]\r\n   * @returns {boolean}\r\n   */\r\n  loadAndOpen(index, dataSource, initialPoint) {\r\n    // Check if the gallery is already open\r\n    if (window.pswp || !this.options) {\r\n      return false;\r\n    }\r\n\r\n    // Use the first gallery element if dataSource is not provided\r\n    if (!dataSource && this.options.gallery && this.options.children) {\r\n      const galleryElements = getElementsFromOption(this.options.gallery);\r\n      if (galleryElements[0]) {\r\n        dataSource = {\r\n          gallery: galleryElements[0]\r\n        };\r\n      }\r\n    }\r\n\r\n    // set initial index\r\n    this.options.index = index;\r\n\r\n    // define options for PhotoSwipe constructor\r\n    this.options.initialPointerPos = initialPoint;\r\n\r\n    this.shouldOpen = true;\r\n    this.preload(index, dataSource);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Load the main module and the slide content by index\r\n   *\r\n   * @param {number} index\r\n   * @param {DataSource} [dataSource]\r\n   */\r\n  preload(index, dataSource) {\r\n    const { options } = this;\r\n\r\n    if (dataSource) {\r\n      options.dataSource = dataSource;\r\n    }\r\n\r\n    // Add the main module\r\n    /** @type {Promise<Type<PhotoSwipe>>[]} */\r\n    const promiseArray = [];\r\n\r\n    const pswpModuleType = typeof options.pswpModule;\r\n    if (isPswpClass(options.pswpModule)) {\r\n      promiseArray.push(Promise.resolve(/** @type {Type<PhotoSwipe>} */ (options.pswpModule)));\r\n    } else if (pswpModuleType === 'string') {\r\n      throw new Error('pswpModule as string is no longer supported');\r\n    } else if (pswpModuleType === 'function') {\r\n      promiseArray.push(/** @type {() => Promise<Type<PhotoSwipe>>} */ (options.pswpModule)());\r\n    } else {\r\n      throw new Error('pswpModule is not valid');\r\n    }\r\n\r\n    // Add custom-defined promise, if any\r\n    if (typeof options.openPromise === 'function') {\r\n      // allow developers to perform some task before opening\r\n      promiseArray.push(options.openPromise());\r\n    }\r\n\r\n    if (options.preloadFirstSlide !== false && index >= 0) {\r\n      this._preloadedContent = lazyLoadSlide(index, this);\r\n    }\r\n\r\n    // Wait till all promises resolve and open PhotoSwipe\r\n    const uid = ++this._uid;\r\n    Promise.all(promiseArray).then((iterableModules) => {\r\n      if (this.shouldOpen) {\r\n        const mainModule = iterableModules[0];\r\n        this._openPhotoswipe(mainModule, uid);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} module\r\n   * @param {number} uid\r\n   */\r\n  _openPhotoswipe(module, uid) {\r\n    // Cancel opening if UID doesn't match the current one\r\n    // (if user clicked on another gallery item before current was loaded).\r\n    //\r\n    // Or if shouldOpen flag is set to false\r\n    // (developer may modify it via public API)\r\n    if (uid !== this._uid && this.shouldOpen) {\r\n      return;\r\n    }\r\n\r\n    this.shouldOpen = false;\r\n\r\n    // PhotoSwipe is already open\r\n    if (window.pswp) {\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * Pass data to PhotoSwipe and open init\r\n     *\r\n     * @type {PhotoSwipe}\r\n     */\r\n    const pswp = typeof module === 'object'\r\n        ? new module.default(this.options) // eslint-disable-line\r\n        : new module(this.options); // eslint-disable-line\r\n\r\n    this.pswp = pswp;\r\n    window.pswp = pswp;\r\n\r\n    // map listeners from Lightbox to PhotoSwipe Core\r\n    /** @type {(keyof PhotoSwipeEventsMap)[]} */\r\n    (Object.keys(this._listeners)).forEach((name) => {\r\n      this._listeners[name]?.forEach((fn) => {\r\n        pswp.on(name, /** @type {EventCallback<typeof name>} */(fn));\r\n      });\r\n    });\r\n\r\n    // same with filters\r\n    /** @type {(keyof PhotoSwipeFiltersMap)[]} */\r\n    (Object.keys(this._filters)).forEach((name) => {\r\n      this._filters[name]?.forEach((filter) => {\r\n        pswp.addFilter(name, filter.fn, filter.priority);\r\n      });\r\n    });\r\n\r\n    if (this._preloadedContent) {\r\n      pswp.contentLoader.addToCache(this._preloadedContent);\r\n      this._preloadedContent = undefined;\r\n    }\r\n\r\n    pswp.on('destroy', () => {\r\n      // clean up public variables\r\n      this.pswp = undefined;\r\n      delete window.pswp;\r\n    });\r\n\r\n    pswp.init();\r\n  }\r\n\r\n  /**\r\n   * Unbinds all events, closes PhotoSwipe if it's open.\r\n   */\r\n  destroy() {\r\n    this.pswp?.destroy();\r\n\r\n    this.shouldOpen = false;\r\n    this._listeners = {};\r\n\r\n    getElementsFromOption(this.options.gallery, this.options.gallerySelector)\r\n      .forEach((galleryElement) => {\r\n        galleryElement.removeEventListener('click', this.onThumbnailsClick, false);\r\n      });\r\n  }\r\n}\r\n\r\nexport default PhotoSwipeLightbox;\r\n","import {SizedModel} from './galleries/AbstractGallery';\n\ninterface ImageRatioInfo {\n    ratio: number;\n    cropped: boolean;\n}\n\nexport interface RatioLimits {\n    min?: number;\n    max?: number;\n}\n\nexport function getNextIcon(document: Document): SVGSVGElement {\n    // Here we cannot use `SVGSVGElement.innerHTML`, because it is not available in SSR.\n    // So instead we use `HTMLDivElement.innerHTML`, and get the SVG inside that div.\n    // see: https://github.com/fgnass/domino/blob/12a5f67136a0ac10e3fa1649b8787ba3b309e9a7/lib/Element.js#L95\n    const div = document.createElement('div');\n    div.innerHTML =\n        '<svg viewBox=\"0 0 100 100\"><polygon points=\"88.126,24.216 50.036,62.306 11.947,24.216 0.355,35.809 50.036,85.49 99.718,35.809\"></polygon></svg>';\n\n    return div.querySelector('svg')!;\n}\n\nexport function getImageRatio(model: SizedModel, ratioLimits?: RatioLimits): number {\n    let ratio = Number(model.enlargedWidth) / Number(model.enlargedHeight);\n\n    if (ratioLimits) {\n        if (ratioLimits.min && ratio < ratioLimits.min) {\n            ratio = ratioLimits.min;\n        } else if (ratioLimits.max && ratio > ratioLimits.max) {\n            ratio = ratioLimits.max;\n        }\n    }\n\n    return ratio;\n}\n\nexport function getImageRatioAndIfCropped(model: SizedModel, ratioLimits?: RatioLimits): ImageRatioInfo {\n    let ratio = Number(model.enlargedWidth) / Number(model.enlargedHeight);\n    let cropped = false;\n\n    if (ratioLimits) {\n        if (ratioLimits.min && ratio < ratioLimits.min) {\n            ratio = ratioLimits.min;\n            cropped = true;\n        } else if (ratioLimits.max && ratio > ratioLimits.max) {\n            ratio = ratioLimits.max;\n            cropped = true;\n        }\n    }\n\n    return {ratio: ratio, cropped: cropped};\n}\n\n/**\n * Cleans HTML, and returns only the plain text and `<br>` from all eventual tags\n */\nexport function sanitizeHtml(term: string | undefined): string {\n    return term ? term.replace(/<(?!\\s*br\\s*\\/?)[^>]*>/gi, '') : '';\n}\n","import {ModelAttributes} from './galleries/AbstractGallery';\nimport {sanitizeHtml} from './Utility';\n\nexport enum LabelVisibility {\n    HOVER = 'hover',\n    NEVER = 'never',\n    ALWAYS = 'always',\n}\n\nexport declare interface ItemOptions {\n    /**\n     * Enables ability to zoom images in photoswipe\n     */\n    lightbox?: boolean;\n\n    /**\n     * Add a checkbox to select image\n     */\n    selectable?: boolean;\n\n    /**\n     * Activable emits 'activate' event when link is not provided. It takes place where the link used to be :\n     * in caption or in image if lightbox is false\n     */\n    activable?: boolean;\n    gap?: number;\n    labelVisibility?: LabelVisibility;\n}\n\nexport type ItemActivateEventDetail<Model extends ModelAttributes> = {\n    event: MouseEvent | KeyboardEvent;\n    item: Item<Model>;\n};\n\nexport class Item<Model extends ModelAttributes> {\n    /**\n     * Cleaned title, used for label / button\n     */\n    public readonly sanitizedTitle: string;\n    /**\n     * Reference to the select button\n     */\n    private _checkbox!: HTMLButtonElement;\n    /**\n     * Element referring the \"button\" containing the label\n     */\n    private figcaption: HTMLElement | null = null;\n\n    /**\n     *\n     * @param model Contains the source data given for an item (e.g. object instance from database with id etc...)\n     */\n    public constructor(\n        private readonly document: Document,\n        private readonly options: ItemOptions,\n        public readonly model: Model,\n    ) {\n        this.sanitizedTitle = sanitizeHtml(model.title);\n    }\n\n    /**\n     * Actual row index in the list\n     */\n    private _row!: number;\n\n    get row(): number {\n        return this._row;\n    }\n\n    set row(value: number) {\n        this._row = value;\n    }\n\n    /**\n     * Computed size (real used size)\n     */\n    private _width!: number;\n\n    get width(): number {\n        return this._width;\n    }\n\n    set width(value: number) {\n        this._width = value;\n    }\n\n    private _height!: number;\n\n    get height(): number {\n        return this._height;\n    }\n\n    set height(value: number) {\n        this._height = value;\n    }\n\n    private _cropped = true;\n\n    /* istanbul ignore next */\n    get cropped(): boolean {\n        return this._cropped;\n    }\n\n    set cropped(value: boolean) {\n        this._cropped = value;\n    }\n\n    /**\n     * Wherever item is selected or not\n     */\n    private _selected = false;\n\n    /* istanbul ignore next */\n    get selected(): boolean {\n        return this._selected;\n    }\n\n    /**\n     * Item root element reference (figure)\n     */\n    private _rootElement!: HTMLElement;\n\n    /* istanbul ignore next */\n    get rootElement(): HTMLElement {\n        return this._rootElement;\n    }\n\n    /* istanbul ignore next */\n    get enlargedWidth(): number {\n        return this.model.enlargedWidth;\n    }\n\n    /* istanbul ignore next */\n    get enlargedHeight(): number {\n        return this.model.enlargedHeight;\n    }\n\n    /**\n     * Create DOM elements according to element raw data (thumbnail and enlarged urls)\n     * Also apply border-radius at this level because it never changed threw time\n     *\n     *\n     * Base structure is always the same :\n     *\n     * <figure>\n     *     <img>\n     *     <figcaption>\n     * </figure>\n     *\n     * But depending on settings, we can add <a> inside <figcaption> or wrap around <figure>\n     */\n    public init(): HTMLElement {\n        // Sources\n        const figure = this.getFigure();\n        const caption = this.getEmptyCaption();\n        const image = this.getImage(!!caption);\n\n        // Prepare contextual containers\n        let root = null;\n        const link = this.getEmptyLinkOrButton();\n        let zoomableElement: HTMLElement | null = null;\n\n        // Define and assign roles for each situation\n        if (this.options.lightbox && caption && link) {\n            root = figure;\n            zoomableElement = image;\n            link.innerHTML = this.sanitizedTitle;\n            figure.appendChild(image);\n            caption.appendChild(link);\n            caption.classList.add('link');\n        } else if (this.options.lightbox && caption && !link) {\n            root = figure;\n            caption.innerHTML = this.sanitizedTitle;\n            figure.appendChild(image);\n            zoomableElement = figure;\n        } else if (this.options.lightbox && !caption && link) {\n            root = figure;\n            zoomableElement = figure;\n            figure.appendChild(image);\n            console.warn(\n                'Link or activation are ignored when lightbox is true and there is no caption because there is no element to support it',\n            );\n        } else if (this.options.lightbox && !caption && !link) {\n            root = figure;\n            zoomableElement = figure;\n            figure.appendChild(image);\n        } else if (!this.options.lightbox && caption && link) {\n            root = figure;\n            figure.appendChild(image);\n            caption.appendChild(link);\n            caption.classList.add('link');\n            link.innerHTML = this.sanitizedTitle;\n        } else if (!this.options.lightbox && caption && !link) {\n            root = figure;\n            figure.appendChild(image);\n            caption.innerHTML = this.sanitizedTitle;\n        } else if (!this.options.lightbox && !caption && link) {\n            root = link;\n            figure.appendChild(image);\n            link.appendChild(figure);\n        } else if (!this.options.lightbox && !caption && !link) {\n            root = figure;\n            figure.appendChild(image);\n        }\n\n        this._rootElement = root || figure;\n        this._rootElement.setAttribute('role', 'group');\n        this._rootElement.classList.add('root');\n\n        const checkbox = this.getCheckbox();\n        [caption, checkbox].filter(c => !!c).forEach(c => figure.appendChild(c));\n        this.handleZoom(zoomableElement);\n        this.style();\n\n        return this._rootElement;\n    }\n\n    public setLabelHover(activate: boolean): void {\n        const className = 'hover';\n        if (activate) {\n            this.options.labelVisibility = LabelVisibility.HOVER;\n            this.figcaption?.classList.add(className);\n        } else {\n            this.options.labelVisibility = LabelVisibility.ALWAYS;\n            this.figcaption?.classList.remove(className);\n        }\n    }\n\n    /**\n     * Use computed (organized) data to apply style (size and margin) to elements on DOM\n     * Does not apply border-radius because is used to restyle data on browser resize, and border-radius don't change.\n     */\n    public style(): void {\n        if (!this._rootElement) {\n            return;\n        }\n\n        this._rootElement.style.width = String(this.width + 'px');\n        this._rootElement.style.height = String(this.height + 'px');\n    }\n\n    private emitSelectEvent(): void {\n        const event = new CustomEvent<Item<Model>>('select', {detail: this});\n        this._rootElement.dispatchEvent(event);\n    }\n\n    public toggleSelect(): void {\n        if (this._selected) {\n            this.unselect();\n        } else {\n            this.select();\n        }\n    }\n\n    private throwNotSelectableError(): void {\n        if (!this.options.selectable) {\n            throw Error('Gallery is not selectable');\n        }\n    }\n\n    public select(): void {\n        this.throwNotSelectableError();\n        this._selected = true;\n        this._rootElement.classList.add('selected');\n        this.updateAriaSelectedStatus();\n        this.emitSelectEvent();\n    }\n\n    public unselect(): void {\n        this.throwNotSelectableError();\n        this._selected = false;\n        this._rootElement.classList.remove('selected');\n        this.updateAriaSelectedStatus();\n        this.emitSelectEvent();\n    }\n\n    public remove(): void {\n        this._rootElement.parentNode?.removeChild(this._rootElement);\n    }\n\n    private updateAriaSelectedStatus(): void {\n        this._checkbox.setAttribute('aria-checked', String(this._selected));\n        this._checkbox.setAttribute('aria-label', this._selected ? 'Unselect' : 'Select');\n    }\n\n    private getEmptyLinkOrButton(): HTMLElement | HTMLButtonElement | null {\n        if (this.model.link) {\n            const link = this.document.createElement('a');\n            link.setAttribute('href', this.model.link);\n\n            if (this.model.linkTarget) {\n                link.setAttribute('target', this.model.linkTarget);\n            }\n\n            return link;\n        } else if (this.options.activable) {\n            const button = this.document.createElement('button');\n            button.classList.add('activation');\n            button.setAttribute('tabindex', '0');\n            this.handleActivation(button);\n\n            return button;\n        }\n\n        return null;\n    }\n\n    /**\n     * Label is visible if options mention hover or always\n     * @private\n     */\n    private showLabel(): boolean {\n        let showLabel = false;\n\n        const showLabelValues = [LabelVisibility.ALWAYS, LabelVisibility.HOVER];\n        if (\n            this.sanitizedTitle &&\n            this.options.labelVisibility &&\n            showLabelValues.includes(this.options.labelVisibility)\n        ) {\n            showLabel = true;\n        }\n\n        return showLabel;\n    }\n\n    private getFigure(): HTMLElement {\n        const figure = this.document.createElement('figure');\n        figure.classList.add('figure');\n        figure.setAttribute('role', 'group');\n\n        if (this.model.color) {\n            figure.style.backgroundColor = this.model.color + '11';\n        }\n\n        return figure;\n    }\n\n    private getImage(hasCaption: boolean): HTMLImageElement {\n        const image = this.document.createElement('img');\n        image.setAttribute('src', this.model.thumbnailSrc);\n        image.style.objectFit = this.model.objectFit || 'cover';\n        image.style.objectPosition = this.model.objectPosition || 'center';\n        image.classList.add('image');\n        image.setAttribute('loading', 'lazy');\n        image.addEventListener('load', () => this._rootElement.classList.add('loaded'));\n\n        // If alt is provided and different from title, set it on mage\n        // If title, but no alt neither caption, set title as alt attribute on image\n        if (this.model.alt && this.model.alt !== this.sanitizedTitle) {\n            image.setAttribute('alt', this.model.alt);\n        } else if (!hasCaption && this.sanitizedTitle) {\n            image.setAttribute('alt', this.sanitizedTitle);\n        }\n\n        return image;\n    }\n\n    private getEmptyCaption(): HTMLElement | null {\n        if (!this.showLabel()) {\n            return null;\n        }\n\n        const caption = this.document.createElement('figcaption');\n        caption.classList.add('caption');\n        caption.classList.add('title');\n\n        if (this.options.labelVisibility === LabelVisibility.HOVER) {\n            caption.classList.add('hover');\n        }\n\n        this.figcaption = caption;\n        return caption;\n    }\n\n    private getCheckbox(): HTMLButtonElement | null {\n        if (!this.options.selectable) {\n            return null;\n        }\n\n        const checkbox = this.document.createElement('button') as HTMLButtonElement;\n        checkbox.tabIndex = 0;\n        checkbox.classList.add('select-btn');\n        checkbox.setAttribute('role', 'checkbox');\n\n        const marker = this.document.createElement('div');\n        marker.classList.add('marker');\n        checkbox.appendChild(marker);\n\n        const handleCheckboxAction = (e: Event) => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.toggleSelect();\n        };\n\n        checkbox.addEventListener('click', handleCheckboxAction);\n        checkbox.addEventListener('keydown', e => {\n            if (e.key === 'Enter' || e.key === ' ') {\n                handleCheckboxAction(e);\n            }\n        });\n        this._checkbox = checkbox;\n        this.updateAriaSelectedStatus();\n\n        if (this.model.selected) {\n            this.select();\n        } else {\n            this.unselect();\n        }\n\n        return checkbox;\n    }\n\n    private handleActivation(element: HTMLElement): void {\n        element.setAttribute('aria-label', 'activate item');\n        const activate = (ev: MouseEvent | KeyboardEvent) => {\n            const data: ItemActivateEventDetail<Model> = {item: this, event: ev};\n            const activableEvent = new CustomEvent<ItemActivateEventDetail<Model>>('activate', {detail: data});\n            this._rootElement.dispatchEvent(activableEvent);\n        };\n        element.addEventListener('click', activate);\n        element.addEventListener('keydown', e => {\n            if (e.key === 'Enter' || e.key === ' ') {\n                activate(e);\n            }\n        });\n    }\n\n    private handleZoom(element: HTMLElement | null): void {\n        if (!element) {\n            return;\n        }\n\n        if (element) {\n            element.tabIndex = 0;\n            element.setAttribute('aria-label', 'zoom');\n            element.setAttribute('role', 'button');\n            element.classList.add('zoomable');\n            const handleZoom = () => {\n                const event = new CustomEvent<Item<Model>>('zoom', {detail: this});\n                this._rootElement.dispatchEvent(event);\n            };\n\n            element.addEventListener('click', handleZoom);\n            element.addEventListener('keydown', e => {\n                if (e.key === 'Enter' || e.key === ' ') {\n                    e.preventDefault();\n                    handleZoom();\n                }\n            });\n        }\n    }\n}\n","import {debounce, pick} from 'es-toolkit';\nimport {defaultsDeep} from 'es-toolkit/compat';\nimport PhotoSwipe, {PhotoSwipeOptions, SlideData} from 'photoswipe';\nimport PhotoSwipeLightbox from 'photoswipe/lightbox';\nimport 'photoswipe/dist/photoswipe.css';\nimport {Item, ItemActivateEventDetail, ItemOptions, LabelVisibility} from '../Item';\nimport {getNextIcon} from '../Utility';\n\nexport type ObjectFit = 'fill' | 'contain' | 'cover' | 'none' | 'scale-down' | 'inherit' | 'initial' | 'unset';\n\nexport type ObjectPosition =\n    | 'center'\n    | 'top'\n    | 'bottom'\n    | 'left'\n    | 'right'\n    | 'top left'\n    | 'top right'\n    | 'top center'\n    | 'bottom left'\n    | 'bottom right'\n    | 'bottom center'\n    | 'center left'\n    | 'center right'\n    | string;\n\n/**\n * A map of all possible event and the structure of their details\n */\nexport interface CustomEventDetailMap<T> {\n    activate: {item: T; event: MouseEvent | KeyboardEvent};\n    'item-added-to-dom': T;\n    'item-displayed': T;\n    pagination: {offset: number; limit: number};\n    select: T[];\n}\n\n/**\n * Augment the global namespace with our custom events\n * See: https://github.com/Microsoft/TypeScript/issues/28357\n */\ndeclare global {\n    interface HTMLElementEventMap {\n        activate: CustomEvent;\n        'item-added-to-dom': CustomEvent;\n        'item-displayed': CustomEvent;\n        pagination: CustomEvent;\n        select: CustomEvent;\n    }\n}\n\nexport interface SizedModel {\n    /**\n     * Height in pixels of the enlarged version the image\n     * If photoswipe is used, the size of the photoswipe enlarged image is required\n     * If photoswipe is not used, any size that match the ratio is enough\n     */\n    enlargedWidth: number;\n\n    /**\n     * Width in pixels of the enlarged version the image\n     * If photoswipe is used, the size of the photoswipe enlarged image is required\n     * If photoswipe is not used, any size that match the ratio is enough\n     */\n    enlargedHeight: number;\n}\n\nexport interface ModelAttributes extends SizedModel {\n    /**\n     * Source link for thumbnail image\n     */\n    thumbnailSrc: string;\n\n    /**\n     * Source link for enlarged (photoswipe) image\n     */\n    enlargedSrc?: string;\n\n    /**\n     * Label of item (or button)\n     */\n    title?: string;\n\n    /**\n     * Href link\n     */\n    link?: string;\n\n    /**\n     * a href target attribute\n     */\n    linkTarget?: '_blank' | '_self' | '_parent' | '_top';\n\n    /**\n     * Hex color\n     */\n    color?: string;\n\n    /**\n     * If item is selected\n     */\n    selected?: boolean;\n\n    /**\n     * Background size, default : cover\n     */\n    objectFit?: ObjectFit;\n\n    /**\n     * Background position, default : center\n     */\n    objectPosition?: ObjectPosition;\n\n    /**\n     * Short text describing specifically the image\n     */\n    alt?: string;\n}\n\nexport interface GalleryOptions extends ItemOptions {\n    rowsPerPage?: number;\n    minRowsAtStart?: number;\n    infiniteScrollOffset?: number;\n    photoSwipeOptions?: PhotoSwipeOptions;\n    photoSwipePluginsInitFn?: ((lighbox: PhotoSwipeLightbox) => void) | null;\n    ssr?: {\n        /**\n         * In SSR mode, if the gallery width cannot be computed, it will fallback to this value\n         */\n        galleryWidth: number;\n    };\n}\n\nexport abstract class AbstractGallery<Model extends ModelAttributes = ModelAttributes> {\n    /**\n     * Default options\n     */\n    protected options: Required<GalleryOptions> = {\n        gap: 3,\n        rowsPerPage: 0,\n        labelVisibility: LabelVisibility.HOVER,\n        lightbox: false,\n        minRowsAtStart: 2,\n        selectable: false,\n        activable: false,\n        infiniteScrollOffset: 0,\n        photoSwipeOptions: {\n            loop: false,\n        },\n        photoSwipePluginsInitFn: null,\n        ssr: {\n            galleryWidth: 480,\n        },\n    };\n\n    /**\n     * Images wrapper container\n     */\n    protected bodyElementRef: HTMLElement;\n\n    /**\n     * Items for which container has been added to dom, but image has not been queries yet\n     */\n    protected scrollBufferedItems: Item<Model>[] = [];\n\n    /**\n     * Debounce function\n     * Runs a small delay after last image has been added to dom\n     * When it runs, images are loaded (appear with fade) and more images are queries to preserve a buffer of\n     * out-of-dom items\n     */\n    protected flushBufferedItems: () => void;\n\n    /**\n     * Number of items to query on buffer flushing\n     */\n    protected requiredItems = 0;\n    protected readonly document: Document;\n    /**\n     * PhotoSwipe Lightbox object\n     */\n    protected psLightbox: PhotoSwipeLightbox | null = null;\n    /**\n     * Used to test the scroll direction\n     * Avoid to load more images when scrolling up\n     */\n    private old_scroll_top = 0;\n    /**\n     * Stores page index that have been emitted\n     * Keeps a log of pages already asked to prevent to ask them multiple times\n     */\n    private requestedIndexesLog: number[] = [];\n    /**\n     * Reference to next button element\n     */\n    private nextButton: HTMLElement;\n\n    /**\n     *\n     * @param elementRef\n     * @param options\n     * @param scrollElementRef\n     */\n    constructor(\n        protected elementRef: HTMLElement,\n        options: GalleryOptions,\n        protected scrollElementRef?: HTMLElement | null,\n    ) {\n        this.document = this.elementRef.ownerDocument;\n        this.options = defaultsDeep(options, this.options);\n\n        // After having finished to add items to dom, show images inside containers and emit updated pagination\n        this.flushBufferedItems = debounce(() => {\n            this.scrollBufferedItems.forEach(item => {\n                this.dispatchEvent('item-displayed', item);\n            });\n\n            this.scrollBufferedItems = [];\n\n            if (!this.requiredItems) {\n                return;\n            }\n\n            // Each time a pagination event is emitted, the offset is logged and then verified to be sure to not ask it\n            // twice. That would cause duplicated entries and probably empty buffer with smaller pages. That could\n            // cause infinite loading until the end of the gallery\n            if (this.requestedIndexesLog.indexOf(this.collection.length) < 0) {\n                const offset = this.collection.length;\n                this.dispatchEvent('pagination', {offset, limit: this.requiredItems});\n                this.requestedIndexesLog.push(offset);\n                this.requiredItems = 0;\n            }\n        }, 500);\n\n        this.elementRef.classList.add('natural-gallery-js');\n        this.elementRef.classList.add(this.getFormatName());\n\n        // Next button\n        this.nextButton = this.document.createElement('div');\n        this.nextButton.classList.add('natural-gallery-next');\n        this.nextButton.appendChild(getNextIcon(this.document));\n        this.nextButton.style.display = 'none';\n        this.nextButton.addEventListener('click', e => {\n            e.preventDefault();\n            this.onPageAdd();\n        });\n\n        this.bodyElementRef = this.document.createElement('div');\n        this.bodyElementRef.classList.add('natural-gallery-body');\n        this.extendToFreeViewport();\n\n        // Iframe\n        const iframe = this.document.createElement('iframe');\n        this.elementRef.appendChild(iframe);\n\n        // Resize debounce\n        const resizeDebounceDuration = 500;\n        const startResize = debounce(() => this.startResize(), resizeDebounceDuration, {edges: ['leading']});\n        const endResize = debounce(() => this.endResize(), resizeDebounceDuration);\n        iframe.contentWindow?.addEventListener('resize', () => {\n            endResize();\n            startResize();\n        });\n\n        this.elementRef.appendChild(this.bodyElementRef);\n        this.elementRef.appendChild(this.nextButton);\n\n        if (!this.options.rowsPerPage) {\n            this.bindScroll(this.scrollElementRef || this.document);\n        }\n\n        this.requestItems();\n\n        if (this.options.lightbox) {\n            this.photoSwipeInit();\n        }\n    }\n\n    /**\n     * Get PhotoSwipe Lightbox\n     */\n    /* istanbul ignore next */\n    get photoSwipe(): PhotoSwipeLightbox | null {\n        return this.psLightbox;\n    }\n\n    /**\n     * Get currently selected PhotoSwipe image\n     */\n    /* istanbul ignore next */\n    get photoSwipeCurrentItem(): Model | null {\n        return this.collection[this.psLightbox?.pswp?.currIndex || 0]?.model || null;\n    }\n\n    /**\n     * Complete collection of images\n     * @type {Array}\n     */\n    protected _collection: Item<Model>[] = [];\n\n    get collection(): Item<Model>[] {\n        return this._collection;\n    }\n\n    /**\n     * Partial set of items that represent the visible items\n     * @type {Item[]}\n     * @private\n     */\n    protected _domCollection: Item<Model>[] = [];\n\n    get domCollection(): Item<Model>[] {\n        return this._domCollection;\n    }\n\n    get selectedItems(): Model[] {\n        return this.domCollection.filter(item => item.selected).map(item => item.model);\n    }\n\n    get width(): number {\n        // elementRef.clientWidth rounds ceil, we need round floor to grant computing fits in the available space\n        // elementRef.getBoundingClientRect().width doesn't round, so we can round floor.\n        return Math.floor(this.elementRef.getBoundingClientRect?.().width ?? this.options.ssr.galleryWidth);\n    }\n\n    public addItemToPhotoSwipeCollection(item: Item<Model>) {\n        const photoSwipeId = this.domCollection.length - 1;\n\n        /* istanbul ignore next */\n        item.rootElement.addEventListener('zoom', () => {\n            this.psLightbox?.loadAndOpen(photoSwipeId);\n        });\n    }\n\n    /**\n     * Add items to collection\n     * Transform given list of models into inner Items\n     * @param models list of models\n     */\n    public addItems(models: Model[]): void {\n        // Display newly added images if it's the first addition or if all images are already shown\n        const addToDom = this.collection.length === this.domCollection.length;\n        const collectionSize = this.collection.length;\n\n        // Complete collection\n        models.forEach((model: Model) => {\n            const itemOptions = pick(this.options, ['lightbox', 'selectable', 'activable', 'gap', 'labelVisibility']);\n            const item = new Item<Model>(this.document, itemOptions, model);\n            this._collection.push(item);\n        });\n\n        if (addToDom && collectionSize === 0) {\n            // First addition : collection size is 0\n            this.onPageAdd();\n        } else if (addToDom && collectionSize > 0) {\n            // Gallery collection completion (after first addition) : collection size > 0\n            this.onScroll();\n        }\n    }\n\n    public setLabelHover(activate: boolean): void {\n        this.options.labelVisibility = activate ? LabelVisibility.HOVER : LabelVisibility.ALWAYS;\n        this.collection.forEach(item => {\n            item.setLabelHover(activate);\n        });\n    }\n\n    /**\n     * Select all items visible in the DOM\n     * Ignores buffered items\n     */\n    public selectDomCollection(): Model[] {\n        if (!this.options.selectable) {\n            throw Error('Gallery is not selectable');\n        }\n\n        this.domCollection.forEach(item => item.select());\n        return this.selectedItems;\n    }\n\n    /**\n     * Unselect all selected elements\n     */\n    public unselectAllItems(): void {\n        this.domCollection.forEach(item => item.unselect());\n    }\n\n    /**\n     * Allows to use the same approach and method name to listen as gallery events on DOM or on javascript gallery\n     * object\n     *\n     * Gallery requests items when it's instantiated. But user may subscribe after creation, so we need to request\n     * again if user subscribes by this function.\n     *\n     * @param name\n     * @param callback\n     * @param options An object that specifies characteristics about the event listener. The available options are, see\n     *     addEventListener official documentation\n     */\n    public addEventListener<K extends keyof CustomEventDetailMap<Model>>(\n        name: K,\n        callback: (evt: CustomEvent<CustomEventDetailMap<Model>[K]>) => void,\n        options?: boolean | AddEventListenerOptions,\n    ): void;\n\n    public addEventListener(\n        name: keyof CustomEventDetailMap<Model>,\n        callback: (evt: CustomEvent<CustomEventDetailMap<Model>[keyof CustomEventDetailMap<Model>]>) => void,\n        options?: boolean | AddEventListenerOptions,\n    ): void {\n        this.elementRef.addEventListener(name, callback, options);\n\n        if (name === 'pagination') {\n            this.requestItems();\n        }\n    }\n\n    /**\n     * Public api for empty function\n     * Emits a pagination event\n     */\n    public clear(): void {\n        this.empty();\n        this.requestItems();\n    }\n\n    /**\n     * Return copy of options to prevent modification\n     */\n    public getOptions(): GalleryOptions {\n        return this.options;\n    }\n\n    /**\n     * Override current collection\n     * @param {Item[]} items\n     */\n    public setItems(items: Model[]): void {\n        this.empty();\n        this.addItems(items);\n    }\n\n    /**\n     *\n     */\n    public abstract organizeItems(items: Item<Model>[], fromRow?: number, toRow?: number): void;\n\n    /**\n     * Initializes PhotoSwipe\n     */\n    protected photoSwipeInit() {\n        this.psLightbox = new PhotoSwipeLightbox({\n            ...this.options.photoSwipeOptions,\n            pswpModule: PhotoSwipe,\n        });\n\n        /* istanbul ignore next */\n        this.psLightbox.addFilter('numItems', (): number => {\n            return this.domCollection.length;\n            // return this.collection.length;\n        });\n\n        /* istanbul ignore next */\n        this.psLightbox.addFilter('itemData', (_itemData: SlideData, index: number): SlideData => {\n            const item = this.collection[index];\n            return {\n                id: index,\n                src: item.model.enlargedSrc,\n                w: item.model.enlargedWidth,\n                h: item.model.enlargedHeight,\n                msrc: item.model.thumbnailSrc,\n                element: item.rootElement,\n                thumbCropped: item.cropped,\n                alt: item.sanitizedTitle,\n            };\n        });\n\n        /* istanbul ignore next */\n        if (this.options.photoSwipePluginsInitFn) {\n            this.options.photoSwipePluginsInitFn(this.psLightbox);\n        }\n\n        this.psLightbox.init();\n\n        // Loading one more page when going to next image\n        /* istanbul ignore next */\n        this.psLightbox.on('change', () => {\n            // Positive delta means next slide.\n            // If we go next slide, and current index is out of visible collection bound, load more items\n            if (this.psLightbox?.pswp && this.psLightbox.pswp.currIndex > this.domCollection.length - 10) {\n                this.onPageAdd();\n            }\n        });\n\n        // With accessibility :focus usage, figures tend to stay sticky on focused state. This returns to wanted behavior\n        /* istanbul ignore next */\n        this.psLightbox.on('destroy', () => {\n            (this.document.activeElement as HTMLElement)?.blur();\n        });\n    }\n\n    /**\n     *\n     */\n    protected abstract getEstimatedColumnsPerRow(): number;\n\n    /**\n     * AbstractRowGallery + Masonry\n     */\n    protected abstract onScroll(): void;\n\n    /**\n     * AbstractRowGallery + Masonry\n     */\n    protected abstract onPageAdd(): void;\n\n    protected abstract getFormatName(): string;\n\n    /**\n     * Return number of rows to show per page to fill the empty space until the bottom of the screen\n     * Should grant all the space is used or more, but not less.\n     * @returns {number}\n     */\n    protected abstract getEstimatedRowsPerPage(): number;\n\n    /**\n     * Fire pagination event\n     * Information provided in the event allows to retrieve items from the server using given data :\n     * \"offset\" and \"limit\" that have the same semantic that respective attributes in mySQL.\n     *\n     * The gallery asks for items it needs, including some buffer items that are not displayed when given but are\n     * available to be added immediately to DOM when user scrolls.\n     *\n     */\n    protected requestItems(): void {\n        const estimatedPerRow = this.getEstimatedColumnsPerRow();\n\n        // +1 because we have to get more than what is used under onPageAdd().\n        // Without +1 all items are always added to DOM and gallery will loop load until end of collection\n        const limit = estimatedPerRow * this.getRowsPerPage() + 1;\n        this.dispatchEvent('pagination', {offset: this.collection.length, limit: limit});\n    }\n\n    /**\n     * Returns option.rowsPerPage is specified.\n     * If not returns the estimated number of rows to fill the rest of the vertical space in the screen\n     * @returns {number}\n     */\n    protected getRowsPerPage(): number {\n        if (this.options.rowsPerPage > 0) {\n            return this.options.rowsPerPage;\n        }\n\n        const estimation = this.getEstimatedRowsPerPage();\n        return estimation < this.options.minRowsAtStart ? this.options.minRowsAtStart : estimation;\n    }\n\n    /**\n     * Add given item to DOM and to domCollection\n     * @param {Item} item\n     * @param destination\n     */\n    protected addItemToDOM(item: Item<Model>, destination: HTMLElement = this.bodyElementRef): void {\n        this.domCollection.push(item);\n\n        destination.appendChild(item.init());\n\n        this.scrollBufferedItems.push(item);\n        this.requiredItems++;\n        this.dispatchEvent('item-added-to-dom', item);\n\n        // When selected / unselected\n        item.rootElement.addEventListener('select', () => {\n            this.dispatchEvent(\n                'select',\n                this.domCollection.filter(i => i.selected),\n            );\n        });\n\n        // When activate (if activate event is given in options)\n        item.rootElement.addEventListener('activate', (ev: CustomEvent<ItemActivateEventDetail<Model>>) => {\n            this.dispatchEvent('activate', {item, event: ev.detail.event});\n        });\n\n        if (this.options.lightbox) {\n            this.addItemToPhotoSwipeCollection(item);\n        }\n    }\n\n    protected updateNextButtonVisibility(): void {\n        if (this.domCollection.length === this.collection.length) {\n            this.nextButton.style.display = 'none';\n        } else {\n            this.nextButton.style.display = 'block';\n        }\n    }\n\n    /**\n     * If infinite scroll (no option.rowsPerPage provided), a minimum height is setted to force gallery to overflow\n     * from viewport. This activates the scroll before adding items to dom. This prevents the scroll to fire new resize\n     * event and recompute all gallery twice on start.\n     */\n    protected extendToFreeViewport(): void {\n        if (this.options.rowsPerPage) {\n            return;\n        }\n\n        this.elementRef.style.minHeight = this.getGalleryVisibleHeight() + 10 + 'px';\n    }\n\n    /**\n     * Space between the top of the gallery wrapper (parent of gallery root elementRef) and the bottom of the window\n     */\n    protected getGalleryVisibleHeight(): number {\n        if (this.document.defaultView) {\n            return this.document.defaultView.innerHeight - this.elementRef.offsetTop;\n        }\n\n        return 0;\n    }\n\n    protected startResize(): void {\n        this.bodyElementRef?.classList.add('resizing');\n    }\n\n    protected endResize(): void {\n        this.bodyElementRef?.classList.remove('resizing');\n    }\n\n    protected dispatchEvent<K extends keyof CustomEventDetailMap<Item<Model>>>(\n        name: K,\n        data: CustomEventDetailMap<Item<Model>>[K],\n    ): void {\n        try {\n            const event = new CustomEvent(name, {detail: data});\n            this.elementRef.dispatchEvent(event);\n        } catch {\n            // silent fail\n        }\n    }\n\n    /**\n     * Effectively empty gallery, and should prepare container to receive new items\n     */\n    protected empty(): void {\n        this.bodyElementRef.innerHTML = '';\n        this.requestedIndexesLog.length = 0;\n        this._domCollection = [];\n        this._collection = [];\n    }\n\n    /**\n     * Listen to scroll event and manages rows additions for lazy load\n     * @param {HTMLElement | Document} element\n     */\n    private bindScroll(element: HTMLElement | Document) {\n        const scrollable = element;\n        const wrapper: HTMLElement = element instanceof Document ? element.documentElement : element;\n\n        const startScroll = debounce(() => this.elementRef.classList.add('scrolling'), 300, {edges: ['leading']});\n        const endScroll = debounce(() => this.elementRef.classList.remove('scrolling'), 300);\n\n        scrollable.addEventListener('scroll', () => {\n            startScroll();\n            endScroll();\n\n            const endOfGalleryAt =\n                this.elementRef.offsetTop + this.elementRef.offsetHeight + this.options.infiniteScrollOffset;\n\n            // Avoid to expand gallery if we are scrolling up\n            const current_scroll_top = wrapper.scrollTop - (wrapper.clientTop || 0);\n            const wrapperHeight = wrapper.clientHeight;\n            const scroll_delta = current_scroll_top - this.old_scroll_top;\n            this.old_scroll_top = current_scroll_top;\n\n            // \"enableMoreLoading\" is a setting coming from the BE bloking / enabling dynamic loading of thumbnail\n            if (scroll_delta > 0 && current_scroll_top + wrapperHeight >= endOfGalleryAt) {\n                // When scrolling only add a row at once\n                this.onScroll();\n            }\n        });\n    }\n\n    get rootElement(): HTMLElement {\n        return this.elementRef;\n    }\n\n    get bodyElement(): HTMLElement {\n        return this.bodyElementRef;\n    }\n}\n","import {AbstractGallery, GalleryOptions, ModelAttributes} from './AbstractGallery';\n\nexport abstract class AbstractRowGallery<\n    Model extends ModelAttributes = ModelAttributes,\n> extends AbstractGallery<Model> {\n    protected constructor(\n        protected elementRef: HTMLElement,\n        options: GalleryOptions,\n        protected scrollElementRef?: HTMLElement | null,\n    ) {\n        super(elementRef, options, scrollElementRef);\n        this.bodyElementRef!.style.rowGap = this.options.gap + 'px';\n    }\n\n    protected onScroll(): void {\n        this.addRows(1);\n    }\n\n    protected onPageAdd(): void {\n        this.addRows(this.getRowsPerPage());\n    }\n\n    /**\n     * Add given number of rows to DOM\n     * @param rows\n     */\n    protected addRows(rows: number): void {\n        const nbVisibleImages = this.domCollection.length;\n\n        // Next row to add (first invisible row)\n        const nextRow = this.domCollection.length ? this.domCollection[nbVisibleImages - 1].row + 1 : 0;\n        const lastWantedRow = nextRow + rows - 1;\n\n        // Compute size only for elements we're going to add\n        const bufferedItems = this.collection.slice(nbVisibleImages);\n        this.organizeItems(bufferedItems, nextRow, lastWantedRow);\n\n        const itemsToAdd = bufferedItems.filter(i => i.row <= lastWantedRow);\n        itemsToAdd.forEach(i => this.addItemToDOM(i));\n\n        this.flushBufferedItems();\n        this.updateNextButtonVisibility();\n    }\n\n    protected endResize(): void {\n        super.endResize();\n\n        if (!this.domCollection.length) {\n            return;\n        }\n\n        // Compute with new width. Rows indexes may have changed\n        this.organizeItems(this.domCollection);\n    }\n}\n","import {Item} from '../Item';\nimport {getImageRatio, getImageRatioAndIfCropped, RatioLimits} from '../Utility';\nimport {GalleryOptions, ModelAttributes, SizedModel} from './AbstractGallery';\nimport {AbstractRowGallery} from './AbstractRowGallery';\n\nexport interface NaturalGalleryOptions extends GalleryOptions {\n    rowHeight: number;\n    ratioLimit?: RatioLimits;\n}\n\nexport class Natural<Model extends ModelAttributes = ModelAttributes> extends AbstractRowGallery<Model> {\n    /**\n     * Options after having been defaulted\n     */\n    declare protected options: Required<NaturalGalleryOptions>;\n\n    constructor(elementRef: HTMLElement, options: NaturalGalleryOptions, scrollElementRef?: HTMLElement | null) {\n        super(elementRef, options, scrollElementRef);\n        if (!options.rowHeight || options.rowHeight <= 0) {\n            throw new Error('Option.rowHeight must be positive');\n        }\n    }\n\n    public static organizeItems<T extends ModelAttributes>(\n        gallery: Natural<T>,\n        items: Item<T>[],\n        fromRow = 0,\n        toRow: number | null = null,\n        currentRow: number | null = null,\n    ): void {\n        if (!currentRow) {\n            currentRow = fromRow ? fromRow : 0;\n        }\n\n        const options = gallery.options;\n\n        for (let chunkSize = 1; chunkSize <= items.length; chunkSize++) {\n            const chunk = items.slice(0, chunkSize);\n            const rowWidth = this.getRowWidth(\n                chunk.map(c => c.model),\n                options.rowHeight,\n                options.gap,\n                options.ratioLimit,\n            );\n\n            if (rowWidth >= gallery.width) {\n                // if end of row\n\n                this.computeSizes(chunk, gallery.width, options.gap, currentRow, null, options.ratioLimit);\n\n                const nextRow = currentRow + 1;\n                if (toRow === null || nextRow <= toRow) {\n                    Natural.organizeItems(gallery, items.slice(chunkSize), fromRow, toRow, nextRow);\n                }\n\n                break;\n            } else if (chunkSize === items.length) {\n                // if end of list\n                // the width is not fixed as we have not enough items\n                // size of images are indexed on max row height.\n                this.computeSizes(chunk, null, options.gap, currentRow, options.rowHeight, options.ratioLimit);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Compute sizes for given images to fit in given row width\n     * Items are updated\n     */\n    public static computeSizes<T extends ModelAttributes>(\n        chunk: Item<T>[],\n        containerWidth: number | null,\n        margin: number,\n        row: number,\n        maxRowHeight: number | null = null,\n        ratioLimits?: RatioLimits,\n    ): void {\n        const chunkModels = chunk.map(c => c.model);\n        const rowHeight = containerWidth\n            ? this.getRowHeight(chunkModels, containerWidth, margin, ratioLimits)\n            : (maxRowHeight ?? 0);\n        const rowWidth = this.getRowWidth(chunkModels, rowHeight, margin, ratioLimits);\n\n        // Overflowed pixels\n        const apportion = (rowWidth - (containerWidth ?? 0)) / chunk.length;\n        const excess = containerWidth ? apportion : 0;\n        let decimals = 0;\n\n        for (let i = 0; i < chunk.length; i++) {\n            const item = chunk[i];\n            const {ratio, cropped} = getImageRatioAndIfCropped(item.model, ratioLimits);\n            let width = ratio * rowHeight - excess;\n            decimals += width - Math.floor(width);\n            width = Math.floor(width);\n\n            if (decimals >= 1 || (i === chunk.length - 1 && Math.round(decimals) === 1)) {\n                width++;\n                decimals--;\n            }\n\n            item.width = width;\n            item.height = Math.floor(rowHeight);\n            item.cropped = cropped;\n            item.row = row;\n            item.style();\n        }\n    }\n\n    public static getRowWidth(\n        models: SizedModel[],\n        maxRowHeight: number,\n        margin: number,\n        ratioLimits?: RatioLimits,\n    ): number {\n        return margin * (models.length - 1) + this.getRatios(models, ratioLimits) * maxRowHeight;\n    }\n\n    public static getRowHeight(\n        models: SizedModel[],\n        containerWidth: number,\n        margin: number,\n        ratioLimits?: RatioLimits,\n    ): number {\n        return (containerWidth - margin * (models.length - 1)) / this.getRatios(models, ratioLimits);\n    }\n\n    /**\n     * Return the ratio format of models as if they were a single image\n     */\n    public static getRatios(models: SizedModel[], ratioLimits?: RatioLimits): number {\n        return models.reduce((total, model) => total + getImageRatio(model, ratioLimits), 0);\n    }\n\n    public addRows(rows: number): void {\n        this.completeLastRow();\n        super.addRows(rows);\n    }\n\n    public organizeItems(items: Item<Model>[], fromRow?: number, toRow?: number): void {\n        Natural.organizeItems(this, items, fromRow, toRow);\n    }\n\n    protected getFormatName(): string {\n        return 'format-natural';\n    }\n\n    protected endResize(): void {\n        super.endResize();\n        this.completeLastRow();\n        this.flushBufferedItems();\n    }\n\n    protected getEstimatedColumnsPerRow(): number {\n        let ratio = 1;\n\n        // Better prediction using ratio if provided\n        if (this.options.ratioLimit && this.options.ratioLimit.min) {\n            ratio = this.options.ratioLimit.min;\n        }\n\n        return Math.ceil(((1 / ratio) * this.width + this.options.gap) / (this.options.rowHeight + this.options.gap));\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        return Math.ceil(this.getGalleryVisibleHeight() / (this.options.rowHeight + this.options.gap)) + 1;\n    }\n\n    private completeLastRow(): void {\n        if (!this.domCollection.length) {\n            return;\n        }\n\n        // Get last row number\n        const lastVisibleRow = this.domCollection[this.domCollection.length - 1].row;\n\n        // Get number of items in that last row\n        const visibleItemsInLastRow = this.domCollection.filter(i => i.row === lastVisibleRow).length;\n\n        // Get a list from first item of last row until end of collection\n        const collectionFromLastVisibleRow = this.collection.slice(this.domCollection.length - visibleItemsInLastRow);\n        this.organizeItems(\n            collectionFromLastVisibleRow,\n            collectionFromLastVisibleRow[0].row,\n            collectionFromLastVisibleRow[0].row,\n        );\n        const itemsToAdd = collectionFromLastVisibleRow\n            .slice(visibleItemsInLastRow)\n            .filter(i => i.row <= collectionFromLastVisibleRow[0].row);\n\n        itemsToAdd.forEach(i => this.addItemToDOM(i));\n    }\n}\n","import {Item} from './Item';\nimport {ModelAttributes} from './galleries/AbstractGallery';\n\nexport declare interface ColumnOptions {\n    width: number;\n    gap: number;\n}\n\nexport class Column<Model extends ModelAttributes> {\n    private readonly collection: Item<Model>[] = [];\n\n    private readonly _elementRef: HTMLElement;\n\n    public constructor(\n        document: Document,\n        private options: ColumnOptions,\n    ) {\n        this._elementRef = document.createElement('div');\n        this._elementRef.classList.add('column');\n        this._elementRef.style.width = this.options.width + 'px';\n        this._elementRef.style.gap = this.options.gap + 'px';\n    }\n\n    get height(): number {\n        return this._elementRef.offsetHeight;\n    }\n\n    get length(): number {\n        return this.collection.length;\n    }\n\n    get elementRef(): HTMLElement {\n        return this._elementRef;\n    }\n\n    public addItem(item: Item<Model>): void {\n        this.collection.push(item);\n    }\n}\n","import {Column} from '../Column';\nimport {Item} from '../Item';\nimport {getImageRatioAndIfCropped, RatioLimits} from '../Utility';\nimport {AbstractGallery, GalleryOptions, ModelAttributes} from './AbstractGallery';\n\nexport interface MasonryGalleryOptions extends GalleryOptions {\n    columnWidth: number;\n    ratioLimit?: RatioLimits;\n}\n\nexport class Masonry<Model extends ModelAttributes = ModelAttributes> extends AbstractGallery<Model> {\n    /**\n     * Options after having been defaulted\n     */\n    declare protected options: Required<MasonryGalleryOptions>;\n\n    /**\n     * Regroup the list of columns\n     */\n    protected columns: Column<Model>[] = [];\n\n    constructor(elementRef: HTMLElement, options: MasonryGalleryOptions, scrollElementRef?: HTMLElement | null) {\n        super(elementRef, options, scrollElementRef);\n\n        if (!options.columnWidth || options.columnWidth <= 0) {\n            throw new Error('Option.columnWidth must be positive');\n        }\n\n        this.addColumns();\n\n        /**\n         * Setup scroll detection to prevent empty zones due to different heights\n         */\n        if (!this.options.infiniteScrollOffset) {\n            let ratio = 0.5; // Portrait format to maximize estimated height\n\n            // Better prediction using ratio if provided\n            if (this.options.ratioLimit && this.options.ratioLimit.min) {\n                ratio = this.options.ratioLimit.min;\n            }\n\n            const columnWidth = this.getColumnWidth();\n            this.options.infiniteScrollOffset = (-1 * columnWidth) / ratio;\n        }\n    }\n\n    /**\n     * Compute sides with 1:1 ratio\n     */\n    public static organizeItems<T extends ModelAttributes>(\n        gallery: Masonry<T>,\n        items: Item<T>[],\n        fromIndex = 0,\n        toIndex: number | null = null,\n    ): void {\n        const itemsPerRow = gallery.getEstimatedColumnsPerRow();\n\n        // Compute columnWidth of pictures\n        const columnWidth = gallery.getColumnWidth();\n\n        let lastIndex = toIndex ? itemsPerRow * (toIndex - fromIndex + 1) : items.length;\n        lastIndex = lastIndex > items.length ? items.length : lastIndex;\n\n        for (let i = 0; i < lastIndex; i++) {\n            const item = items[i];\n            const {ratio, cropped} = getImageRatioAndIfCropped(item.model, gallery.options.ratioLimit);\n\n            item.width = Math.floor(columnWidth);\n            item.height = item.width / ratio;\n            item.cropped = cropped;\n            item.style(); // todo : externalise to split dom manipulation and logic computing\n        }\n    }\n\n    public organizeItems(items: Item<Model>[], fromRow?: number, toRow?: number): void {\n        Masonry.organizeItems(this, items, fromRow, toRow);\n    }\n\n    protected onScroll(): void {\n        this.addUntilFill();\n    }\n\n    protected onPageAdd(): void {\n        this.addUntilFill();\n    }\n\n    protected getFormatName(): string {\n        return 'format-masonry';\n    }\n\n    protected getEstimatedColumnsPerRow(): number {\n        return Math.ceil((this.width - this.options.gap) / (this.options.columnWidth + this.options.gap));\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        let ratio = 1.75; // ~16/9 - landscape format to minimum the height and maximize the prediction of the number of items\n\n        // Better prediction using ratio if provided\n        if (this.options.ratioLimit && this.options.ratioLimit.max) {\n            ratio = this.options.ratioLimit.max;\n        }\n\n        const columnWidth = this.getColumnWidth();\n        const estimatedImageHeight = columnWidth / ratio;\n        return Math.ceil(this.getGalleryVisibleHeight() / estimatedImageHeight);\n    }\n\n    /**\n     * Use current gallery height as reference. To fill free space it add images until the gallery height changes, then are one more row\n     */\n    protected addUntilFill(): void {\n        do {\n            this.addItemsToDom(1);\n        } while (this.viewportIsNotFilled() && this.domCollection.length < this.collection.length);\n    }\n\n    protected addItemToDOM(item: Item<Model>): void {\n        const shortestColumn = this.getShortestColumn();\n        shortestColumn.addItem(item);\n        super.addItemToDOM(item, shortestColumn.elementRef);\n    }\n\n    protected endResize(): void {\n        super.endResize();\n\n        if (!this.domCollection.length) {\n            return;\n        }\n\n        // Compute with new width. Rows indexes may have changed\n        this.domCollection.length = 0;\n        this.addColumns();\n        this.addUntilFill();\n    }\n\n    protected addColumns(): void {\n        this.bodyElementRef.innerHTML = '';\n        this.columns = [];\n        const columnWidth = this.getColumnWidth();\n        for (let i = 0; i < this.getEstimatedColumnsPerRow(); i++) {\n            const columnRef = new Column<Model>(this.document, {width: columnWidth, gap: this.options.gap});\n            this.columns.push(columnRef);\n            this.bodyElementRef.appendChild(columnRef.elementRef);\n        }\n    }\n\n    protected empty(): void {\n        super.empty();\n        this.addColumns();\n    }\n\n    /**\n     * Returns true if at least one column doesn't overflow on the bottom of the viewport\n     */\n    private viewportIsNotFilled(): boolean {\n        return this.columns.some(\n            c => c.elementRef.getBoundingClientRect().bottom < this.document.documentElement.clientHeight,\n        );\n    }\n\n    private addItemsToDom(nbItems: number) {\n        const nbVisibleImages = this.domCollection.length;\n\n        // Next row to add (first invisible row)\n        const firstIndex = this.domCollection.length ? nbVisibleImages : 0;\n        const lastWantedIndex = firstIndex + nbItems - 1;\n\n        // Compute size only for elements we're going to add\n        this.organizeItems(this.collection.slice(nbVisibleImages), firstIndex, lastWantedIndex);\n\n        for (let i = nbVisibleImages; i < this.collection.length; i++) {\n            const item = this.collection[i];\n            if (i <= lastWantedIndex) {\n                this.addItemToDOM(item);\n            } else {\n                break;\n            }\n        }\n\n        this.flushBufferedItems();\n        this.updateNextButtonVisibility();\n    }\n\n    /**\n     * Return square side size\n     */\n    private getColumnWidth(): number {\n        const itemsPerRow = this.getEstimatedColumnsPerRow();\n        return Math.floor((this.width - (itemsPerRow - 1) * this.options.gap) / itemsPerRow);\n    }\n\n    private getShortestColumn(): Column<Model> {\n        return this.columns.reduce((shortestColumn, column) => {\n            if (!shortestColumn) {\n                return column;\n            }\n\n            return column.height < shortestColumn.height ? column : shortestColumn;\n        });\n    }\n}\n","import {Item} from '../Item';\nimport {GalleryOptions, ModelAttributes} from './AbstractGallery';\nimport {AbstractRowGallery} from './AbstractRowGallery';\n\nexport interface SquareGalleryOptions extends GalleryOptions {\n    itemsPerRow: number;\n}\n\nexport class Square<Model extends ModelAttributes = ModelAttributes> extends AbstractRowGallery<Model> {\n    /**\n     * Options after having been defaulted\n     */\n    declare protected options: Required<SquareGalleryOptions>;\n\n    constructor(elementRef: HTMLElement, options: SquareGalleryOptions, scrollElementRef?: HTMLElement | null) {\n        super(elementRef, options, scrollElementRef);\n\n        if (!options.itemsPerRow || options.itemsPerRow <= 0) {\n            throw new Error('Option.itemsPerRow must be positive');\n        }\n    }\n\n    /**\n     * Compute sides with 1:1 ratio\n     */\n    public static organizeItems<T extends ModelAttributes>(\n        gallery: Square<T>,\n        items: Item<T>[],\n        firstRowIndex = 0,\n        toRow: number | null = null,\n    ): void {\n        const sideSize = gallery.getItemSideSize();\n        let lastIndex = toRow ? gallery.options.itemsPerRow * (toRow - firstRowIndex + 1) : items.length;\n        lastIndex = lastIndex > items.length ? items.length : lastIndex;\n\n        for (let i = 0; i < lastIndex; i++) {\n            const item = items[i];\n            item.width = Math.floor(sideSize);\n            item.height = Math.floor(sideSize);\n            item.cropped = true;\n            item.row = Math.floor(i / gallery.options.itemsPerRow) + firstRowIndex;\n            item.style();\n        }\n    }\n\n    public organizeItems(items: Item<Model>[], fromRow?: number, toRow?: number): void {\n        Square.organizeItems(this, items, fromRow, toRow);\n    }\n\n    protected getEstimatedColumnsPerRow(): number {\n        return this.options.itemsPerRow;\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        return Math.ceil(this.getGalleryVisibleHeight() / this.getItemSideSize());\n    }\n\n    /**\n     * Return square side size\n     */\n    protected getItemSideSize(): number {\n        const itemsPerRow = this.getEstimatedColumnsPerRow();\n        return (this.width - (itemsPerRow - 1) * this.options.gap) / itemsPerRow;\n    }\n\n    protected getFormatName(): string {\n        return 'format-square';\n    }\n}\n"],"mappings":"ycAAA,SAASA,EAASC,EAAMC,EAAY,CAAE,OAAAC,EAAQ,MAAAC,CAAM,EAAI,CAAC,EAAG,CACxD,IAAIC,EACAC,EAAc,KACZC,EAAUH,GAAS,MAAQA,EAAM,SAAS,SAAS,EACnDI,EAAWJ,GAAS,MAAQA,EAAM,SAAS,UAAU,EACrDK,EAAS,IAAM,CACbH,IAAgB,OAChBL,EAAK,MAAMI,EAAaC,CAAW,EACnCD,EAAc,OACdC,EAAc,KAEtB,EACMI,EAAa,IAAM,CACjBF,GACAC,EAAO,EAEXE,EAAO,CACX,EACIC,EAAY,KACVC,EAAW,IAAM,CACfD,GAAa,MACb,aAAaA,CAAS,EAE1BA,EAAY,WAAW,IAAM,CACzBA,EAAY,KACZF,EAAW,CACf,EAAGR,CAAU,CACjB,EACMY,EAAc,IAAM,CAClBF,IAAc,OACd,aAAaA,CAAS,EACtBA,EAAY,KAEpB,EACMD,EAAS,IAAM,CACjBG,EAAY,EACZT,EAAc,OACdC,EAAc,IAClB,EACMS,EAAQ,IAAM,CAChBD,EAAY,EACZL,EAAO,CACX,EACMO,EAAY,YAAaC,EAAM,CACjC,GAAId,GAAA,MAAAA,EAAQ,QACR,OAEJE,EAAc,KACdC,EAAcW,EACd,IAAMC,EAAcN,GAAa,KACjCC,EAAS,EACLN,GAAWW,GACXT,EAAO,CAEf,EACA,OAAAO,EAAU,SAAWH,EACrBG,EAAU,OAASL,EACnBK,EAAU,MAAQD,EAClBZ,GAAA,MAAAA,EAAQ,iBAAiB,QAASQ,EAAQ,CAAE,KAAM,EAAK,GAChDK,CACX,CC5DA,SAASG,EAAKC,EAAKC,EAAM,CACrB,IAAMC,EAAS,CAAC,EAChB,QAAS,EAAI,EAAG,EAAID,EAAK,OAAQ,IAAK,CAClC,IAAME,EAAMF,EAAK,CAAC,EACd,OAAO,OAAOD,EAAKG,CAAG,IACtBD,EAAOC,CAAG,EAAIH,EAAIG,CAAG,EAE7B,CACA,OAAOD,CACX,CCTA,SAASE,EAAcC,EAAQ,CAA/B,IAAAC,EAII,GAHI,OAAOD,GAAW,UAGlBA,GAAU,KACV,MAAO,GAEX,GAAI,OAAO,eAAeA,CAAM,IAAM,KAClC,MAAO,GAEX,GAAI,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAM,kBAAmB,CAC9D,IAAME,EAAMF,EAAO,OAAO,WAAW,EAKrC,OAJIE,GAAO,MAGW,GAACD,EAAA,OAAO,yBAAyBD,EAAQ,OAAO,WAAW,IAA1D,MAAAC,EAA6D,UAEzE,GAEJD,EAAO,SAAS,IAAM,WAAWE,CAAG,GAC/C,CACA,IAAIC,EAAQH,EACZ,KAAO,OAAO,eAAeG,CAAK,IAAM,MACpCA,EAAQ,OAAO,eAAeA,CAAK,EAEvC,OAAO,OAAO,eAAeH,CAAM,IAAMG,CAC7C,CCxBA,SAASC,EAAaC,KAAWC,EAAS,CACtCD,EAAS,OAAOA,CAAM,EACtB,QAASE,EAAI,EAAGA,EAAID,EAAQ,OAAQC,IAAK,CACrC,IAAMC,EAASF,EAAQC,CAAC,EACpBC,GAAU,MAEVC,EAAsBJ,EAAQG,EADhB,IAAI,OACyB,CAEnD,CACA,OAAOH,CACX,CACA,SAASI,EAAsBJ,EAAQG,EAAQE,EAAO,CAClD,QAAWC,KAAOH,EAAQ,CACtB,IAAMI,EAAcJ,EAAOG,CAAG,EACxBE,EAAcR,EAAOM,CAAG,EAE9B,GAAI,CADiB,OAAO,OAAON,EAAQM,CAAG,GACzBE,IAAgB,OACjC,GAAIH,EAAM,IAAIE,CAAW,EACrBP,EAAOM,CAAG,EAAID,EAAM,IAAIE,CAAW,UAE9BE,EAAcF,CAAW,EAAG,CACjC,IAAMG,EAAS,CAAC,EAChBL,EAAM,IAAIE,EAAaG,CAAM,EAC7BV,EAAOM,CAAG,EAAII,EACdN,EAAsBM,EAAQH,EAAaF,CAAK,CACpD,MAEIL,EAAOM,CAAG,EAAIC,UAGbE,EAAcD,CAAW,GAAKC,EAAcF,CAAW,EAAG,CAC/D,IAAMI,EAAUN,EAAM,IAAIE,CAAW,GACjC,CAACI,GAAYA,GAAWN,EAAM,IAAIE,CAAW,IAAMC,KACnDH,EAAM,IAAIE,EAAaC,CAAW,EAClCJ,EAAsBI,EAAaD,EAAaF,CAAK,EAE7D,CACJ,CACJ,CC/BO,SAASO,EAAcC,EAAWC,EAASC,EAAY,CAC5D,IAAMC,EAAKC,SAASL,cAAcE,CAAvB,EACX,OAAID,IACFG,EAAGH,UAAYA,GAEbE,GACFA,EAAWG,YAAYF,CAAvB,EAEKA,CACR,CAOM,SAASG,EAAeC,EAAIC,EAAI,CACrCD,OAAAA,EAAGE,EAAID,EAAGC,EACVF,EAAGG,EAAIF,EAAGE,EACNF,EAAGG,KAAOC,SACZL,EAAGI,GAAKH,EAAGG,IAENJ,CACR,CAKM,SAASM,GAAWC,EAAG,CAC5BA,EAAEL,EAAIM,KAAKC,MAAMF,EAAEL,CAAb,EACNK,EAAEJ,EAAIK,KAAKC,MAAMF,EAAEJ,CAAb,CACP,CASM,SAASO,EAAmBV,EAAIC,EAAI,CACzC,IAAMC,EAAIM,KAAKG,IAAIX,EAAGE,EAAID,EAAGC,CAAnB,EACJC,EAAIK,KAAKG,IAAIX,EAAGG,EAAIF,EAAGE,CAAnB,EACV,OAAOK,KAAKI,KAAMV,EAAIA,EAAMC,EAAIA,CAAzB,CACR,CASM,SAASU,EAAYb,EAAIC,EAAI,CAClC,OAAOD,EAAGE,IAAMD,EAAGC,GAAKF,EAAGG,IAAMF,EAAGE,CACrC,CAUM,SAASW,EAAMC,EAAKC,EAAKC,EAAK,CACnC,OAAOT,KAAKQ,IAAIR,KAAKS,IAAIF,EAAKC,CAAd,EAAoBC,CAA7B,CACR,CAUM,SAASC,EAAkBhB,EAAGC,EAAGgB,EAAO,CAC7C,IAAIC,EAAa,eAAclB,CAAE,MAAKC,GAAK,CAAE,QAE7C,OAAIgB,IAAUd,SACZe,GAAc,YAAWD,CAAM,IAAGA,CAAM,OAGnCC,CACR,CAUM,SAASC,EAAazB,EAAIM,EAAGC,EAAGgB,EAAO,CAC5CvB,EAAG0B,MAAMC,UAAYL,EAAkBhB,EAAGC,EAAGgB,CAAP,CACvC,CAED,IAAMK,GAAmB,2BAUlB,SAASC,GAAmB7B,EAAI8B,EAAMC,EAAUC,EAAM,CAI3DhC,EAAG0B,MAAMO,WAAaH,EACjB,GAAEA,CAAK,IAAGC,CAAS,MAAKC,GAAQJ,EAAiB,GAClD,MACL,CASM,SAASM,EAAelC,EAAImC,EAAGC,EAAG,CACvCpC,EAAG0B,MAAMW,MAAS,OAAOF,GAAM,SAAa,GAAEA,CAAE,KAAMA,EACtDnC,EAAG0B,MAAMY,OAAU,OAAOF,GAAM,SAAa,GAAEA,CAAE,KAAMA,CACxD,CAKM,SAASG,GAAsBvC,EAAI,CACxC6B,GAAmB7B,CAAD,CACnB,CAMM,SAASwC,GAAYC,EAAK,CAC/B,MAAI,WAAYA,EACPA,EAAIC,OAAJ,EAAaC,MAAM,IAAM,CAAA,CAAzB,EAGLF,EAAIG,SACCC,QAAQC,QAAQL,CAAhB,EAGF,IAAII,QAAQ,CAACC,EAASC,IAAW,CACtCN,EAAIO,OAAS,IAAMF,EAAQL,CAAD,EAC1BA,EAAIQ,QAAUF,CACf,CAHM,CAIR,CAIM,IAAMG,EAAa,CACxBC,KAAM,OACNC,QAAS,UACTC,OAAQ,SACRC,MAAO,OAJiB,EAenB,SAASC,GAAeC,EAAG,CAChC,MAAQ,WAAYA,GAAKA,EAAEC,SAAW,GAAMD,EAAEE,SAAWF,EAAEG,SAAWH,EAAEI,QAAUJ,EAAEK,QACrF,CAUM,SAASC,GAAsBC,EAAQC,EAAgBC,EAAShE,SAAU,CAE/E,IAAIiE,EAAW,CAAA,EAEf,GAAIH,aAAkBI,QACpBD,EAAW,CAACH,CAAD,UACFA,aAAkBK,UAAYC,MAAMC,QAAQP,CAAd,EACvCG,EAAWG,MAAME,KAAKR,CAAX,MACN,CACL,IAAMS,EAAW,OAAOT,GAAW,SAAWA,EAASC,EACnDQ,IACFN,EAAWG,MAAME,KAAKN,EAAOQ,iBAAiBD,CAAxB,CAAX,EAEd,CAED,OAAON,CACR,CAmBM,SAASQ,IAAW,CACzB,MAAO,CAAC,EAAEC,UAAUC,QAAUD,UAAUC,OAAOC,MAAM,QAAvB,EAC/B,CCtOD,IAAIC,GAAkB,GAEtB,GAAI,CAEFC,OAAOC,iBAAiB,OAAQ,KAAMC,OAAOC,eAAe,CAAA,EAAI,UAAW,CACzEC,IAAK,IAAM,CACTL,GAAkB,EACnB,CAHwE,CAArC,CAAtC,CAKD,OAAQtB,EAAG,CAAA,CAWZ,IAAM4B,EAAN,KAAgB,CACdC,aAAc,CAKZ,KAAKC,MAAQ,CAAA,CACd,CAUDC,IAAIC,EAAQC,EAAMC,EAAUC,EAAS,CACnC,KAAKC,gBAAgBJ,EAAQC,EAAMC,EAAUC,CAA7C,CACD,CAUDE,OAAOL,EAAQC,EAAMC,EAAUC,EAAS,CACtC,KAAKC,gBAAgBJ,EAAQC,EAAMC,EAAUC,EAAS,EAAtD,CACD,CAKDG,WAAY,CACV,KAAKR,MAAMS,QAASC,GAAa,CAC/B,KAAKJ,gBACHI,EAASR,OACTQ,EAASP,KACTO,EAASN,SACTM,EAASL,QACT,GACA,EANF,EADF,EAUA,KAAKL,MAAQ,CAAA,CACd,CAaDM,gBAAgBJ,EAAQC,EAAMC,EAAUC,EAASM,EAAQC,EAAU,CACjE,GAAI,CAACV,EACH,OAGF,IAAMW,EAAaF,EAAS,sBAAwB,mBACtCR,EAAKW,MAAM,GAAX,EACRL,QAASM,GAAU,CACvB,GAAIA,EAAO,CAGJH,IACCD,EAEF,KAAKX,MAAQ,KAAKA,MAAMgB,OAAQN,GACvBA,EAASP,OAASY,GACpBL,EAASN,WAAaA,GACtBM,EAASR,SAAWA,CAHd,EAOb,KAAKF,MAAMiB,KAAK,CACdf,OAAAA,EACAC,KAAMY,EACNX,SAAAA,EACAC,QAAAA,EAJF,GAWJ,IAAMa,EAAe1B,GAAkB,CAAEa,QAAUA,GAAW,EAAvB,EAAkC,GAEzEH,EAAOW,CAAD,EACJE,EACAX,EACAc,CAHF,CAKD,EAhCH,CAkCD,CAtGa,ECXT,SAASC,GAAgBC,EAASC,EAAM,CAC7C,GAAID,EAAQE,kBAAmB,CAC7B,IAAMC,EAAkBH,EAAQE,kBAAkBF,EAASC,CAAnC,EACxB,GAAIE,EACF,OAAOA,CAEV,CAED,MAAO,CACLvG,EAAGL,SAAS6G,gBAAgBC,YAM5BxG,EAAGwE,OAAOiC,YAEb,CAqCM,SAASC,EAAmBnF,EAAM4E,EAASQ,EAAcC,EAAUC,EAAO,CAC/E,IAAIC,EAAe,EAEnB,GAAIX,EAAQY,UACVD,EAAeX,EAAQY,UAAUJ,EAAcC,EAAUC,CAA1C,EAAiDtF,CAAjD,UACN4E,EAAQa,QACjBF,EAAeX,EAAQa,QAAQzF,CAAhB,MACV,CACL,IAAM0F,EAAiB,UAAY1F,EAAK,CAAD,EAAI2F,YAAR,EAAwB3F,EAAK4F,MAAM,CAAX,EAEvDhB,EAAQc,CAAD,IAETH,EAAeX,EAAQc,CAAD,EAEzB,CAED,OAAOG,OAAON,CAAD,GAAkB,CAChC,CASM,SAASO,GAAelB,EAASQ,EAAcC,EAAUC,EAAO,CACrE,MAAO,CACL9G,EAAG4G,EAAa5G,EACZ2G,EAAmB,OAAQP,EAASQ,EAAcC,EAAUC,CAA1C,EAClBH,EAAmB,QAASP,EAASQ,EAAcC,EAAUC,CAA3C,EACtB7G,EAAG2G,EAAa3G,EACZ0G,EAAmB,MAAOP,EAASQ,EAAcC,EAAUC,CAAzC,EAClBH,EAAmB,SAAUP,EAASQ,EAAcC,EAAUC,CAA5C,EAEzB,CCzFD,IAAMS,EAAN,KAAgB,CAIdxC,YAAYyC,EAAO,CACjB,KAAKA,MAAQA,EACb,KAAKC,cAAgB,EACrB,KAAKC,OAA8B,CAAE1H,EAAG,EAAGC,EAAG,GAC9C,KAAKc,IAA2B,CAAEf,EAAG,EAAGC,EAAG,GAC3C,KAAKa,IAA2B,CAAEd,EAAG,EAAGC,EAAG,EAC5C,CAOD0H,OAAOF,EAAe,CACpB,KAAKA,cAAgBA,EAEhB,KAAKD,MAAMzF,OAGd,KAAK6F,YAAY,GAAjB,EACA,KAAKA,YAAY,GAAjB,EACA,KAAKJ,MAAMnB,KAAKwB,SAAS,aAAc,CAAEL,MAAO,KAAKA,MAArD,GAJA,KAAKM,MAAL,CAMH,CAODF,YAAYG,EAAM,CAChB,GAAM,CAAE1B,KAAAA,CAAF,EAAW,KAAKmB,MAChBQ,EAAS,KAAKR,MAAMO,IAAS,IAAM,QAAU,QAApC,EAAgD,KAAKN,cAE9DR,EAAUN,EADIoB,IAAS,IAAM,OAAS,MAG1C1B,EAAKD,QACLC,EAAKO,aACL,KAAKY,MAAMS,KACX,KAAKT,MAAMV,KALqB,EAQ5BoB,EAAc,KAAKV,MAAMU,YAAYH,CAAvB,EAIpB,KAAKL,OAAOK,CAAZ,EAAoBzH,KAAKC,OAAO2H,EAAcF,GAAU,CAApC,EAAyCf,EAG7D,KAAKlG,IAAIgH,CAAT,EAAkBC,EAASE,EACvB5H,KAAKC,MAAM2H,EAAcF,CAAzB,EAAmCf,EACnC,KAAKS,OAAOK,CAAZ,EAGJ,KAAKjH,IAAIiH,CAAT,EAAkBC,EAASE,EACvBjB,EACA,KAAKS,OAAOK,CAAZ,CACL,CAGDD,OAAQ,CACN,KAAKJ,OAAO1H,EAAI,EAChB,KAAK0H,OAAOzH,EAAI,EAChB,KAAKc,IAAIf,EAAI,EACb,KAAKe,IAAId,EAAI,EACb,KAAKa,IAAId,EAAI,EACb,KAAKc,IAAIb,EAAI,CACd,CASDkI,WAAWJ,EAAMK,EAAW,CAC1B,OAAOxH,EAAMwH,EAAW,KAAKrH,IAAIgH,CAAT,EAAgB,KAAKjH,IAAIiH,CAAT,CAA5B,CACb,CAlFa,ECVVM,GAAkB,IAalBC,EAAN,KAAgB,CAOdvD,YAAYqB,EAASS,EAAUC,EAAOT,EAAM,CAC1C,KAAKA,KAAOA,EACZ,KAAKD,QAAUA,EACf,KAAKS,SAAWA,EAChB,KAAKC,MAAQA,EAEb,KAAKoB,YAAc,KAEnB,KAAKK,YAAc,KACnB,KAAKC,IAAM,EACX,KAAKC,KAAO,EACZ,KAAKC,MAAQ,EACb,KAAKC,QAAU,EACf,KAAKC,UAAY,EACjB,KAAK7H,IAAM,EACX,KAAKD,IAAM,CACZ,CAWD6G,OAAOkB,EAAUC,EAAWZ,EAAa,CAEvC,IAAMK,EAAc,CAAEvI,EAAG6I,EAAU5I,EAAG6I,GACtC,KAAKP,YAAcA,EACnB,KAAKL,YAAcA,EAEnB,IAAMa,EAASb,EAAYlI,EAAIuI,EAAYvI,EACrCgJ,EAASd,EAAYjI,EAAIsI,EAAYtI,EAE3C,KAAKuI,IAAMlI,KAAKQ,IAAI,EAAGiI,EAASC,EAASD,EAASC,CAAvC,EACX,KAAKP,KAAOnI,KAAKQ,IAAI,EAAGiI,EAASC,EAASD,EAASC,CAAvC,EAIZ,KAAKN,MAAQpI,KAAKQ,IAAI,EAAGkI,CAAZ,EAEb,KAAKL,QAAU,KAAKM,YAAL,EACf,KAAKL,UAAY,KAAKM,cAAL,EACjB,KAAKnI,IAAMT,KAAKS,IACd,KAAK4H,QACL,KAAKC,UACL,KAAKO,QAAL,CAHS,EAMX,KAAKrI,IAAMR,KAAKQ,IACd,KAAK0H,IACL,KAAKG,QACL,KAAKC,SAHI,EAMP,KAAKvC,MACP,KAAKA,KAAKwB,SAAS,mBAAoB,CAAEuB,WAAY,KAAMC,UAAW,KAAKxC,SAA3E,CAEH,CASDyC,sBAAsBC,EAAc,CAClC,IAAMC,EACJD,EAAe,YAEXE,EAAc,KAAKrD,QAAQoD,CAAb,EAEpB,GAAKC,EAIL,OAAI,OAAOA,GAAgB,WAClBA,EAAY,IAAD,EAGhBA,IAAgB,OACX,KAAKhB,KAGVgB,IAAgB,MACX,KAAKjB,IAGPnB,OAAOoC,CAAD,CACd,CAWDP,eAAgB,CACd,IAAIzB,EAAgB,KAAK6B,sBAAsB,WAA3B,EAEpB,OAAI7B,IAKJA,EAAgBnH,KAAKQ,IAAI,EAAG,KAAK0H,IAAM,CAAvB,EAEZ,KAAKD,aAAed,EAAgB,KAAKc,YAAYvI,EAAIqI,KAC3DZ,EAAgBY,GAAkB,KAAKE,YAAYvI,GAG9CyH,EACR,CAQDwB,aAAc,CACZ,OAAO,KAAKK,sBAAsB,SAA3B,GAAyC,KAAKd,GACtD,CAUDW,SAAU,CAGR,OAAO,KAAKG,sBAAsB,KAA3B,GAAqChJ,KAAKS,IAAI,EAAG,KAAKyH,IAAM,CAAvB,CAC7C,CArJa,ECuBVkB,EAAN,KAAY,CAMV3E,YAAYkD,EAAMnB,EAAOT,EAAM,CAC7B,KAAK4B,KAAOA,EACZ,KAAKnB,MAAQA,EACb,KAAKT,KAAOA,EACZ,KAAKsD,SAAY7C,IAAUT,EAAKuD,UAChC,KAAKC,kBAAoB,EAEzB,KAAK3B,YAAc,CAAElI,EAAG,EAAGC,EAAG,GAE9B,KAAK6J,IAAM,CAAE9J,EAAG,EAAGC,EAAG,GAEtB,KAAK8J,aAAgB,KAAKJ,UAAY,CAACtD,EAAK2D,OAAOC,OAEnD,KAAKb,WAAa,IAAId,EAAUjC,EAAKD,QAAS6B,EAAMnB,EAAOT,CAAzC,EAElB,KAAKA,KAAKwB,SAAS,cAAe,CAChCL,MAAO,KACPS,KAAM,KAAKA,KACXnB,MAAAA,EAHF,EAMA,KAAKoD,QAAU,KAAK7D,KAAK8D,cAAcC,kBAAkB,IAA1C,EACf,KAAKC,UAAY/K,EAAc,kBAAmB,KAApB,EAE9B,KAAKgL,cAAgB,KAErB,KAAK7C,cAAgB,EAErB,KAAK1F,MAAQ,KAAKmI,QAAQnI,MAE1B,KAAKC,OAAS,KAAKkI,QAAQlI,OAC3B,KAAKuI,cAAgB,GACrB,KAAKC,OAAS,IAAIjD,EAAU,IAAd,EAEd,KAAKkD,mBAAqB,GAC1B,KAAKC,oBAAsB,GAE3B,KAAKrE,KAAKwB,SAAS,YAAa,CAAEL,MAAO,KAAzC,CACD,CAODmD,YAAYhB,EAAU,CAChBA,GAAY,CAAC,KAAKA,SAEpB,KAAKiB,SAAL,EACS,CAACjB,GAAY,KAAKA,UAE3B,KAAKkB,WAAL,CAEH,CAODC,OAAOR,EAAe,CACpB,KAAKA,cAAgBA,EAErB,KAAKD,UAAUjJ,MAAM2J,gBAAkB,MAGlC,KAAK9C,OAIV,KAAK+C,cAAL,EAEA,KAAKC,KAAL,EACA,KAAKC,kBAAL,EACA,KAAKC,YAAL,EAEA,KAAKb,cAAc1K,YAAY,KAAKyK,SAApC,EAEA,KAAKe,oBAAL,EAEA,KAAK/E,KAAKwB,SAAS,eAAgB,CAAEL,MAAO,KAA5C,EAEA,KAAK6D,oBAAL,EAEA,KAAKhF,KAAKwB,SAAS,kBAAmB,CAAEL,MAAO,KAA/C,EAEI,KAAKmC,UACP,KAAKiB,SAAL,EAEH,CAEDK,MAAO,CACL,KAAKf,QAAQe,KAAK,EAAlB,EACA,KAAK5E,KAAKwB,SAAS,YAAa,CAAEL,MAAO,KAAzC,CACD,CAQD2D,aAAc,CACZ,GAAM,CAAE9E,KAAAA,CAAF,EAAW,KAIb,KAAKkE,eACF,CAAClE,EAAK2D,OAAOC,QACb5D,EAAKiF,WAAWC,UAAhB,GACC,CAAC,KAAK5B,UAAY,CANA,IAUtB,KAAKtD,KAAKwB,SAAS,cAAe,CAAEL,MAAO,KAA3C,EAAmDgE,mBAIvD,KAAKjB,cAAgB,GAErB,KAAKL,QAAQY,OAAb,EAEA,KAAKzE,KAAKwB,SAAS,qBAAsB,CAAEL,MAAO,KAAlD,EACD,CAQDoD,UAAW,CACT,KAAKjB,SAAW,GAChB,KAAKwB,YAAL,EACA,KAAKjB,QAAQU,SAAb,EACA,KAAKvE,KAAKwB,SAAS,gBAAiB,CAAEL,MAAO,KAA7C,CACD,CAODqD,YAAa,CACX,KAAKlB,SAAW,GAChB,KAAKO,QAAQW,WAAb,EAEI,KAAKpD,gBAAkB,KAAK2B,WAAWT,SAEzC,KAAKqC,cAAL,EAIF,KAAKnB,kBAAoB,EACzB,KAAKuB,oBAAL,EACA,KAAKC,oBAAL,EACA,KAAKH,kBAAL,EAEA,KAAK7E,KAAKwB,SAAS,kBAAmB,CAAEL,MAAO,KAA/C,CACD,CAMDiE,SAAU,CACR,KAAKvB,QAAQwB,SAAW,GACxB,KAAKxB,QAAQ3E,OAAb,EACA,KAAK8E,UAAU9E,OAAf,EACA,KAAKc,KAAKwB,SAAS,eAAgB,CAAEL,MAAO,KAA5C,CACD,CAEDmE,QAAS,CACH,KAAKlE,gBAAkB,KAAK2B,WAAWT,SAAW,CAAC,KAAKgB,UAK1D,KAAKqB,cAAL,EACA,KAAKnB,kBAAoB,EACzB,KAAKuB,oBAAL,EACA,KAAKC,oBAAL,EACA,KAAKH,kBAAL,IAGA,KAAKF,cAAL,EACA,KAAKR,OAAO7C,OAAO,KAAKF,aAAxB,EACA,KAAKmE,MAAM,KAAK9B,IAAI9J,EAAG,KAAK8J,IAAI7J,CAAhC,EAEH,CASDiL,kBAAkBW,EAAO,CAGvB,IAAMC,EAAkB,KAAKjC,mBAAqB,KAAKT,WAAWT,QAElE,GAAI,CAACmD,EACH,OAGF,IAAM/J,EAAQzB,KAAKC,MAAM,KAAKwB,MAAQ+J,CAAxB,GAA4C,KAAKzF,KAAKO,aAAa5G,EAC3EgC,EAAS1B,KAAKC,MAAM,KAAKyB,OAAS8J,CAAzB,GAA6C,KAAKzF,KAAKO,aAAa3G,EAE/E,CAAC,KAAK8L,YAAYhK,EAAOC,CAAxB,GAAmC,CAAC6J,GAGzC,KAAK3B,QAAQ8B,iBAAiBjK,EAAOC,CAArC,CACD,CAMD+J,YAAYhK,EAAOC,EAAQ,CACzB,OAAID,IAAU,KAAK0I,oBACZzI,IAAW,KAAK0I,qBACrB,KAAKD,mBAAqB1I,EAC1B,KAAK2I,oBAAsB1I,EACpB,IAGF,EACR,CAGDiK,uBAAwB,CAAA,IAAAC,EACtB,OAAAA,EAAO,KAAKhC,QAAQiC,eAApB,MAAAD,IAAA,OAAA,OAAOA,EAA0BE,OAClC,CAWDC,OAAOC,EAAeC,EAAaC,EAAoBC,EAAc,CACnE,GAAM,CAAEpG,KAAAA,CAAF,EAAW,KACjB,GAAI,CAAC,KAAKqG,WAAL,GACErG,EAAKiF,WAAWC,UAAhB,EACL,OAGFlF,EAAKwB,SAAS,eAAgB,CAC5ByE,cAAAA,EAAeC,YAAAA,EAAaC,mBAAAA,CADA,CAA9B,EAKAnG,EAAKsG,WAAWC,WAAhB,EAMA,IAAMC,EAAgB,KAAKpF,cAEtBgF,IACHH,EAAgB1L,EAAM0L,EAAe,KAAKlD,WAAWtI,IAAK,KAAKsI,WAAWrI,GAArD,GAOvB,KAAK+L,aAAaR,CAAlB,EACA,KAAKxC,IAAI9J,EAAI,KAAK+M,yBAAyB,IAAKR,EAAaM,CAAhD,EACb,KAAK/C,IAAI7J,EAAI,KAAK8M,yBAAyB,IAAKR,EAAaM,CAAhD,EACbzM,GAAW,KAAK0J,GAAN,EAEV,IAAMkD,EAAmB,IAAM,CAC7B,KAAKC,eAAeX,CAApB,EACA,KAAKjB,oBAAL,GAGGmB,EAGHnG,EAAKsG,WAAWO,gBAAgB,CAC9BC,MAAO,GACPC,KAAM,SACNlI,OAAQ,KAAKmF,UACbhJ,UAAW,KAAKgM,oBAAL,EACXC,WAAYN,EACZvL,SAAU+K,EACVe,OAAQlH,EAAKD,QAAQmH,OAPvB,EAFAP,EAAgB,CAYnB,CAKDQ,WAAWjB,EAAa,CACtB,KAAKF,OACH,KAAK5E,gBAAkB,KAAK2B,WAAWT,QACnC,KAAKS,WAAWR,UAAY,KAAKQ,WAAWT,QAChD4D,EACA,KAAKlG,KAAKD,QAAQqH,qBAJpB,CAMD,CAQDX,aAAarF,EAAe,CAC1B,KAAKA,cAAgBA,EACrB,KAAK+C,OAAO7C,OAAO,KAAKF,aAAxB,CACD,CAeDsF,yBAAyBhF,EAAM2F,EAAOb,EAAe,CAEnD,GADyB,KAAKrC,OAAOzJ,IAAIgH,CAAhB,EAAwB,KAAKyC,OAAO1J,IAAIiH,CAAhB,IACxB,EACvB,OAAO,KAAKyC,OAAO9C,OAAOK,CAAnB,EAGJ2F,IACHA,EAAQ,KAAKrH,KAAKsH,uBAAV,GAGLd,IACHA,EAAgB,KAAKzD,WAAWT,SAGlC,IAAMiF,EAAa,KAAKnG,cAAgBoF,EACxC,OAAO,KAAKrC,OAAOrC,WACjBJ,GACC,KAAK+B,IAAI/B,CAAT,EAAiB2F,EAAM3F,CAAD,GAAU6F,EAAaF,EAAM3F,CAAD,CAF9C,CAIR,CAQD6D,MAAMiC,EAAMC,EAAM,CAChB,KAAKhE,IAAI9J,EAAI,KAAKwK,OAAOrC,WAAW,IAAK0F,CAA5B,EACb,KAAK/D,IAAI7J,EAAI,KAAKuK,OAAOrC,WAAW,IAAK2F,CAA5B,EACb,KAAKzC,oBAAL,CACD,CAMD0C,YAAa,CACX,MAAOC,EAAQ,KAAKjM,OAAW,KAAK0F,cAAgB,KAAK2B,WAAWZ,GACrE,CAMDkE,YAAa,CACX,MAAOsB,EAAQ,KAAKjM,OAAU,KAAKmI,QAAQwC,WAAb,CAC/B,CAMDrB,qBAAsB,CACpB,KAAK4C,oBAAoB,KAAKnE,IAAI9J,EAAG,KAAK8J,IAAI7J,EAAG,KAAKwH,aAAtD,EACI,OAAS,KAAKpB,KAAK6H,WACrB,KAAK7H,KAAKwB,SAAS,gBAAiB,CAAEL,MAAO,KAA7C,CAEH,CAED4D,qBAAsB,CACpB,KAAK3D,cAAgB,KAAK2B,WAAWT,QAGrC,KAAK6B,OAAO7C,OAAO,KAAKF,aAAxB,EACA5H,EAAe,KAAKiK,IAAK,KAAKU,OAAO9C,MAAvB,EACd,KAAKrB,KAAKwB,SAAS,iBAAkB,CAAEL,MAAO,KAA9C,CACD,CAUDyG,oBAAoBjO,EAAGC,EAAGkO,EAAM,CAC9BA,GAAQ,KAAKtE,mBAAqB,KAAKT,WAAWT,QAClDxH,EAAa,KAAKkJ,UAAWrK,EAAGC,EAAGkO,CAAvB,CACb,CAEDnD,eAAgB,CACd,GAAM,CAAE3E,KAAAA,CAAF,EAAW,KAEjBxG,EACE,KAAKqI,YACLZ,GAAejB,EAAKD,QAASC,EAAKO,aAAc,KAAKqB,KAAM,KAAKnB,KAAlD,CAFF,EAKd,KAAKsC,WAAWzB,OAAO,KAAK5F,MAAO,KAAKC,OAAQ,KAAKkG,WAArD,EAEA7B,EAAKwB,SAAS,gBAAiB,CAC7BL,MAAO,KADT,CAGD,CAGD6F,qBAAsB,CACpB,IAAMpM,EAAQ,KAAKwG,eAAiB,KAAKoC,mBAAqB,KAAKT,WAAWT,SAC9E,OAAO3H,EAAkB,KAAK8I,IAAI9J,EAAG,KAAK8J,IAAI7J,EAAGgB,CAAzB,CACzB,CAiBDgM,eAAemB,EAAe,CACxBA,IAAkB,KAAKvE,oBAI3B,KAAKA,kBAAoBuE,EACzB,KAAKlD,kBAAL,EAEA,KAAK7E,KAAKwB,SAAS,mBAAnB,EACD,CAndS,EC7BNwG,GAAmB,IACnBC,GAAyB,GAGzBC,GAAqB,GAIrBC,GAAuB,GAO7B,SAASC,GAAQC,EAAiBC,EAAkB,CAClD,OAAOD,EAAkBC,GAAoB,EAAIA,EAClD,CAKD,IAAMC,EAAN,KAAkB,CAIhB7J,YAAY8J,EAAU,CACpB,KAAKA,SAAWA,EAChB,KAAKxI,KAAOwI,EAASxI,KAErB,KAAKyI,SAAW,CAAE9O,EAAG,EAAGC,EAAG,EAC5B,CAED8O,OAAQ,CACF,KAAK1I,KAAK6H,WACZrO,EAAe,KAAKiP,SAAU,KAAKzI,KAAK6H,UAAUpE,GAApC,EAEhB,KAAKzD,KAAKsG,WAAWqC,QAArB,CACD,CAEDC,QAAS,CACP,GAAM,CAAEnP,GAAAA,EAAIoP,OAAAA,EAAQC,SAAAA,CAAd,EAA2B,KAAKN,SAChC,CAAEX,UAAAA,CAAF,EAAgB,KAAK7H,KAE3B,GAAI8I,IAAa,KACV,KAAK9I,KAAKD,QAAQgJ,qBACjBlB,GAAaA,EAAUzG,eAAiByG,EAAU9E,WAAWZ,KAC9D,CAAC,KAAKqG,SAASQ,aAAc,CAElC,IAAMvB,EAAOI,EAAUpE,IAAI7J,GAAKH,EAAGG,EAAIiP,EAAOjP,GAC9C,GAAI,CAAC,KAAKoG,KAAKwB,SAAS,eAAgB,CAAEiG,KAAAA,EAArC,EAA6CtC,iBAAkB,CAClE,KAAK8D,oBAAoB,IAAKxB,EAAMQ,EAApC,EACA,IAAMiB,EAAY,EAAIjP,KAAKG,IAAI,KAAK+O,sBAAsBtB,EAAUpE,IAAI7J,CAAzC,CAAT,EACtB,KAAKoG,KAAKoJ,eAAeF,CAAzB,EACArB,EAAU7C,oBAAV,CACD,CACF,MAC2B,KAAKqE,qBAAqB,GAA1B,IAExB,KAAKA,qBAAqB,GAA1B,EAEIxB,IACF9N,GAAW8N,EAAUpE,GAAX,EACVoE,EAAU7C,oBAAV,GAIP,CAEDsE,KAAM,CACJ,GAAM,CAAEC,SAAAA,CAAF,EAAe,KAAKf,SACpB,CAAEvD,WAAAA,EAAY4C,UAAAA,CAAd,EAA4B,KAAK7H,KACnCwJ,EAAY,EAKhB,GAHA,KAAKxJ,KAAKsG,WAAWqC,QAArB,EAGI1D,EAAWC,UAAX,EAAwB,CAQ1B,IAAMuE,GANsBxE,EAAWtL,EAAIsL,EAAWyE,cAAX,GAMgB,KAAK1J,KAAKO,aAAa5G,EAU7E4P,EAAS5P,EAAI,CAACwO,IAAwBsB,EAA8B,GACjEF,EAAS5P,EAAI,IAAO8P,EAA8B,KAExDD,EAAY,EACZD,EAAS5P,EAAIM,KAAKQ,IAAI8O,EAAS5P,EAAG,CAArB,IACH4P,EAAS5P,EAAIwO,IAAwBsB,EAA8B,GACvEF,EAAS5P,EAAI,KAAQ8P,EAA8B,MAEzDD,EAAY,GACZD,EAAS5P,EAAIM,KAAKS,IAAI6O,EAAS5P,EAAG,CAArB,GAGfsL,EAAW0E,YAAYH,EAAW,GAAMD,EAAS5P,CAAjD,CACD,CAGIkO,GAAaA,EAAUzG,cAAgByG,EAAU9E,WAAWrI,KAC1D,KAAK8N,SAASQ,aACnB,KAAKR,SAASzF,WAAW6G,eAAe,EAAxC,GAMA,KAAKC,yBAAyB,GAA9B,EACA,KAAKA,yBAAyB,GAA9B,EAEH,CAMDA,yBAAyBnI,EAAM,CAC7B,GAAM,CAAE6H,SAAAA,CAAF,EAAe,KAAKf,SACpB,CAAEX,UAAAA,CAAF,EAAgB,KAAK7H,KAE3B,GAAI,CAAC6H,EACH,OAGF,GAAM,CAAEpE,IAAAA,EAAKU,OAAAA,CAAP,EAAkB0D,EAClBiC,EAASrG,EAAI/B,CAAD,EACZqI,EAAoB,KAAK/J,KAAKkJ,UAAY,GAAKxH,IAAS,IAOxDsI,EAAoBF,EAAS1B,GAAQmB,EAAS7H,CAAD,EAH1B,IAGiB,EAE1C,GAAIqI,EAAkB,CACpB,IAAME,EAAa,KAAKd,sBAAsBW,CAA3B,EACbI,EAAsB,KAAKf,sBAAsBa,CAA3B,EAI5B,GAAKC,EAAa,GAAKC,EAAsB,CAAChC,IACtC+B,EAAa,GAAKC,EAAsBhC,GAAqB,CACnE,KAAKlI,KAAKmK,MAAV,EACA,MACD,CACF,CAGD,IAAMC,EAAuBjG,EAAOrC,WAAWJ,EAAMsI,CAAxB,EAI7B,GAAIF,IAAWM,EACb,OAIF,IAAMC,EAAgBD,IAAyBJ,EAAqB,EAAI,IAElEM,EAAmB,KAAKtK,KAAKkJ,UAC7BqB,EAAeH,EAAuBN,EAE5C,KAAK9J,KAAKsG,WAAWkE,YAAY,CAC/BzD,KAAM,aAAerF,EACrBoF,MAAO,GACP4B,MAAOoB,EACPR,IAAKc,EACLb,SAAUA,EAAS7H,CAAD,EAClB2I,aAAAA,EACAI,SAAWC,GAAQ,CAEjB,GAAIX,GAAoB,KAAK/J,KAAKkJ,UAAY,EAAG,CAE/C,IAAMyB,EAAyB,GAAKP,EAAuBM,GAAOH,EAKlE,KAAKvK,KAAKoJ,eAAe7O,EACvB+P,GAAoB,EAAIA,GAAoBK,EAC5C,EACA,CAH4B,CAA9B,CAKD,CAEDlH,EAAI/B,CAAD,EAASzH,KAAK2Q,MAAMF,CAAX,EACZ7C,EAAU7C,oBAAV,CACD,EAzBH,CA2BD,CAYDqE,qBAAqB3H,EAAM,CACzB,GAAM,CAAEjI,GAAAA,EAAIqP,SAAAA,EAAUD,OAAAA,EAAQG,aAAAA,CAAxB,EAAyC,KAAKR,SAC9C,CAAEX,UAAAA,EAAW5C,WAAAA,CAAb,EAA4B,KAAKjF,KACjC6K,EAASpR,EAAGiI,CAAD,EAASmH,EAAOnH,CAAD,EAC1BoJ,EAAiB7F,EAAWtL,EAAIkR,EAEtC,GAAI,CAACA,GAAS,CAAChD,EACb,MAAO,GAIT,GAAInG,IAAS,KAAO,CAACmG,EAAUH,WAAV,GAA0B,CAACsB,EAC9C/D,OAAAA,EAAW8F,OAAOD,EAAgB,EAAlC,EACO,GAGT,GAAM,CAAE3G,OAAAA,CAAF,EAAa0D,EACbmD,EAASnD,EAAUpE,IAAI/B,CAAd,EAAsBmJ,EAErC,GAAI,KAAK7K,KAAKD,QAAQkL,gBACfnC,IAAa,KACbpH,IAAS,KACT,CAACsH,EAAc,CACpB,IAAMkC,EAAuBjG,EAAWyE,cAAX,EAGvByB,EAAsBlG,EAAWtL,EAAIuR,EAErCE,EAAgBP,EAAQ,EACxBQ,EAAgB,CAACD,EAEvB,GAAIJ,EAAS7G,EAAO1J,IAAIiH,CAAX,GAAoB0J,EAAe,CAQ9C,GAF6BjH,EAAO1J,IAAIiH,CAAX,GAAoB,KAAK+G,SAAS/G,CAAd,EAG/CuD,OAAAA,EAAW8F,OAAOD,EAAgB,EAAlC,EACO,GAEP,KAAK7B,oBAAoBvH,EAAMsJ,CAA/B,CAGH,SAAUA,EAAS7G,EAAOzJ,IAAIgH,CAAX,GAAoB2J,EAAe,CAMrD,GAF6B,KAAK5C,SAAS/G,CAAd,GAAuByC,EAAOzJ,IAAIgH,CAAX,EAGlDuD,OAAAA,EAAW8F,OAAOD,EAAgB,EAAlC,EACO,GAEP,KAAK7B,oBAAoBvH,EAAMsJ,CAA/B,CAGH,SAEKG,IAAwB,EAAG,CAE7B,GAAIA,EAAsB,EACxBlG,OAAAA,EAAW8F,OAAO9Q,KAAKS,IAAIoQ,EAAgBI,CAAzB,EAAgD,EAAlE,EACO,GACF,GAAIC,EAAsB,EAE/BlG,OAAAA,EAAW8F,OAAO9Q,KAAKQ,IAAIqQ,EAAgBI,CAAzB,EAAgD,EAAlE,EACO,EAEV,MAEC,KAAKjC,oBAAoBvH,EAAMsJ,CAA/B,CAGL,MACKtJ,IAAS,IAEP,CAACuD,EAAWC,UAAX,GAA0Bf,EAAO1J,IAAIb,IAAMuK,EAAOzJ,IAAId,GACzD,KAAKqP,oBAAoBvH,EAAMsJ,CAA/B,EAGF,KAAK/B,oBAAoBvH,EAAMsJ,CAA/B,EAIJ,MAAO,EACR,CAgBD7B,sBAAsB1B,EAAM,CAAA,IAAA6D,EAAAC,EAC1B,OAAQ9D,IAAI6D,GAAAC,EAAI,KAAKvL,KAAK6H,aAAV,MAAA0D,IAAA,OAAA,OAAAA,EAAqBpH,OAAO9C,OAAOzH,KAAK,MAAA0R,IAAA,OAAAA,EAAA,KAAO,KAAKtL,KAAKO,aAAa3G,EAAI,EAC3F,CAYDqP,oBAAoBvH,EAAM8J,EAAcC,EAAgB,CACtD,GAAM,CAAE5D,UAAAA,CAAF,EAAgB,KAAK7H,KAE3B,GAAI,CAAC6H,EACH,OAGF,GAAM,CAAEpE,IAAAA,EAAKU,OAAAA,CAAP,EAAkB0D,EAGxB,GAFqB1D,EAAOrC,WAAWJ,EAAM8J,CAAxB,IAEAA,GAAgBC,EAAgB,CACnD,IAAMZ,EAAQ5Q,KAAKC,MAAMsR,EAAe/H,EAAI/B,CAAD,CAA7B,EACd+B,EAAI/B,CAAD,GAAUmJ,GAASY,GAAkBzD,GACzC,MACCvE,EAAI/B,CAAD,EAAS8J,CAEf,CAtUe,ECtBZE,GAAsB,IACtBC,GAAsB,IAW5B,SAASC,GAAoB5R,EAAGP,EAAIC,EAAI,CACtCM,OAAAA,EAAEL,GAAKF,EAAGE,EAAID,EAAGC,GAAK,EACtBK,EAAEJ,GAAKH,EAAGG,EAAIF,EAAGE,GAAK,EACfI,CACR,CAED,IAAM6R,EAAN,KAAkB,CAIhBnN,YAAY8J,EAAU,CACpB,KAAKA,SAAWA,EAKhB,KAAKsD,UAAY,CAAEnS,EAAG,EAAGC,EAAG,GAK5B,KAAKmS,gBAAkB,CAAEpS,EAAG,EAAGC,EAAG,GAKlC,KAAKoS,WAAa,CAAErS,EAAG,EAAGC,EAAG,GAE7B,KAAKqS,qBAAuB,GAE5B,KAAKC,gBAAkB,CACxB,CAEDxD,OAAQ,CACN,GAAM,CAAEb,UAAAA,GAAc,KAAKW,SAASxI,KAChC6H,IACF,KAAKqE,gBAAkBrE,EAAUzG,cACjC5H,EAAe,KAAKsS,UAAWjE,EAAUpE,GAA3B,GAGhB,KAAK+E,SAASxI,KAAKsG,WAAWC,WAA9B,EACA,KAAK0F,qBAAuB,EAC7B,CAEDrD,QAAS,CACP,GAAM,CAAEnP,GAAAA,EAAI0S,QAAAA,EAASzS,GAAAA,EAAI0S,QAAAA,EAASpM,KAAAA,CAA5B,EAAqC,KAAKwI,SAC1C,CAAEX,UAAAA,CAAF,EAAgB7H,EAEtB,GAAI,CAAC6H,EACH,OAGF,IAAMwE,EAAexE,EAAU9E,WAAWtI,IACpC6R,EAAezE,EAAU9E,WAAWrI,IAE1C,GAAI,CAACmN,EAAUxB,WAAV,GAA0BrG,EAAKiF,WAAWC,UAAhB,EAC7B,OAGF0G,GAAoB,KAAKG,gBAAiBI,EAASC,CAAhC,EACnBR,GAAoB,KAAKI,WAAYvS,EAAIC,CAAtB,EAEnB,IAAI0H,EAAiB,EAAIjH,EAAmBgS,EAASC,CAAV,EACvBjS,EAAmBV,EAAIC,CAAL,EAClB,KAAKwS,gBAOzB,GAJI9K,EAAgByG,EAAU9E,WAAWT,QAAWuF,EAAU9E,WAAWT,QAAU,KACjF,KAAK2J,qBAAuB,IAG1B7K,EAAgBiL,EAClB,GAAIrM,EAAKD,QAAQwM,cACV,CAAC,KAAKN,sBACN,KAAKC,iBAAmBrE,EAAU9E,WAAWT,QAAS,CAE3D,IAAM4G,EAAY,GAAMmD,EAAejL,IAAkBiL,EAAe,KACnErM,EAAKwB,SAAS,aAAc,CAAE0H,UAAAA,EAA9B,EAA2C/D,kBAC9CnF,EAAKoJ,eAAeF,CAApB,CAEH,MAEC9H,EAAgBiL,GAAgBA,EAAejL,GAAiBuK,QAEzDvK,EAAgBkL,IAEzBlL,EAAgBkL,GAAgBlL,EAAgBkL,GAAgBZ,IAGlE7D,EAAUpE,IAAI9J,EAAI,KAAK6S,0BAA0B,IAAKpL,CAApC,EAClByG,EAAUpE,IAAI7J,EAAI,KAAK4S,0BAA0B,IAAKpL,CAApC,EAElByG,EAAUpB,aAAarF,CAAvB,EACAyG,EAAU7C,oBAAV,CACD,CAEDsE,KAAM,CACJ,GAAM,CAAEtJ,KAAAA,CAAF,EAAW,KAAKwI,SAChB,CAAEX,UAAAA,CAAF,EAAgB7H,GACjB,CAAC6H,GAAaA,EAAUzG,cAAgByG,EAAU9E,WAAWT,UAC3D,CAAC,KAAK2J,sBACNjM,EAAKD,QAAQwM,aAClBvM,EAAKmK,MAAL,EAEA,KAAKP,eAAL,CAEH,CAQD4C,0BAA0B9K,EAAMN,EAAe,CAC7C,IAAMmG,EAAanG,EAAgB,KAAK8K,gBACxC,OAAO,KAAKF,WAAWtK,CAAhB,GACK,KAAKqK,gBAAgBrK,CAArB,EAA6B,KAAKoK,UAAUpK,CAAf,GAAwB6F,CAClE,CAUDqC,eAAe6C,EAAe,CAC5B,GAAM,CAAEzM,KAAAA,CAAF,EAAW,KAAKwI,SAChB,CAAEX,UAAAA,CAAF,EAAgB7H,EAEtB,GAAI,EAAC6H,GAAD,MAACA,EAAWxB,WAAX,GACH,OAGE,KAAK2F,WAAWrS,IAAM,IACxB8S,EAAgB,IAGlB,IAAMjG,EAAgBqB,EAAUzG,cAG5BsL,EACAC,EAA2B,GAE3BnG,EAAgBqB,EAAU9E,WAAWT,QACvCoK,EAAuB7E,EAAU9E,WAAWT,QAEnCkE,EAAgBqB,EAAU9E,WAAWrI,IAC9CgS,EAAuB7E,EAAU9E,WAAWrI,KAG5CiS,EAA2B,GAC3BD,EAAuBlG,GAGzB,IAAM8D,EAAmBtK,EAAKkJ,UACxBa,EAAmB/J,EAAKkJ,UAAY,EAEpC0D,EAAapT,EAAe,CAAEG,EAAG,EAAGC,EAAG,CAAX,EAAgBiO,EAAUpE,GAA3B,EAC7BoJ,EAAiBrT,EAAe,CAAEG,EAAG,EAAGC,EAAG,GAAKgT,CAAjB,EAE/BH,IACF,KAAKT,WAAWrS,EAAI,EACpB,KAAKqS,WAAWpS,EAAI,EACpB,KAAKmS,gBAAgBpS,EAAI,EACzB,KAAKoS,gBAAgBnS,EAAI,EACzB,KAAKsS,gBAAkB1F,EACvBhN,EAAe,KAAKsS,UAAWc,CAAjB,GAGZD,IACFE,EAAiB,CACflT,EAAG,KAAK6S,0BAA0B,IAAKE,CAApC,EACH9S,EAAG,KAAK4S,0BAA0B,IAAKE,CAApC,IAKP7E,EAAUpB,aAAaiG,CAAvB,EAEAG,EAAiB,CACflT,EAAGkO,EAAU1D,OAAOrC,WAAW,IAAK+K,EAAelT,CAAhD,EACHC,EAAGiO,EAAU1D,OAAOrC,WAAW,IAAK+K,EAAejT,CAAhD,CAFY,EAMjBiO,EAAUpB,aAAaD,CAAvB,EAEA,IAAMsG,EAAiB,CAACxS,EAAYuS,EAAgBD,CAAjB,EAEnC,GAAI,CAACE,GAAkB,CAACH,GAA4B,CAAC5C,EAAkB,CAErElC,EAAUjB,eAAe8F,CAAzB,EACA7E,EAAU7C,oBAAV,EAGA,MACD,CAEDhF,EAAKsG,WAAWC,WAAhB,EAEAvG,EAAKsG,WAAWkE,YAAY,CAC1B1D,MAAO,GACP4B,MAAO,EACPY,IAAK,IACLC,SAAU,EACVc,aAAc,EACd0C,iBAAkB,GAClBtC,SAAWuC,GAAQ,CAGjB,GAFAA,GAAO,IAEHF,GAAkBH,EAA0B,CAM9C,GALIG,IACFjF,EAAUpE,IAAI9J,EAAIiT,EAAWjT,GAAKkT,EAAelT,EAAIiT,EAAWjT,GAAKqT,EACrEnF,EAAUpE,IAAI7J,EAAIgT,EAAWhT,GAAKiT,EAAejT,EAAIgT,EAAWhT,GAAKoT,GAGnEL,EAA0B,CAC5B,IAAMM,EAAezG,GACNkG,EAAuBlG,GAAiBwG,EACvDnF,EAAUpB,aAAawG,CAAvB,CACD,CAEDpF,EAAU7C,oBAAV,CACD,CAGG+E,GAAoB/J,EAAKkJ,UAAY,GAIvClJ,EAAKoJ,eAAe7O,EAClB+P,GAAoB,EAAIA,GAAoB0C,EAAK,EAAG,CAD7B,CAAzB,GAKJ/F,WAAY,IAAM,CAEhBY,EAAUjB,eAAe8F,CAAzB,EACA7E,EAAU7C,oBAAV,CACD,EAvCH,CAyCD,CA9Oe,ECPlB,SAASkI,GAAoBC,EAAO,CAClC,MAAO,CAAC,CAA8BA,EAAMtO,OAAQuO,QAAQ,kBAAvB,CACtC,CAKD,IAAMC,GAAN,KAAiB,CAIf3O,YAAY8J,EAAU,CACpB,KAAKA,SAAWA,CACjB,CAMD8E,MAAMjG,EAAOkG,EAAe,CAC1B,IAAMC,EAA8CD,EAAc1O,OAAQ4O,UACpEC,EAAeF,EAAgBG,SAAS,WAAzB,EACfC,EAAoBJ,EAAgBG,SAAS,YAAzB,GACGH,EAAgBG,SAAS,iBAAzB,EAEzBD,EACF,KAAKG,oBAAoB,aAAcxG,EAAOkG,CAA9C,EACSK,GACT,KAAKC,oBAAoB,UAAWxG,EAAOkG,CAA3C,CAEH,CAMDO,IAAIzG,EAAOkG,EAAe,CACpBL,GAAoBK,CAAD,GACrB,KAAKM,oBAAoB,MAAOxG,EAAOkG,CAAvC,CAEH,CAMDQ,UAAU1G,EAAOkG,EAAe,CAC1BL,GAAoBK,CAAD,GACrB,KAAKM,oBAAoB,YAAaxG,EAAOkG,CAA7C,CAEH,CAQDM,oBAAoBG,EAAY3G,EAAOkG,EAAe,CAAA,IAAAU,EACpD,GAAM,CAAEjO,KAAAA,CAAF,EAAW,KAAKwI,SAChB,CAAEX,UAAAA,CAAF,EAAgB7H,EAChBkO,EAA+DF,EAAa,SAC5E5K,EAAcpD,EAAKD,QAAQmO,CAAb,EAEpB,GAAIlO,CAAAA,EAAKwB,SAAS0M,EAAgB,CAAE7G,MAAAA,EAAOkG,cAAAA,EAAvC,EAAwDpI,iBAI5D,IAAI,OAAO/B,GAAgB,WAAY,CACrCA,EAAY+K,KAAKnO,EAAMqH,EAAOkG,CAA9B,EACA,MACD,CAED,OAAQnK,EAAR,CACE,IAAK,QACL,IAAK,OACHpD,EAAKoD,CAAD,EAAJ,EACA,MACF,IAAK,OACHyE,GAAS,MAATA,EAAWV,WAAWE,CAAtB,EACA,MACF,IAAK,gBAGCQ,GAAS,MAATA,EAAWxB,WAAX,GACGwB,EAAU9E,WAAWR,YAAcsF,EAAU9E,WAAWT,QAC7DuF,EAAUV,WAAWE,CAArB,EACSrH,EAAKD,QAAQqO,yBACtBpO,EAAKmK,MAAL,EAEF,MACF,IAAK,mBACH8D,EAAA,KAAKzF,SAASxI,KAAK+F,WAAnB,MAAAkI,IAAA,QAAAA,EAA4BR,UAAUY,OAAO,kBAA7C,EAMA,KAzBJ,EA2BD,CA7Fc,ECZXC,GAAwB,GAGxBC,GAAmB,IACnBC,GAAmB,GASnBC,GAAN,KAAe,CAIb/P,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EAGZ,KAAK8I,SAAW,KAKhB,KAAKrP,GAAK,CAAEE,EAAG,EAAGC,EAAG,CAAX,EAEV,KAAKF,GAAK,CAAEC,EAAG,EAAGC,EAAG,CAAX,EAEV,KAAKiP,OAAS,CAAElP,EAAG,EAAGC,EAAG,GAEzB,KAAK8U,OAAS,CAAE/U,EAAG,EAAGC,EAAG,GAEzB,KAAKuS,QAAU,CAAExS,EAAG,EAAGC,EAAG,GAE1B,KAAKwS,QAAU,CAAEzS,EAAG,EAAGC,EAAG,GAE1B,KAAK2P,SAAW,CAAE5P,EAAG,EAAGC,EAAG,GAK3B,KAAK+U,aAAe,CAAEhV,EAAG,EAAGC,EAAG,GAI/B,KAAKgV,YAAc,CAAEjV,EAAG,EAAGC,EAAG,GAE9B,KAAKiV,iBAAmB,EAIxB,KAAKC,iBAAmB,CAAA,EAExB,KAAKC,mBAAqB,iBAAkB3Q,OAE5C,KAAK4Q,qBAAuB,CAAC,CAAE5Q,OAAO6Q,aACtC,KAAKC,cAAgB,KAAKH,oBACA,KAAKC,sBAAwBhR,UAAUmR,eAAiB,EAElF,KAAKN,iBAAmB,EAExB,KAAKO,cAAgB,EAErB,KAAKC,oBAAsB,GAC3B,KAAKrG,aAAe,GACpB,KAAKsG,WAAa,GAClB,KAAKC,UAAY,GAEjB,KAAKC,IAAM,KAIX,KAAKC,UAAY,KAEZ,KAAKP,gBAERlP,EAAKD,QAAQkL,eAAiB,IAGhC,KAAKyE,KAAO,IAAInH,EAAY,IAAhB,EACZ,KAAKxF,WAAa,IAAI8I,EAAY,IAAhB,EAClB,KAAK8D,WAAa,IAAItC,GAAW,IAAf,EAElBrN,EAAK4P,GAAG,aAAc,IAAM,CAC1B5P,EAAK6P,OAAOjR,IACVoB,EAAK8P,WACL,QAC2B,KAAKC,SAASC,KAAK,IAAnB,CAH7B,EAMI,KAAKhB,qBACP,KAAKiB,YAAY,UAAW,OAAQ,KAAM,QAA1C,EACS,KAAKlB,oBACd,KAAKkB,YAAY,QAAS,QAAS,MAAO,QAA1C,EAUIjQ,EAAK8P,aACP9P,EAAK8P,WAAWI,YAAc,IAAM,CAAA,EACpClQ,EAAK8P,WAAWK,WAAa,IAAM,CAAA,IAGrC,KAAKF,YAAY,QAAS,OAAQ,IAAlC,EAzBJ,CA4BD,CASDA,YAAYG,EAAMC,EAAMC,EAAIC,EAAQ,CAClC,GAAM,CAAEvQ,KAAAA,CAAF,EAAW,KACX,CAAE6P,OAAAA,CAAF,EAAa7P,EAEbwQ,EAAcD,EAASH,EAAOG,EAAS,GAE7CV,EAAOjR,IACLoB,EAAK8P,WACLM,EAAOC,EACoB,KAAKI,cAAcT,KAAK,IAAxB,CAH7B,EAKAH,EAAOjR,IAAIR,OAAQgS,EAAO,OAAmC,KAAKM,cAAcV,KAAK,IAAxB,CAA7D,EACAH,EAAOjR,IAAIR,OAAQgS,EAAOE,EAA+B,KAAKK,YAAYX,KAAK,IAAtB,CAAzD,EACIQ,GACFX,EAAOjR,IACLoB,EAAK8P,WACLU,EAC2B,KAAKG,YAAYX,KAAK,IAAtB,CAH7B,CAMH,CAKDS,cAAc5T,EAAG,CAOf,IAAM+T,EAAiB/T,EAAEiC,OAAS,aAAejC,EAAEgU,cAAgB,QAKnE,GAAID,GAAkB/T,EAAEC,OAAS,EAC/B,OAGF,GAAM,CAAEkD,KAAAA,GAAS,KAGjB,GAAI,CAACA,EAAK2D,OAAOC,OAAQ,CACvB/G,EAAEiU,eAAF,EACA,MACD,CAEG9Q,EAAKwB,SAAS,cAAe,CAAE+L,cAAe1Q,EAA9C,EAAmDsI,mBAInDyL,IACF5Q,EAAK+Q,cAAL,EAIA,KAAKC,8BAA8BnU,EAAG,MAAtC,GAGFmD,EAAKsG,WAAWqC,QAAhB,EAEA,KAAKsI,cAAcpU,EAAG,MAAtB,EAEI,KAAKgS,mBAAqB,IAC5B,KAAK/F,SAAW,KAGhBtP,EAAe,KAAK2S,QAAS,KAAK1S,EAApB,GAGZ,KAAKoV,iBAAmB,GAE1B,KAAKqC,eAAL,EACA,KAAKlI,aAAe,IAEpB,KAAKA,aAAe,GAEvB,CAKD0H,cAAc7T,EAAG,CACf,KAAKmU,8BAA8BnU,EAAG,MAAtC,EAEK,KAAKgS,mBAIV,KAAKoC,cAAcpU,EAAG,MAAtB,EAEI,MAAKmD,KAAKwB,SAAS,cAAe,CAAE+L,cAAe1Q,EAAnD,EAAwDsI,mBAIxD,KAAK0J,mBAAqB,GAAK,CAAC,KAAKS,YAClC,KAAKxG,UACR,KAAKqI,wBAAL,EAIE,KAAKrI,UAAY,CAAC,KAAKwG,aACrB,KAAKC,YACP,KAAKA,UAAY,GACjB,KAAKxM,WAAWuG,IAAhB,GAGF,KAAKgG,WAAa,GAClB,KAAK4B,eAAL,EAGA,KAAKE,mBAAL,EACA,KAAKhC,cAAgBiC,KAAKrE,IAAL,EAErB,KAAKqC,oBAAsB,GAC3B7V,EAAe,KAAKoV,YAAa,KAAKnV,EAAxB,EACd,KAAK8P,SAAS5P,EAAI,EAClB,KAAK4P,SAAS3P,EAAI,EAClB,KAAK8V,KAAKhH,MAAV,EAEA,KAAK4I,aAAL,EACA,KAAKC,eAAL,IAEO,KAAK1C,iBAAmB,GAAK,CAAC,KAAKU,YAC5C,KAAKiC,YAAL,EAEA,KAAKjC,UAAY,GAGjB,KAAK6B,mBAAL,EAEA,KAAKrO,WAAW2F,MAAhB,EAEA,KAAK4I,aAAL,EACA,KAAKC,eAAL,IAEH,CAKDC,aAAc,CACR,KAAKlC,aACP,KAAKA,WAAa,GAIb,KAAKD,qBACR,KAAKoC,gBAAgB,EAArB,EAGF,KAAK/B,KAAKpG,IAAV,EACA,KAAKR,SAAW,KAEnB,CAKD6H,YAAY9T,EAAG,CACR,KAAKgS,mBAIV,KAAKoC,cAAcpU,EAAG,IAAtB,EAEI,MAAKmD,KAAKwB,SAAS,YAAa,CAAE+L,cAAe1Q,EAAjD,EAAsDsI,mBAItD,KAAK0J,mBAAqB,IAC5B,KAAKyC,aAAL,EAEI,KAAKhC,WACP,KAAKkC,YAAL,EACS,CAAC,KAAKjC,WAAa,CAAC,KAAKvG,cAElC,KAAK0I,WAAW7U,CAAhB,GAIA,KAAKgS,iBAAmB,GAAK,KAAKU,YACpC,KAAKA,UAAY,GACjB,KAAKxM,WAAWuG,IAAhB,EAEI,KAAKuF,mBAAqB,IAE5B,KAAK/F,SAAW,KAChB,KAAKsI,mBAAL,KAGL,CAKDG,gBAAiB,EACX,KAAKjC,YAAc,KAAKC,aAC1B,KAAKkC,gBAAL,EAEI,KAAKnC,WAEFhV,EAAY,KAAKb,GAAI,KAAKoP,MAAf,GACd,KAAK6G,KAAK9G,OAAV,GAGE,CAACtO,EAAY,KAAKb,GAAI,KAAKoP,MAAf,GACT,CAACvO,EAAY,KAAKZ,GAAI,KAAKgV,MAAf,IACjB,KAAK3L,WAAW6F,OAAhB,EAIJ,KAAK+I,kBAAL,EACA,KAAKnC,IAAMoC,sBAAsB,KAAKL,eAAevB,KAAK,IAAzB,CAAD,EAEnC,CAQDyB,gBAAgBjM,EAAO,CACrB,IAAMqM,EAAOR,KAAKrE,IAAL,EACP5R,EAAWyW,EAAO,KAAKzC,cAEzBhU,EAAW,IAAM,CAACoK,IAKtB,KAAK+D,SAAS5P,EAAI,KAAKmY,aAAa,IAAK1W,CAAvB,EAClB,KAAKmO,SAAS3P,EAAI,KAAKkY,aAAa,IAAK1W,CAAvB,EAElB,KAAKgU,cAAgByC,EACrBrY,EAAe,KAAKoV,YAAa,KAAKnV,EAAxB,EACd,KAAK4V,oBAAsB,GAC5B,CAMDqC,WAAW7U,EAAG,CACZ,GAAM,CAAEoI,WAAAA,GAAe,KAAKjF,KAG5B,GAAIiF,EAAWC,UAAX,EAAwB,CAG1BD,EAAW0E,YAAY,EAAG,EAA1B,EACA,MACD,CAGD,GAAI9M,EAAEiC,KAAKiT,QAAQ,QAAf,EAA2B,EAC7B,OAIF,GAAIlV,EAAEiC,OAAS,WAAajC,EAAEgU,cAAgB,QAAS,CACrD,KAAKlB,WAAWrC,MAAM,KAAKnB,QAAStP,CAApC,EACA,MACD,CAGD,IAAMmV,EAAW,KAAKhS,KAAKD,QAAQkS,gBAAkB1D,GAAmB,EAKpE,KAAKkB,WACP,KAAKyB,eAAL,EAEI/W,EAAmB,KAAKwU,aAAc,KAAKxC,OAAzB,EAAoCqC,IACxD,KAAKmB,WAAW5B,UAAU,KAAK5B,QAAStP,CAAxC,IAGFrD,EAAe,KAAKmV,aAAc,KAAKxC,OAAzB,EACd,KAAKsD,UAAYyC,WAAW,IAAM,CAChC,KAAKvC,WAAW7B,IAAI,KAAK3B,QAAStP,CAAlC,EACA,KAAKqU,eAAL,GACCc,CAHwB,EAK9B,CAKDd,gBAAiB,CACX,KAAKzB,YACP0C,aAAa,KAAK1C,SAAN,EACZ,KAAKA,UAAY,KAEpB,CAUDqC,aAAapQ,EAAMtG,EAAU,CAE3B,IAAMgX,EAAe,KAAK3Y,GAAGiI,CAAR,EAAgB,KAAKkN,YAAYlN,CAAjB,EAErC,OAAIzH,KAAKG,IAAIgY,CAAT,EAAyB,GAAKhX,EAAW,EACpCgX,EAAehX,EAGjB,CACR,CAKDkW,cAAe,CACT,KAAK9B,MACP6C,qBAAqB,KAAK7C,GAAN,EACpB,KAAKA,IAAM,KAEd,CAODwB,8BAA8BnU,EAAGgU,EAAa,CAChB,KAAK7Q,KAAKsS,aAAa,sBAAuB,GAAMzV,EAAGgU,CAAvD,GAE1BhU,EAAEiU,eAAF,CAEH,CAUDG,cAAcpU,EAAGgU,EAAa,CAC5B,GAAI,KAAK7B,qBAAsB,CAC7B,IAAMuD,EAA4C1V,EAE5C2V,EAAe,KAAK1D,iBAAiB2D,UAAWC,GAC7CA,EAAe7Y,KAAO0Y,EAAaI,SADvB,EAIjB9B,IAAgB,MAAQ2B,EAAe,GAEzC,KAAK1D,iBAAiB8D,OAAOJ,EAAc,CAA3C,EACS3B,IAAgB,QAAU2B,IAAiB,GAEpD,KAAK1D,iBAAiBlP,KAAK,KAAKiT,wBAAwBN,EAAc,CAAE5Y,EAAG,EAAGC,EAAG,CAAX,CAA3C,CAA3B,EACS4Y,EAAe,IAExB,KAAKK,wBAAwBN,EAAc,KAAKzD,iBAAiB0D,CAAtB,CAA3C,EAGF,KAAK3D,iBAAmB,KAAKC,iBAAiBgE,OAI1C,KAAKjE,iBAAmB,GAC1BrV,EAAe,KAAKC,GAAI,KAAKqV,iBAAiB,CAAtB,CAAV,EAGZ,KAAKD,iBAAmB,GAC1BrV,EAAe,KAAKE,GAAI,KAAKoV,iBAAiB,CAAtB,CAAV,CAEjB,KAAM,CACL,IAAMiE,EAAwClW,EAE9C,KAAKgS,iBAAmB,EACpBkE,EAAWjU,KAAKiT,QAAQ,OAAxB,EAAmC,GAGjCgB,EAAWC,SAAWD,EAAWC,QAAQF,OAAS,IACpD,KAAKD,wBAAwBE,EAAWC,QAAQ,CAAnB,EAAuB,KAAKvZ,EAAzD,EACA,KAAKoV,mBACDkE,EAAWC,QAAQF,OAAS,IAC9B,KAAKD,wBAAwBE,EAAWC,QAAQ,CAAnB,EAAuB,KAAKtZ,EAAzD,EACA,KAAKmV,sBAKT,KAAKgE,wBAAqDhW,EAAI,KAAKpD,EAAnE,EACIoX,IAAgB,KAElB,KAAKhC,iBAAmB,EAExB,KAAKA,mBAGV,CACF,CAKD8C,mBAAoB,CAClBnY,EAAe,KAAKqP,OAAQ,KAAKpP,EAAnB,EACdD,EAAe,KAAKkV,OAAQ,KAAKhV,EAAnB,CACf,CAKD0X,oBAAqB,CACnB5X,EAAe,KAAK2S,QAAS,KAAK1S,EAApB,EACdD,EAAe,KAAK4S,QAAS,KAAK1S,EAApB,EACd,KAAKiY,kBAAL,CACD,CAGDR,yBAA0B,CACxB,GAAI,KAAKnR,KAAKiF,WAAWC,UAArB,EAEF,KAAK4D,SAAW,QACX,CAEL,IAAMmK,EAAOhZ,KAAKG,IAAI,KAAKX,GAAGE,EAAI,KAAKwS,QAAQxS,CAAlC,EAAuCM,KAAKG,IAAI,KAAKX,GAAGG,EAAI,KAAKuS,QAAQvS,CAAlC,EAEpD,GAAIqZ,IAAS,EAAG,CAEd,IAAMC,EAAcD,EAAO,EAAI,IAAM,IAEjChZ,KAAKG,IAAI,KAAKX,GAAGyZ,CAAR,EAAuB,KAAK/G,QAAQ+G,CAAb,CAAhC,GAA8D5E,KAChE,KAAKxF,SAAWoK,EAEnB,CACF,CACF,CAWDL,wBAAwBhW,EAAG7C,EAAG,CAC5BA,OAAAA,EAAEL,EAAIkD,EAAEsW,MAAQ,KAAKnT,KAAKoT,OAAOzZ,EACjCK,EAAEJ,EAAIiD,EAAEwW,MAAQ,KAAKrT,KAAKoT,OAAOxZ,EAE7B,cAAeiD,EACjB7C,EAAEH,GAAKgD,EAAE8V,UACA9V,EAAEyW,aAAexZ,SAC1BE,EAAEH,GAAKgD,EAAEyW,YAGJtZ,CACR,CAMD+V,SAASlT,EAAG,CAEN,KAAKmD,KAAKiF,WAAWC,UAArB,IACFrI,EAAEiU,eAAF,EACAjU,EAAE0W,gBAAF,EAEH,CAxkBY,EChBTC,GAA2B,IAa3BC,GAAN,KAAiB,CAIf/U,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EACZ,KAAKrG,EAAI,EACT,KAAK+Z,WAAa,EAElB,KAAKC,mBAAqB,EAE1B,KAAKC,mBAAqB,EAE1B,KAAKC,qBAAuB,GAG5B,KAAKC,YAAc,CAAA,CACpB,CAQDxO,OAAOyO,EAAc,CACnB,GAAM,CAAE/T,KAAAA,CAAF,EAAW,KACXgU,EAAgB/Z,KAAKC,MACzB8F,EAAKO,aAAa5G,EAAIqG,EAAKO,aAAa5G,EAAIqG,EAAKD,QAAQkU,OADrC,EAMhBC,EAAqBF,IAAkB,KAAKN,WAE9CQ,IACF,KAAKR,WAAaM,EAClB,KAAKjJ,OAAO,KAAKrB,cAAL,CAAZ,GAGF,KAAKoK,YAAY1U,QAAQ,CAAC+U,EAAY1T,IAAU,CAC1CyT,GACFpZ,EAAaqZ,EAAW9a,IAAKoH,EAAQ,KAAKoT,sBACZ,KAAKH,UADvB,EAIVK,GAAgBI,EAAWhT,OAC7BgT,EAAWhT,MAAMmE,OAAjB,EAPJ,CAUD,CAKD8O,eAAgB,CAGd,KAAKT,mBAAqB,EAC1B,KAAKC,mBAAqB,EAG1B,KAAKF,WAAa,EAGlB,KAAKG,qBAAuB,EAC7B,CAMDQ,eAAgB,CACd,KAAKP,YAAc,CAAA,EAInB,QAASQ,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAMjb,EAAKJ,EAAc,aAAc,MAAO,KAAK+G,KAAKgE,SAAhC,EACxB3K,EAAGkb,aAAa,OAAQ,OAAxB,EACAlb,EAAGkb,aAAa,uBAAwB,OAAxC,EACAlb,EAAGkb,aAAa,cAAe,MAA/B,EAGAlb,EAAG0B,MAAMyZ,QAAWF,IAAM,EAAK,QAAU,OAEzC,KAAKR,YAAYlU,KAAK,CACpBvG,GAAAA,EADF,CAID,CACF,CAMDob,aAAc,CACZ,OAAO,KAAKzU,KAAK0U,YAAV,EAA0B,CAClC,CAiBD/K,YAAYsJ,EAAM0B,EAASC,EAAW,CACpC,GAAM,CAAE5U,KAAAA,CAAF,EAAW,KACb6U,EAAW7U,EAAK8U,eAAiB7B,EAC/B8B,EAAY/U,EAAK0U,YAAL,EAElB,GAAI1U,EAAKgV,QAAL,EAAgB,CAClBH,EAAW7U,EAAKiV,eAAeJ,CAApB,EACX,IAAMK,GAAYjC,EAAO8B,GAAaA,EAClCG,GAAYH,EAAY,EAE1B9B,EAAOiC,EAGPjC,EAAOiC,EAAWH,CAErB,MACKF,EAAW,EACbA,EAAW,EACFA,GAAYE,IACrBF,EAAWE,EAAY,GAEzB9B,EAAO4B,EAAW7U,EAAK8U,eAGzB9U,EAAK8U,eAAiBD,EACtB,KAAKlB,oBAAsBV,EAE3BjT,EAAKsG,WAAW6O,eAAhB,EAEA,IAAMC,EAAe,KAAK1L,cAAL,EACrB,GAAI,CAACiL,EACH,KAAK5J,OAAOqK,CAAZ,EACA,KAAKC,eAAL,MACK,CACLrV,EAAKsG,WAAWkE,YAAY,CAC1B8K,aAAc,GACd5M,MAAO,KAAK/O,EACZ2P,IAAK8L,EACL7L,SAAUqL,GAAa,EACvB7H,iBAAkB,GAClB1C,aAAc,EACdI,SAAW9Q,GAAM,CACf,KAAKoR,OAAOpR,CAAZ,GAEFsN,WAAY,IAAM,CAChB,KAAKoO,eAAL,EACArV,EAAK8E,YAAL,CACD,EAbH,EAgBA,IAAIyQ,EAAWvV,EAAK8U,eAAiB9U,EAAKuD,UAC1C,GAAIvD,EAAKgV,QAAL,EAAgB,CAClB,IAAMQ,GAAgBD,EAAWR,GAAaA,EAC1CS,GAAgBT,EAAY,EAE9BQ,EAAWC,EAGXD,EAAWC,EAAeT,CAE7B,CAIG9a,KAAKG,IAAImb,CAAT,EAAqB,GACvB,KAAKF,eAAL,CAEH,CAED,MAAO1N,EAAQsL,CAChB,CAODvJ,eAAgB,CACd,OAAO,KAAKgK,WAAa,KAAKC,kBAC/B,CAODzO,WAAY,CACV,OAAO,KAAKvL,IAAM,KAAK+P,cAAL,CACnB,CAKD2L,gBAAiB,CAAA,IAAAI,EACf,GAAM,CAAEzV,KAAAA,CAAF,EAAW,KACX0V,EAAqB,KAAK9B,mBAAqB,KAAKD,mBAE1D,GAAI,CAAC+B,EACH,OAGF,KAAK9B,mBAAqB,KAAKD,mBAE/B3T,EAAKuD,UAAYvD,EAAK8U,eAEtB,IAAIa,EAAU1b,KAAKG,IAAIsb,CAAT,EAEVE,EAEAD,GAAW,IACb,KAAK9B,sBAAwB6B,GAAsBA,EAAqB,EAAI,GAAK,GACjFC,EAAU,EAGV,KAAK7B,YAAY1U,QAAS+U,GAAe,CAAA,IAAA0B,GACvCA,EAAA1B,EAAWhT,SAAX,MAAA0U,IAAA,QAAAA,EAAkBzQ,QAAlB,EACA+O,EAAWhT,MAAQrH,OAFrB,GAMF,QAASwa,EAAI,EAAGA,EAAIqB,EAASrB,IACvBoB,EAAqB,GACvBE,EAAa,KAAK9B,YAAYgC,MAAjB,EACTF,IACF,KAAK9B,YAAY,CAAjB,EAAsB8B,EAEtB,KAAK/B,uBAEL/Y,EAAa8a,EAAWvc,IAAK,KAAKwa,qBAAuB,GAAK,KAAKH,UAAvD,EAEZ1T,EAAK+V,WAAWH,EAAa5V,EAAKuD,UAAYoS,EAAWrB,EAAI,CAA7D,KAGFsB,EAAa,KAAK9B,YAAYkC,IAAjB,EACTJ,IACF,KAAK9B,YAAYmC,QAAQL,CAAzB,EAEA,KAAK/B,uBAEL/Y,EAAa8a,EAAWvc,GAAI,KAAKwa,qBAAuB,KAAKH,UAAjD,EAEZ1T,EAAK+V,WAAWH,EAAa5V,EAAKuD,UAAYoS,EAAWrB,EAAI,CAA7D,IAWFra,KAAKG,IAAI,KAAKyZ,oBAAd,EAAsC,IAAM,CAAC,KAAK3O,UAAL,IAC/C,KAAKkP,cAAL,EACA,KAAK9O,OAAL,GAIFtF,EAAKsG,WAAWC,WAAhB,EAEA,KAAKuN,YAAY1U,QAAQ,CAAC+U,EAAYG,IAAM,CACtCH,EAAWhT,OAEbgT,EAAWhT,MAAMmD,YAAYgQ,IAAM,CAAnC,EAHJ,EAOAtU,EAAK6H,WAAL4N,EAAiB,KAAK3B,YAAY,CAAjB,KAAA,MAAA2B,IAAA,OAAA,OAAAA,EAAqBtU,MACtCnB,EAAK8D,cAAcoS,WAAWR,CAA9B,EAEI1V,EAAK6H,WACP7H,EAAK6H,UAAU7C,oBAAf,EAGFhF,EAAKwB,SAAS,QAAd,CACD,CAQDuJ,OAAOpR,EAAGwc,EAAU,CAClB,GAAI,CAAC,KAAKnW,KAAKgV,QAAV,GAAuBmB,EAAU,CAEpC,IAAIC,GAAwB,KAAK1C,WAAa,KAAKC,mBAAsBha,GAAK,KAAK+Z,WACnF0C,GAAuB,KAAKpW,KAAKuD,UACjC,IAAMsH,EAAQ5Q,KAAKC,MAAMP,EAAI,KAAKA,CAApB,GAETyc,EAAsB,GAAKvL,EAAQ,GAChCuL,GAAuB,KAAKpW,KAAK0U,YAAV,EAA0B,GAAK7J,EAAQ,KACpElR,EAAI,KAAKA,EAAKkR,EAAQ2I,GAEzB,CAED,KAAK7Z,EAAIA,EAEL,KAAKqG,KAAKgE,WACZlJ,EAAa,KAAKkF,KAAKgE,UAAWrK,CAAtB,EAGd,KAAKqG,KAAKwB,SAAS,iBAAkB,CAAE7H,EAAAA,EAAGwc,SAAUA,GAAF,KAAEA,EAAY,GAAhE,CACD,CA/Tc,ECdXE,GAAsB,CAC1BC,OAAQ,GACRC,EAAG,GACHC,UAAW,GACXC,QAAS,GACTC,WAAY,GACZC,UAAW,GACXC,IAAK,CAPqB,EAgBtBC,EAAsB,CAACC,EAAKC,IACzBA,EAAiBD,EAAMT,GAAoBS,CAAD,EAO7CE,GAAN,KAAe,CAIbtY,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EAEZ,KAAKiX,YAAc,GAEnBjX,EAAK4P,GAAG,aAAc,IAAM,CACtB5P,EAAKD,QAAQmX,YAEVlX,EAAKD,QAAQoX,mBAIhB,KAAKC,WAAL,EAGFpX,EAAK6P,OAAOjR,IACVtF,SACA,UAC2B,KAAK+d,WAAWrH,KAAK,IAArB,CAH7B,GAOFhQ,EAAK6P,OAAOjR,IAAItF,SAAU,UAAsC,KAAKge,WAAWtH,KAAK,IAArB,CAAhE,EAjBF,EAoBA,IAAMuH,EAAgDje,SAASke,cAC/DxX,EAAK4P,GAAG,UAAW,IAAM,CACnB5P,EAAKD,QAAQ0X,aACVF,GACA,KAAKN,aACVM,EAAkBG,MAAlB,EAJJ,CAOD,CAGDN,YAAa,CACP,CAAC,KAAKH,aAAe,KAAKjX,KAAK+F,UACjC,KAAK/F,KAAK+F,QAAQ2R,MAAlB,EACA,KAAKT,YAAc,GAEtB,CAMDK,WAAWza,EAAG,CACZ,GAAM,CAAEmD,KAAAA,CAAF,EAAW,KAMjB,GAJIA,EAAKwB,SAAS,UAAW,CAAE+L,cAAe1Q,EAA1C,EAA+CsI,kBAI/CvI,GAAeC,CAAD,EAIhB,OAIF,IAAI8a,EAEAjW,EACAkW,EAAY,GACVb,EAAiB,QAASla,EAEhC,OAAQka,EAAiBla,EAAEia,IAAMja,EAAEgb,QAAnC,CACE,KAAKhB,EAAoB,SAAUE,CAAX,EAClB/W,EAAKD,QAAQ+X,SACfH,EAAgB,SAElB,MACF,KAAKd,EAAoB,IAAKE,CAAN,EACtBY,EAAgB,aAChB,MACF,KAAKd,EAAoB,YAAaE,CAAd,EACtBrV,EAAO,IACP,MACF,KAAKmV,EAAoB,UAAWE,CAAZ,EACtBrV,EAAO,IACP,MACF,KAAKmV,EAAoB,aAAcE,CAAf,EACtBrV,EAAO,IACPkW,EAAY,GACZ,MACF,KAAKf,EAAoB,YAAaE,CAAd,EACtBa,EAAY,GACZlW,EAAO,IACP,MACF,KAAKmV,EAAoB,MAAOE,CAAR,EACtB,KAAKK,WAAL,EACA,KAzBJ,CA8BA,GAAI1V,EAAM,CAER7E,EAAEiU,eAAF,EAEA,GAAM,CAAEjJ,UAAAA,CAAF,EAAgB7H,EAElBA,EAAKD,QAAQgY,WACVrW,IAAS,KACT1B,EAAK0U,YAAL,EAAqB,EAC1BiD,EAAgBC,EAAY,OAAS,OAC5B/P,GAAaA,EAAUzG,cAAgByG,EAAU9E,WAAWZ,MAKrE0F,EAAUpE,IAAI/B,CAAd,GAAuBkW,EAAY,IAAM,GACzC/P,EAAUtC,MAAMsC,EAAUpE,IAAI9J,EAAGkO,EAAUpE,IAAI7J,CAA/C,EAEH,CAEG+d,IACF9a,EAAEiU,eAAF,EAEA9Q,EAAK2X,CAAD,EAAJ,EAEH,CAQDN,WAAWxa,EAAG,CACZ,GAAM,CAAEmb,SAAAA,CAAF,EAAe,KAAKhY,KACtBgY,GACG1e,WAAauD,EAAEgC,QACfmZ,IAAanb,EAAEgC,QACf,CAACmZ,EAASrK,SAA8B9Q,EAAEgC,MAAzC,GAENmZ,EAASN,MAAT,CAEH,CAhJY,EC/BTO,GAAiB,2BAkBjBC,GAAN,KAAmB,CAMjBxZ,YAAYyZ,EAAO,CAAA,IAAAC,EACjB,KAAKD,MAAQA,EACb,GAAM,CACJtZ,OAAAA,EACAoI,WAAAA,EACAjM,UAAAA,EACAqd,SAAAA,EAAW,IAAM,CAAA,EACjBjd,SAAAA,EAAW,IACX8L,OAAAA,EAAS+Q,EANL,EAOFE,EAEJ,KAAKE,SAAWA,EAGhB,IAAMld,EAAOH,EAAY,YAAc,UACjCH,GAAYsd,EAAAA,EAAMhd,CAAD,KAAR,MAAAid,IAAA,OAAAA,EAAkB,GAGjC,KAAKE,QAAUzZ,EAEf,KAAK0Z,YAActR,EAEnB,KAAKuR,UAAY,GAGjB,KAAKC,iBAAmB,KAAKA,iBAAiBzI,KAAK,IAA3B,EASxB,KAAK0I,eAAiBxG,WAAW,IAAM,CACrChX,GAAmB2D,EAAQ1D,EAAMC,EAAU8L,CAAzB,EAClB,KAAKwR,eAAiBxG,WAAW,IAAM,CACrCrT,EAAOR,iBAAiB,gBAAiB,KAAKoa,iBAAkB,EAAhE,EACA5Z,EAAOR,iBAAiB,mBAAoB,KAAKoa,iBAAkB,EAAnE,EAMA,KAAKC,eAAiBxG,WAAW,IAAM,CACrC,KAAKyG,mBAAL,CACD,EAAEvd,EAAW,GAFkB,EAGhCyD,EAAO9D,MAAMI,CAAb,EAAqBN,CACtB,EAAE,EAZ6B,GAa/B,CAf6B,CAgBjC,CAMD4d,iBAAiB5b,EAAG,CACdA,EAAEgC,SAAW,KAAKyZ,SACpB,KAAKK,mBAAL,CAEH,CAKDA,oBAAqB,CACd,KAAKH,YACR,KAAKA,UAAY,GACjB,KAAKH,SAAL,EACI,KAAKE,aACP,KAAKA,YAAL,EAGL,CAGDnT,SAAU,CACJ,KAAKsT,gBACPvG,aAAa,KAAKuG,cAAN,EAEd9c,GAAsB,KAAK0c,OAAN,EACrB,KAAKA,QAAQM,oBAAoB,gBAAiB,KAAKH,iBAAkB,EAAzE,EACA,KAAKH,QAAQM,oBAAoB,mBAAoB,KAAKH,iBAAkB,EAA5E,EACK,KAAKD,WACR,KAAKG,mBAAL,CAEH,CA5FgB,ECpBbE,GAA4B,GAC5BC,GAAwB,IAKxBC,GAAN,KAAkB,CAgBhBra,YAAY2J,EAAiBgC,EAAc0C,EAAkB,CAC3D,KAAKxD,SAAWlB,EAAkB,IAGlC,KAAK2Q,cAAgB3O,GAAgByO,GAGrC,KAAKG,kBAAoBlM,GAAoB8L,GAE7C,KAAKK,iBAAmB,KAAKD,kBAEzB,KAAKD,cAAgB,IACvB,KAAKE,kBAAoBjf,KAAKI,KAAK,EAAI,KAAK2e,cAAgB,KAAKA,aAAxC,EAE5B,CAQDG,UAAUC,EAAeC,EAAW,CAMlC,IAAIjH,EAAe,EACfkH,EAEJD,GAAa,IAEb,IAAME,EAAoBtf,EAAAA,KAAKuf,EAAM,CAAC,KAAKR,cAAgB,KAAKC,kBAAoBI,GAEpF,GAAI,KAAKL,gBAAkB,EACzBM,EAAQ,KAAK/P,SAAW,KAAK0P,kBAAoBG,EAEjDhH,GAAgBgH,EAAgBE,EAAQD,GAAaE,EAErD,KAAKhQ,SAAW6I,EACK,CAAC,KAAK6G,kBAAqBK,EAC5BC,UACX,KAAKP,cAAgB,EAAG,CACjCM,EAAS,EAAI,KAAKJ,kBACL,KAAKF,cAAgB,KAAKC,kBAAoBG,EAAgB,KAAK7P,UAEhF,IAAMkQ,EAAaxf,KAAKyf,IAAI,KAAKR,iBAAmBG,CAAjC,EACbM,EAAa1f,KAAK2f,IAAI,KAAKV,iBAAmBG,CAAjC,EAEnBjH,EAAemH,GACKH,EAAgBK,EAAaH,EAAQK,GAEzD,KAAKpQ,SAAW6I,EACK,CAAC,KAAK6G,kBACP,KAAKD,cACLO,GACC,CAAC,KAAKL,iBAAmBE,EAAgBO,EAC1C,KAAKT,iBAAmBI,EAAQG,EACrD,CAID,OAAOrH,CACR,CAhFe,ECWZyH,GAAN,KAAsB,CAIpBnb,YAAYyZ,EAAO,CACjB,KAAKA,MAAQA,EACb,KAAK2B,KAAO,EAEZ,GAAM,CACJpR,MAAAA,EACAY,IAAAA,EACAC,SAAAA,EACAkB,SAAAA,EACAxD,WAAAA,EACAoR,SAAAA,EAAW,IAAM,CAAA,EACjBhO,aAAAA,EACA0C,iBAAAA,CARI,EASFoL,EAEJ,KAAKE,SAAWA,EAEhB,IAAM0B,EAAQ,IAAIhB,GAAYxP,EAAUc,EAAc0C,CAAxC,EACViN,EAAW3I,KAAKrE,IAAL,EACXoM,EAAgB1Q,EAAQY,EAEtB2Q,EAAgB,IAAM,CACtB,KAAKH,OACPV,EAAgBW,EAAMZ,UAAUC,EAAe/H,KAAKrE,IAAL,EAAagN,CAA5C,EAGZ/f,KAAKG,IAAIgf,CAAT,EAA0B,GAAKnf,KAAKG,IAAI2f,EAAMxQ,QAAf,EAA2B,IAE5DkB,EAASnB,CAAD,EACJrC,GACFA,EAAU,EAEZ,KAAKoR,SAAL,IAEA2B,EAAW3I,KAAKrE,IAAL,EACXvC,EAAS2O,EAAgB9P,CAAjB,EACR,KAAKwQ,KAAOlI,sBAAsBqI,CAAD,KAKvC,KAAKH,KAAOlI,sBAAsBqI,CAAD,CAClC,CAGD7U,SAAU,CACJ,KAAK0U,MAAQ,GACfzH,qBAAqB,KAAKyH,IAAN,EAEtB,KAAKA,KAAO,CACb,CAtDmB,ECGhBI,GAAN,KAAiB,CACfxb,aAAc,CAEZ,KAAKyb,iBAAmB,CAAA,CACzB,CAKD3P,YAAY2N,EAAO,CACjB,KAAKiC,OAAOjC,EAAO,EAAnB,CACD,CAKDtR,gBAAgBsR,EAAO,CACrB,KAAKiC,OAAOjC,CAAZ,CACD,CAQDiC,OAAOjC,EAAOkC,EAAU,CACtB,IAAMC,EAAYD,EACd,IAAIR,GAAmD1B,CAAvD,EACA,IAAID,GAA6CC,CAAjD,EAEJ,YAAKgC,iBAAiBva,KAAK0a,CAA3B,EACAA,EAAUjC,SAAW,IAAM,KAAKkC,KAAKD,CAAV,EAEpBA,CACR,CAKDC,KAAKD,EAAW,CACdA,EAAUlV,QAAV,EACA,IAAM3E,EAAQ,KAAK0Z,iBAAiBpI,QAAQuI,CAA9B,EACV7Z,EAAQ,IACV,KAAK0Z,iBAAiBvH,OAAOnS,EAAO,CAApC,CAEH,CAEDkI,SAAU,CACR,KAAKwR,iBAAiB/a,QAASkb,GAAc,CAC3CA,EAAUlV,QAAV,EADF,EAGA,KAAK+U,iBAAmB,CAAA,CACzB,CAKD5T,YAAa,CACX,KAAK4T,iBAAmB,KAAKA,iBAAiBxa,OAAQ2a,GAChDA,EAAUnC,MAAMrR,OAClBwT,EAAUlV,QAAV,EACO,IAGF,EANe,CAQzB,CAED+P,gBAAiB,CACf,KAAKgF,iBAAmB,KAAKA,iBAAiBxa,OAAQ2a,GAChDA,EAAUnC,MAAM7C,cAClBgF,EAAUlV,QAAV,EACO,IAGF,EANe,CAQzB,CAcDoV,cAAe,CACb,OAAO,KAAKL,iBAAiBM,KAAMH,GAC1BA,EAAUnC,MAAMrR,KADlB,CAGR,CAhGc,ECdX4T,GAAN,KAAkB,CAIhBhc,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EACZA,EAAK6P,OAAOjR,IAAIoB,EAAK+F,QAAS,QAAoC,KAAK4U,SAAS3K,KAAK,IAAnB,CAAlE,CACD,CAMD2K,SAAS9d,EAAG,CACVA,EAAEiU,eAAF,EACA,GAAM,CAAEjJ,UAAAA,CAAF,EAAgB,KAAK7H,KACvB,CAAE4a,OAAAA,EAAQC,OAAAA,CAAV,EAAqBhe,EAEzB,GAAKgL,GAID,MAAK7H,KAAKwB,SAAS,QAAS,CAAE+L,cAAe1Q,EAA7C,EAAkDsI,iBAItD,GAAItI,EAAEE,SAAW,KAAKiD,KAAKD,QAAQ+a,aAEjC,GAAIjT,EAAUxB,WAAV,EAAwB,CAC1B,IAAIkB,EAAa,CAACsT,EACdhe,EAAEke,YAAc,EAClBxT,GAAc,IAEdA,GAAc1K,EAAEke,UAAY,EAAI,KAElCxT,EAAayT,EAAA,EAAKzT,GAElB,IAAMtB,EAAgB4B,EAAUzG,cAAgBmG,EAChDM,EAAU7B,OAAOC,EAAe,CAC9BtM,EAAGkD,EAAEoe,QACLrhB,EAAGiD,EAAEqe,QAFP,CAID,OAGGrT,EAAUH,WAAV,IACE7K,EAAEke,YAAc,IAElBH,GAAU,GACVC,GAAU,IAGZhT,EAAUtC,MACRsC,EAAUpE,IAAI9J,EAAIihB,EAClB/S,EAAUpE,IAAI7J,EAAIihB,CAFpB,EAML,CA1De,ECkClB,SAASM,GAAeC,EAAU,CAChC,GAAI,OAAOA,GAAa,SAQtB,OAAOA,EAGT,GAAI,CAACA,GAAY,CAACA,EAASC,YACzB,MAAO,GAGT,IAAMC,EAAUF,EACZG,EAAM,wFAEVA,OAAAA,EAAMA,EAAI9b,MAAM,IAAV,EAAgB+b,KAA4BF,EAAQG,MAAQ,EAA5D,EAOFH,EAAQI,YACVH,GAAO,8CAAgDD,EAAQI,UAAY,OAG7EH,GAAOD,EAAQK,MAEfJ,GAAO,SAEAA,CACR,CAED,IAAMK,GAAN,KAAgB,CAKdld,YAAYsB,EAAM4B,EAAM,CAAA,IAAAia,EACtB,IAAM9U,EAAOnF,EAAKmF,MAAQnF,EAAK1I,UAC3B4iB,EAAcla,EAAKma,KAGvB,GAAI/b,EAAKD,QAAQgH,CAAb,IAAuB,GAEzB,OAKE,OAAO/G,EAAKD,QAAQgH,EAAO,KAApB,GAA+B,WAMxC+U,EAAc9b,EAAKD,QAAQgH,EAAO,KAApB,GAGhB/G,EAAKwB,SAAS,kBAAmB,CAAEI,KAAAA,EAAnC,EAEA,IAAI1I,EAAY,GACZ0I,EAAKoa,UACP9iB,GAAa,gBACbA,GAAc0I,EAAK1I,WAAc,iBAAgB0I,EAAKmF,IAAK,IAE3D7N,GAAc0I,EAAK1I,WAAc,SAAQ0I,EAAKmF,IAAK,GAGrD,IAAI5N,EAAUyI,EAAKoa,SAAYpa,EAAKzI,SAAW,SAAayI,EAAKzI,SAAW,MAC5EA,EAAsDA,EAAQ8iB,YAAR,EAEtD,IAAMlW,EAAU9M,EAAcC,EAAWC,CAAZ,EAE7B,GAAIyI,EAAKoa,SAAU,CACb7iB,IAAY,WACoB4M,EAASjH,KAAO,UAGpD,GAAI,CAAEod,MAAAA,CAAF,EAAYta,EACV,CAAEua,UAAAA,GAAcva,EAGlB,OAAO5B,EAAKD,QAAQgH,EAAO,OAApB,GAAiC,WAE1CmV,EAAQlc,EAAKD,QAAQgH,EAAO,OAApB,GAGNmV,IACFnW,EAAQmW,MAAQA,GAGlB,IAAME,EAAWD,GAAaD,EAC1BE,GACFrW,EAAQwO,aAAa,aAAc6H,CAAnC,CAEH,CAEDrW,EAAQsW,UAAYlB,GAAeW,CAAD,EAE9Bla,EAAK0a,QACP1a,EAAK0a,OAAOvW,EAAS/F,CAArB,EAGE4B,EAAK2a,UACPxW,EAAQyW,QAAW3f,GAAM,CACnB,OAAO+E,EAAK2a,SAAY,SAE1Bvc,EAAK4B,EAAK2a,OAAN,EAAJ,EACS,OAAO3a,EAAK2a,SAAY,YACjC3a,EAAK2a,QAAQ1f,EAAGkJ,EAAS/F,CAAzB,IAMN,IAAMyc,EAAW7a,EAAK6a,UAAY,MAE9BzY,EAAYhE,EAAK+F,QACjB0W,IAAa,OACVzc,EAAK0c,SACR1c,EAAK0c,OAASzjB,EAAc,oCAAqC,MAAO+G,EAAK8P,UAAlD,GAE7B9L,EAAYhE,EAAK0c,SAIjB3W,EAAQ0H,UAAU7O,IAAI,qBAAtB,EAEI6d,IAAa,YACfzY,EAAYhE,EAAK8P,cAIrB+L,EAAA7X,KAAS,MAAEzK,IAAAA,QAAAA,EAAAA,YAAYyG,EAAKsS,aAAa,YAAavM,EAASnE,CAAxC,CAAvB,CACD,CAtGa,EChEhB,SAAS+a,GAAgB5W,EAAS/F,EAAM4c,EAAc,CACpD7W,EAAQ0H,UAAU7O,IAAI,qBAAtB,EAEAmH,EAAQwO,aAAa,gBAAiB,aAAtC,EACAvU,EAAK4P,GAAG,SAAU,IAAM,CACjB5P,EAAKD,QAAQ8c,OACZD,EAED7W,EAAS+W,SAAW,EAAE9c,EAAKuD,UAAYvD,EAAK0U,YAAL,EAAqB,GAG5D3O,EAAS+W,SAAW,EAAE9c,EAAKuD,UAAY,IAP9C,CAWD,CAGM,IAAMwZ,GAAY,CACvBhW,KAAM,YACN7N,UAAW,4BACXgjB,MAAO,WACPc,MAAO,GACPhB,SAAU,GACVS,SAAU,UACVV,KAAM,CACJV,YAAa,GACbI,KAAM,GACNE,MAAO,4EACPD,UAAW,mBAEba,QAAS,OACTD,OAAQK,EAde,EAkBZM,GAAY,CACvBlW,KAAM,YACN7N,UAAW,4BACXgjB,MAAO,OACPc,MAAO,GACPhB,SAAU,GACVS,SAAU,UACVV,KAAM,CACJV,YAAa,GACbI,KAAM,GACNE,MAAO,uCACPD,UAAW,mBAEba,QAAS,OACTD,OAAQ,CAACjjB,EAAI2G,IAAS,CACpB2c,GAAgBtjB,EAAI2G,EAAM,EAAX,CAChB,CAhBsB,EChDnBkd,GAAc,CAClBnW,KAAM,QACNmV,MAAO,QACPc,MAAO,GACPhB,SAAU,GACVD,KAAM,CACJV,YAAa,GACbM,MAAO,wFACPD,UAAW,mBAEba,QAAS,OAVS,ECAdY,GAAa,CACjBpW,KAAM,OACNmV,MAAO,OACPc,MAAO,GACPhB,SAAU,GACVD,KAAM,CACJV,YAAa,GAEbM,MAAO,uPAGPD,UAAW,kBAEba,QAAS,YAbQ,ECANa,GAAmB,CAC9BrW,KAAM,YACN0V,SAAU,MACVO,MAAO,EACPjB,KAAM,CACJV,YAAa,GAEbM,MAAO,kIACPD,UAAW,qBAEbY,OAAQ,CAACe,EAAkBrd,IAAS,CAElC,IAAIsd,EAEAC,EAAe,KAMbC,EAAuB,CAACtkB,EAAW0F,IAAQ,CAC/Cye,EAAiB5P,UAAUY,OAAO,oBAAsBnV,EAAW0F,CAAnE,GAMI6e,EAA0BC,GAAY,CACtCJ,IAAcI,IAChBJ,EAAYI,EACZF,EAAqB,SAAUE,CAAX,IAIlBC,EAA4B,IAAM,CAAA,IAAAC,EACtC,GAAI,GAAAA,EAAC5d,EAAK6H,aAAN,MAAA+V,IAAA,QAACA,EAAgB/Z,QAAQga,UAAxB,GAAqC,CACxCJ,EAAuB,EAAD,EAClBF,IACFpL,aAAaoL,CAAD,EACZA,EAAe,MAEjB,MACD,CAEIA,IAEHA,EAAerL,WAAW,IAAM,CAAA,IAAA4L,EAC9BL,EAAuB9V,GAAQ3H,GAAAA,EAAAA,EAAK6H,aAAL,MAAAiW,IAAA,SAAAA,EAAgBja,QAAQga,UAAxB,EAAT,EACtBN,EAAe,IAChB,EAAEvd,EAAKD,QAAQge,cAHS,IAO7B/d,EAAK4P,GAAG,SAAU+N,CAAlB,EAEA3d,EAAK4P,GAAG,eAAiB/S,GAAM,CACzBmD,EAAK6H,YAAchL,EAAEsE,OACvBwc,EAAyB,CAE5B,CAJD,EAOI3d,EAAKge,KACPhe,EAAKge,GAAGL,0BAA4BA,EAEvC,CAjE6B,ECAnBM,GAAmB,CAC9BlX,KAAM,UACNiW,MAAO,EACPV,OAAQ,CAAC4B,EAAgBle,IAAS,CAChCA,EAAK4P,GAAG,SAAU,IAAM,CACtBsO,EAAeC,UAAane,EAAKuD,UAAY,EACfvD,EAAKD,QAAQqe,kBACbpe,EAAK0U,YAAL,EAHhC,CAKD,CAT6B,ECkBhC,SAAS2J,GAAYhlB,EAAIilB,EAAY,CACnCjlB,EAAGoU,UAAUY,OAAO,kBAAmBiQ,CAAvC,CACD,CAED,IAAMC,GAAN,KAAS,CAIP7f,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EACZ,KAAKwe,aAAe,GAEpB,KAAKC,eAAiB,CAAA,EAEtB,KAAKC,MAAQ,CAAA,EAEb,KAAKf,0BAA4B,IAAM,CAAA,EAMvC,KAAKgB,sBAAwB7kB,MAC9B,CAED8kB,MAAO,CACL,GAAM,CAAE5e,KAAAA,CAAF,EAAW,KACjB,KAAKwe,aAAe,GACpB,KAAKC,eAAiB,CACpBvB,GACAH,GACAE,GACAE,GACAC,GACAa,EANoB,EAStBje,EAAKwB,SAAS,YAAd,EAGA,KAAKid,eAAeI,KAAK,CAACC,EAAGC,KAEnBD,EAAE9B,OAAS,IAAM+B,EAAE/B,OAAS,EAFtC,EAKA,KAAK0B,MAAQ,CAAA,EAEb,KAAKF,aAAe,GACpB,KAAKC,eAAerf,QAAS4f,GAAkB,CAC7C,KAAKC,gBAAgBD,CAArB,EADF,EAIAhf,EAAK4P,GAAG,SAAU,IAAM,CAAA,IAAAsP,GACtBA,EAAAlf,EAAK+F,WAAL,MAAAmZ,IAAA,QAAAA,EAAczR,UAAUY,OAAO,kBAAmBrO,EAAK0U,YAAL,IAAuB,CAAzE,EADF,EAIA1U,EAAK4P,GAAG,gBAAiB,IAAM,KAAKuP,iBAAL,CAA/B,CACD,CAKDF,gBAAgBG,EAAa,CACvB,KAAKZ,aACP,KAAKE,MAAM9e,KACT,IAAIgc,GAAU,KAAK5b,KAAMof,CAAzB,CADF,EAIA,KAAKX,eAAe7e,KAAKwf,CAAzB,CAEH,CAQDD,kBAAmB,CACjB,GAAM,CAAEnH,SAAAA,EAAUnQ,UAAAA,EAAW9H,QAAAA,CAAvB,EAAmC,KAAKC,KAE9C,GAAI,KAAKA,KAAK2D,OAAO0b,WAAa,CAACrH,GAAY,CAACnQ,EAC9C,OAGF,GAAI,CAAEzG,cAAAA,GAAkByG,EAOxB,GAJK,KAAK7H,KAAK2D,OAAOC,SACpBxC,EAAgByG,EAAU9E,WAAWT,SAGnClB,IAAkB,KAAKud,sBACzB,OAEF,KAAKA,sBAAwBvd,EAE7B,IAAMke,EAAoBzX,EAAU9E,WAAWT,QAAUuF,EAAU9E,WAAWR,UAG9E,GAAItI,KAAKG,IAAIklB,CAAT,EAA8B,KAAQ,CAACzX,EAAUxB,WAAV,EAAwB,CAEjEgY,GAAYrG,EAAU,EAAX,EACXA,EAASvK,UAAUvO,OAAO,oBAA1B,EACA,MACD,CAED8Y,EAASvK,UAAU7O,IAAI,oBAAvB,EAEA,IAAM2gB,EAAqBne,IAAkByG,EAAU9E,WAAWT,QAC9DuF,EAAU9E,WAAWR,UAAYsF,EAAU9E,WAAWT,QAE1D+b,GAAYrG,EAAUuH,GAAsBne,CAAjC,GAEPrB,EAAQyf,mBAAqB,QAC1Bzf,EAAQyf,mBAAqB,kBAClCxH,EAASvK,UAAU7O,IAAI,qBAAvB,CAEH,CAlHM,ECdT,SAAS6gB,GAAmBpmB,EAAI,CAC9B,IAAMqmB,EAAgBrmB,EAAGsmB,sBAAH,EACtB,MAAO,CACLhmB,EAAG+lB,EAAcE,KACjBhmB,EAAG8lB,EAAcG,IACjBrkB,EAAGkkB,EAAchkB,MAEpB,CAQD,SAASokB,GAA0BzmB,EAAI0mB,EAAYC,EAAa,CAC9D,IAAMN,EAAgBrmB,EAAGsmB,sBAAH,EAIhBjd,EAASgd,EAAchkB,MAAQqkB,EAC/Bpd,EAAS+c,EAAc/jB,OAASqkB,EAChCC,EAAgBvd,EAASC,EAASD,EAASC,EAE3Cud,GAAWR,EAAchkB,MAAQqkB,EAAaE,GAAiB,EAC/DE,GAAWT,EAAc/jB,OAASqkB,EAAcC,GAAiB,EASjE9b,EAAS,CACbxK,EAAG+lB,EAAcE,KAAOM,EACxBtmB,EAAG8lB,EAAcG,IAAMM,EACvB3kB,EAAGukB,EAAaE,CAHH,EAQf9b,OAAAA,EAAOic,UAAY,CACjB5kB,EAAGkkB,EAAchkB,MACjBD,EAAGikB,EAAc/jB,OACjBhC,EAAGumB,EACHtmB,EAAGumB,GAGEhc,CACR,CAWM,SAASkc,GAAe5f,EAAOD,EAAU8f,EAAU,CAExD,IAAMnT,EAAQmT,EAAS9e,SAAS,cAAe,CAC7Cf,MAAAA,EACAD,SAAAA,EACA8f,SAAAA,EAHY,EAMd,GAAInT,EAAMoT,YAER,OAAOpT,EAAMoT,YAGf,GAAM,CAAExa,QAAAA,CAAF,EAAcvF,EAEhB+f,EAEAC,EAEJ,GAAIza,GAAWua,EAASvgB,QAAQ0gB,gBAAkB,GAAO,CACvD,IAAMA,EAAgBH,EAASvgB,QAAQ0gB,eAAiB,MACxDD,EAAYza,EAAQ2a,QAAQD,CAAhB,EACR1a,EAA6CA,EAAQ4a,cAAcF,CAAtB,CAClD,CAEDD,OAAAA,EAAYF,EAAShO,aAAa,UAAWkO,EAAWhgB,EAAUC,CAAtD,EAER+f,IACGhgB,EAASogB,aAGZL,EAAcT,GACZU,EACAhgB,EAAS9E,OAAS8E,EAAShF,GAAK,EAChCgF,EAAS7E,QAAU6E,EAAS/E,GAAK,CAHI,EAFvC8kB,EAAcd,GAAmBe,CAAD,GAU7BF,EAAShO,aAAa,cAAeiO,EAAa/f,EAAUC,CAA5D,CACR,CCkGD,IAAMogB,GAAN,KAAsB,CAKpBniB,YAAYI,EAAMgiB,EAAS,CACzB,KAAKhiB,KAAOA,EACZ,KAAKqG,iBAAmB,GACpB2b,GACFxiB,OAAOyiB,OAAO,KAAMD,CAApB,CAEH,CAEDhQ,gBAAiB,CACf,KAAK3L,iBAAmB,EACzB,CAfmB,EAsBhB6b,GAAN,KAAgB,CACdtiB,aAAc,CAIZ,KAAKuiB,WAAa,CAAA,EAKlB,KAAKC,SAAW,CAAA,EAGhB,KAAKlhB,KAAOlG,OAGZ,KAAKiG,QAAUjG,MAChB,CAQDqnB,UAAUpa,EAAMqa,EAAIC,EAAW,IAAK,CAAA,IAAAC,EAAAC,EAAAC,EAC7B,KAAKN,SAASna,CAAd,IACH,KAAKma,SAASna,CAAd,EAAsB,CAAA,IAGxBua,EAAA,KAAKJ,SAASna,CAAd,KAAA,MAAAua,IAAA,QAAAA,EAAqB1hB,KAAK,CAAEwhB,GAAAA,EAAIC,SAAAA,EAAhC,GACAE,EAAA,KAAKL,SAASna,CAAd,KAAqB8X,MAAAA,IAAAA,QAAAA,EAAAA,KAAK,CAAC4C,EAAIC,IAAOD,EAAGJ,SAAWK,EAAGL,QAAvD,GAEKrhB,EAAAA,KAAAA,QAAL,MAAAwhB,IAAA,QAAAA,EAAWL,UAAUpa,EAAMqa,EAAIC,CAA/B,CACD,CAODM,aAAa5a,EAAMqa,EAAI,CACjB,KAAKF,SAASna,CAAd,IAEF,KAAKma,SAASna,CAAd,EAAsB,KAAKma,SAASna,CAAd,EAAoBpH,OAAOA,GAAWA,EAAOyhB,KAAOA,CAApD,GAGpB,KAAKphB,MACP,KAAKA,KAAK2hB,aAAa5a,EAAMqa,CAA7B,CAEH,CAQD9O,aAAavL,KAAS6a,EAAM,CAAA,IAAAC,EAC1B,OAAAA,EAAA,KAAKX,SAASna,CAAd,KAAA,MAAA8a,IAAA,QAAAA,EAAqBziB,QAASO,GAAW,CAEvCiiB,EAAK,CAAD,EAAMjiB,EAAOyhB,GAAGU,MAAM,KAAMF,CAAtB,EAFZ,EAIOA,EAAK,CAAD,CACZ,CAODhS,GAAG7I,EAAMqa,EAAI,CAAA,IAAAW,EAAAC,EACN,KAAKf,WAAWla,CAAhB,IACH,KAAKka,WAAWla,CAAhB,EAAwB,CAAA,IAErBka,EAAAA,KAAAA,WAAWla,CAAhB,KAAA,MAAAgb,IAAA,QAAAA,EAAuBniB,KAAKwhB,CAA5B,GAKAY,EAAA,KAAKhiB,QAAM4P,MAAAA,IAAAA,QAAAA,EAAAA,GAAG7I,EAAMqa,CAApB,CACD,CAODa,IAAIlb,EAAMqa,EAAI,CAAA,IAAAc,EACR,KAAKjB,WAAWla,CAAhB,IAEF,KAAKka,WAAWla,CAAhB,EAAwB,KAAKka,WAAWla,CAAhB,EAAsBpH,OAAOZ,GAAaqiB,IAAOriB,CAAjD,IAG1BmjB,EAAA,KAAKliB,QAAMiiB,MAAAA,IAAAA,QAAAA,EAAAA,IAAIlb,EAAMqa,CAArB,CACD,CAQD5f,SAASuF,EAAM+Z,EAAS,CAAA,IAAAqB,EACtB,GAAI,KAAKniB,KACP,OAAO,KAAKA,KAAKwB,SAASuF,EAAM+Z,CAAzB,EAGT,IAAM3T,EAA0C,IAAI0T,GAAgB9Z,EAAM+Z,CAA1B,EAEhD,OAAAqB,EAAA,KAAKlB,WAAWla,CAAhB,KAAA,MAAAob,IAAA,QAAAA,EAAuB/iB,QAASL,GAAa,CAC3CA,EAASoP,KAAK,KAAMhB,CAApB,EADF,EAIOA,CACR,CAnHa,ECpOViV,GAAN,KAAkB,CAKhB1jB,YAAY2jB,EAAUre,EAAW,CAU/B,GANA,KAAK+B,QAAU9M,EACb,mCACAopB,EAAW,MAAQ,MACnBre,CAH0B,EAMxBqe,EAAU,CACZ,IAAMC,EAAyC,KAAKvc,QACpDuc,EAAMC,SAAW,QACjBD,EAAME,IAAM,GACZF,EAAMG,IAAMJ,EACZC,EAAM/N,aAAa,OAAQ,cAA3B,CACD,CAED,KAAKxO,QAAQwO,aAAa,cAAe,MAAzC,CACD,CAMD5O,iBAAiBjK,EAAOC,EAAQ,CACzB,KAAKoK,UAIN,KAAKA,QAAQ5M,UAAY,OAI3BoC,EAAe,KAAKwK,QAAS,IAAK,MAApB,EACd,KAAKA,QAAQhL,MAAM2J,gBAAkB,MACrC,KAAKqB,QAAQhL,MAAMC,UAAYL,EAAkB,EAAG,EAAGe,EAAQ,GAAf,GAEhDH,EAAe,KAAKwK,QAASrK,EAAOC,CAAtB,EAEjB,CAEDyJ,SAAU,CAAA,IAAAsd,GACRA,EAAI,KAAK3c,WAAL,MAAA2c,IAAA,QAAAA,EAAcC,YAChB,KAAK5c,QAAQ7G,OAAb,EAEF,KAAK6G,QAAU,IAChB,CApDe,ECMZ6c,GAAN,KAAc,CAMZlkB,YAAY8B,EAAU8f,EAAU7f,EAAO,CACrC,KAAK6f,SAAWA,EAChB,KAAK1e,KAAOpB,EACZ,KAAKC,MAAQA,EAGb,KAAKsF,QAAUjM,OAEf,KAAKgM,YAAchM,OAEnB,KAAKqH,MAAQrH,OAEb,KAAK+oB,oBAAsB,EAC3B,KAAKC,qBAAuB,EAE5B,KAAKpnB,MAAQsF,OAAO,KAAKY,KAAKpG,CAAX,GAAiBwF,OAAO,KAAKY,KAAKlG,KAAX,GAAqB,EAC/D,KAAKC,OAASqF,OAAO,KAAKY,KAAKnG,CAAX,GAAiBuF,OAAO,KAAKY,KAAKjG,MAAX,GAAsB,EAEjE,KAAKonB,WAAa,GAClB,KAAK1d,SAAW,GAChB,KAAK2d,WAAa,GAElB,KAAKC,MAAQ1mB,EAAWC,KAEpB,KAAKoF,KAAK9C,KACZ,KAAKA,KAAO,KAAK8C,KAAK9C,KACb,KAAK8C,KAAK6gB,IACnB,KAAK3jB,KAAO,QAEZ,KAAKA,KAAO,OAGd,KAAKwhB,SAAS9e,SAAS,cAAe,CAAEqC,QAAS,KAAjD,CACD,CAEDqf,mBAAoB,CACd,KAAKpd,aAAe,CAAC,KAAKqd,gBAAL,GAEvBjR,WAAW,IAAM,CACX,KAAKpM,cACP,KAAKA,YAAYV,QAAjB,EACA,KAAKU,YAAchM,SAEpB,GALO,CAOb,CAQD8K,KAAKwe,EAAQC,EAAQ,CACnB,GAAI,KAAKliB,OAAS,KAAKmiB,eAAL,EAChB,GAAK,KAAKxd,YAYH,CACL,IAAMyd,EAAgB,KAAKzd,YAAYC,QAEnCwd,GAAiB,CAACA,EAAcC,eAClC,KAAKriB,MAAM6C,UAAUyf,QAAQF,CAA7B,CAEH,KAlBsB,CACrB,IAAMG,EAAiB,KAAKpD,SAAShO,aACnC,iBAGC,KAAK1Q,KAAK+hB,MAAQ,KAAKxiB,MAAMuC,aAAgB,KAAK9B,KAAK+hB,KAAO,GAC/D,IALqB,EAOvB,KAAK7d,YAAc,IAAIsc,GACrBsB,EACA,KAAKviB,MAAM6C,SAFM,CAIpB,CASC,KAAK+B,SAAW,CAACsd,GAIjB,KAAK/C,SAAS9e,SAAS,cAAe,CAAEqC,QAAS,KAAMuf,OAAAA,EAAvD,EAAiEje,mBAIjE,KAAKye,eAAL,GACF,KAAK7d,QAAU9M,EAAc,YAAa,KAAd,EAGxB,KAAK4pB,qBACP,KAAKgB,UAAUT,CAAf,IAGF,KAAKrd,QAAU9M,EAAc,gBAAiB,KAAlB,EAC5B,KAAK8M,QAAQsW,UAAY,KAAKza,KAAKma,MAAQ,IAGzCsH,GAAU,KAAKliB,OACjB,KAAKA,MAAM0D,kBAAkB,EAA7B,EAEH,CAODgf,UAAUT,EAAQ,CAAA,IAAAU,EAAAC,EAChB,GAAI,CAAC,KAAKH,eAAL,GACA,CAAC,KAAK7d,SACN,KAAKua,SAAS9e,SAAS,mBAAoB,CAAEqC,QAAS,KAAMuf,OAAAA,EAA5D,EAAsEje,iBACzE,OAGF,IAAM6e,EAA8C,KAAKje,QAEzD,KAAKke,kBAAL,EAEI,KAAKriB,KAAKsiB,SACZF,EAAaE,OAAS,KAAKtiB,KAAKsiB,QAGlCF,EAAavB,KAAMqB,EAAA,KAAKliB,KAAK6gB,OAA7B,MAAAqB,IAAA,OAAAA,EAAoC,GACpCE,EAAaxB,KAAMuB,EAAA,KAAKniB,KAAK4gB,OAA7B,MAAAuB,IAAA,OAAAA,EAAoC,GAEpC,KAAKd,MAAQ1mB,EAAWE,QAEpBunB,EAAa/nB,SACf,KAAKkoB,SAAL,GAEAH,EAAa3nB,OAAS,IAAM,CAC1B,KAAK8nB,SAAL,GAGFH,EAAa1nB,QAAU,IAAM,CAC3B,KAAK8nB,QAAL,GAGL,CAODC,SAASljB,EAAO,CACd,KAAKA,MAAQA,EACb,KAAKkE,SAAW,GAChB,KAAKib,SAAWnf,EAAMnB,IAGvB,CAKDmkB,UAAW,CACT,KAAKlB,MAAQ1mB,EAAWG,OAEpB,KAAKyE,OAAS,KAAK4E,UACrB,KAAKua,SAAS9e,SAAS,eAAgB,CAAEL,MAAO,KAAKA,MAAO0C,QAAS,IAA9B,CAAvC,EAGI,KAAK1C,MAAMmC,UACR,KAAKnC,MAAM+C,eACX,CAAC,KAAK6B,QAAQ4c,aACnB,KAAKle,OAAL,EACA,KAAKtD,MAAM0D,kBAAkB,EAA7B,IAGE,KAAKoe,QAAU1mB,EAAWG,QAAU,KAAKumB,QAAU1mB,EAAWI,QAChE,KAAKumB,kBAAL,EAGL,CAKDkB,SAAU,CACR,KAAKnB,MAAQ1mB,EAAWI,MAEpB,KAAKwE,QACP,KAAKmjB,aAAL,EACA,KAAKhE,SAAS9e,SAAS,eAAgB,CAAEL,MAAO,KAAKA,MAAOojB,QAAS,GAAM1gB,QAAS,KAApF,EACA,KAAKyc,SAAS9e,SAAS,YAAa,CAAEL,MAAO,KAAKA,MAAO0C,QAAS,KAAlE,EAEH,CAKDga,WAAY,CACV,OAAO,KAAKyC,SAAShO,aACnB,mBACA,KAAK2Q,QAAU1mB,EAAWE,QAC1B,IAHK,CAKR,CAKD8nB,SAAU,CACR,OAAO,KAAKtB,QAAU1mB,EAAWI,KAClC,CAKDinB,gBAAiB,CACf,OAAO,KAAK9kB,OAAS,OACtB,CAQD6G,iBAAiBjK,EAAOC,EAAQ,CAC9B,GAAK,KAAKoK,UAIN,KAAKD,aACP,KAAKA,YAAYH,iBAAiBjK,EAAOC,CAAzC,EAGE,MAAK2kB,SAAS9e,SAChB,gBACA,CAAEqC,QAAS,KAAMnI,MAAAA,EAAOC,OAAAA,EAFtB,EAEgCwJ,mBAKpC5J,EAAe,KAAKwK,QAASrK,EAAOC,CAAtB,EAEV,KAAKioB,eAAL,GAAyB,CAAC,KAAKW,QAAL,IAAgB,CAC5C,IAAMC,EAAuB,CAAC,KAAK3B,qBAAuBnnB,EAE1D,KAAKmnB,oBAAsBnnB,EAC3B,KAAKonB,qBAAuBnnB,EAExB6oB,EACF,KAAKX,UAAU,EAAf,EAEA,KAAKI,kBAAL,EAGE,KAAK9iB,OACP,KAAKmf,SAAS9e,SACZ,kBACA,CAAEL,MAAO,KAAKA,MAAOzF,MAAAA,EAAOC,OAAAA,EAAQkI,QAAS,KAF/C,CAKH,CACF,CAKDwC,YAAa,CACX,OAAO,KAAKia,SAAShO,aACnB,oBACA,KAAKsR,eAAL,GAA0B,KAAKX,QAAU1mB,EAAWI,MACpD,IAHK,CAKR,CAKDsnB,mBAAoB,CAMlB,GAAI,CAAC,KAAKL,eAAL,GAAyB,CAAC,KAAK7d,SAAW,CAAC,KAAKnE,KAAKsiB,OACxD,OAGF,IAAMO,EAAuC,KAAK1e,QAC5C2e,EAAa,KAAKpE,SAAShO,aAC/B,mBACA,KAAKuQ,oBACL,IAHiB,GAOjB,CAAC4B,EAAME,QAAQC,iBACZF,EAAaG,SAASJ,EAAME,QAAQC,gBAAiB,EAAhC,KAExBH,EAAMK,MAAQJ,EAAa,KAC3BD,EAAME,QAAQC,gBAAkBG,OAAOL,CAAD,EAEzC,CAKDpB,gBAAiB,CACf,OAAO,KAAKhD,SAAShO,aACnB,wBACA,KAAKsR,eAAL,EACA,IAHK,CAKR,CAKDoB,UAAW,CACL,KAAK1E,SAAS9e,SAAS,kBAAmB,CAAEqC,QAAS,KAArD,EAA6DsB,kBAIjE,KAAKP,KAAK,EAAV,CACD,CAKDue,iBAAkB,CAChB,OAAO,KAAK7C,SAAShO,aACnB,uBACA,KAAKuL,UAAL,EACA,IAHK,CAKR,CAKDzY,SAAU,CACR,KAAKC,SAAW,GAChB,KAAKlE,MAAQrH,OAET,MAAKwmB,SAAS9e,SAAS,iBAAkB,CAAEqC,QAAS,KAApD,EAA4DsB,mBAIhE,KAAKjG,OAAL,EAEI,KAAK4G,cACP,KAAKA,YAAYV,QAAjB,EACA,KAAKU,YAAchM,QAGjB,KAAK8pB,eAAL,GAAyB,KAAK7d,UAChC,KAAKA,QAAQ1J,OAAS,KACtB,KAAK0J,QAAQzJ,QAAU,KACvB,KAAKyJ,QAAUjM,QAElB,CAKDwqB,cAAe,CACb,GAAI,KAAKnjB,MAAO,CAAA,IAAA8jB,EAAAC,EACd,IAAIC,EAAalsB,EAAc,kBAAmB,KAApB,EAC9BksB,EAAWhH,WAAX8G,GAAAC,EAAuB,KAAK5E,SAASvgB,WAAd,MAAAmlB,IAAA,OAAA,OAAAA,EAAuBE,YAA9C,MAAAH,IAAA,OAAAA,EAA0D,GAC1DE,EAA4C,KAAK7E,SAAShO,aACxD,sBACA6S,EACA,IAH0C,EAK5C,KAAKpf,QAAU9M,EAAc,0CAA2C,KAA5C,EAC5B,KAAK8M,QAAQxM,YAAY4rB,CAAzB,EACA,KAAKhkB,MAAM6C,UAAUma,UAAY,GACjC,KAAKhd,MAAM6C,UAAUzK,YAAY,KAAKwM,OAAtC,EACA,KAAK5E,MAAM0D,kBAAkB,EAA7B,EACA,KAAKqe,kBAAL,CACD,CACF,CAKDze,QAAS,CACP,GAAI,KAAKse,YAAc,CAAC,KAAKhd,QAC3B,OAKF,GAFA,KAAKgd,WAAa,GAEd,KAAKE,QAAU1mB,EAAWI,MAAO,CACnC,KAAK2nB,aAAL,EACA,MACD,CAED,GAAI,KAAKhE,SAAS9e,SAAS,gBAAiB,CAAEqC,QAAS,KAAnD,EAA2DsB,iBAC7D,OAGF,IAAMkgB,EAAkB,WAAY,KAAKtf,QAErC,KAAK6d,eAAL,EAaEyB,GAAkB,KAAKlkB,QAAU,CAAC,KAAKA,MAAMmC,UAAYvF,GAAQ,IACnE,KAAKilB,WAAa,GAIjB,KAAKjd,QAAShK,OAAf,EAAwBC,MAAM,IAAM,CAAA,CAApC,EAAwCspB,QAAQ,IAAM,CACpD,KAAKtC,WAAa,GAClB,KAAKuC,YAAL,EAFF,GAKA,KAAKA,YAAL,EAEO,KAAKpkB,OAAS,CAAC,KAAK4E,QAAQ4c,YACrC,KAAKxhB,MAAM6C,UAAUzK,YAAY,KAAKwM,OAAtC,CAEH,CAODxB,UAAW,CACL,KAAK+b,SAAS9e,SAAS,kBAAmB,CAAEqC,QAAS,IAAX,CAA1C,EAA6DsB,kBAC5D,CAAC,KAAKhE,QAIP,KAAKyiB,eAAL,GAAyB,KAAKZ,YAAc,CAACjlB,GAAQ,EAGvD,KAAKwnB,YAAL,EACS,KAAKhB,QAAL,GACT,KAAK3f,KAAK,GAAO,EAAjB,EAGE,KAAKzD,MAAM8C,eACb,KAAK9C,MAAM8C,cAAcsQ,aAAa,cAAe,OAArD,EAEH,CAKD/P,YAAa,CACX,KAAK8b,SAAS9e,SAAS,oBAAqB,CAAEqC,QAAS,KAAvD,EACI,KAAK1C,OAAS,KAAKA,MAAM8C,eAC3B,KAAK9C,MAAM8C,cAAcsQ,aAAa,cAAe,MAArD,CAEH,CAMDrV,QAAS,CACP,KAAK6jB,WAAa,GAEd,MAAKzC,SAAS9e,SAAS,gBAAiB,CAAEqC,QAAS,KAAnD,EAA2DsB,mBAI3D,KAAKY,SAAW,KAAKA,QAAQ4c,YAC/B,KAAK5c,QAAQ7G,OAAb,EAGE,KAAK4G,aAAe,KAAKA,YAAYC,SACvC,KAAKD,YAAYC,QAAQ7G,OAAzB,EAEH,CAKDqmB,aAAc,CACP,KAAKxC,aAIN,KAAKzC,SAAS9e,SAAS,qBAAsB,CAAEqC,QAAS,KAAxD,EAAgEsB,mBAKhE,KAAKhE,OAAS,KAAK4E,SAAW,CAAC,KAAKA,QAAQ4c,YAC9C,KAAKxhB,MAAM6C,UAAUzK,YAAY,KAAKwM,OAAtC,GAGE,KAAKkd,QAAU1mB,EAAWG,QAAU,KAAKumB,QAAU1mB,EAAWI,QAChE,KAAKumB,kBAAL,GAEH,CA5fW,ECCRsC,GAAsB,EAYrB,SAASC,GAAajlB,EAAU8f,EAAU7f,EAAO,CACtD,IAAMoD,EAAUyc,EAASoF,sBAAsBllB,EAAUC,CAAzC,EAEZklB,EAEE,CAAE5lB,QAAAA,GAAYugB,EAIpB,GAAIvgB,EAAS,CACX4lB,EAAY,IAAI1jB,EAAUlC,EAASS,EAAU,EAAjC,EAEZ,IAAID,EACA+f,EAAStgB,KACXO,EAAe+f,EAAStgB,KAAKO,aAE7BA,EAAeT,GAAgBC,EAASugB,CAAV,EAGhC,IAAMze,EAAcZ,GAAelB,EAASQ,EAAcC,EAAUC,CAAlC,EAClCklB,EAAUrkB,OAAOuC,EAAQnI,MAAOmI,EAAQlI,OAAQkG,CAAhD,CACD,CAEDgC,OAAAA,EAAQmhB,SAAR,EAEIW,GACF9hB,EAAQ8B,iBACN1L,KAAK2rB,KAAK/hB,EAAQnI,MAAQiqB,EAAUrjB,OAApC,EACArI,KAAK2rB,KAAK/hB,EAAQlI,OAASgqB,EAAUrjB,OAArC,CAFF,EAMKuB,CACR,CAcM,SAASgiB,GAAcplB,EAAO6f,EAAU,CAC7C,IAAM9f,EAAW8f,EAASwF,YAAYrlB,CAArB,EAEjB,GAAI6f,CAAAA,EAAS9e,SAAS,gBAAiB,CAAEf,MAAAA,EAAOD,SAAAA,EAA5C,EAAwD2E,iBAI5D,OAAOsgB,GAAajlB,EAAU8f,EAAU7f,CAArB,CACpB,CAED,IAAMslB,GAAN,KAAoB,CAIlBrnB,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EAEZ,KAAKgmB,MAAQ/rB,KAAKS,IAChBsF,EAAKD,QAAQkmB,QAAQ,CAArB,EAA0BjmB,EAAKD,QAAQkmB,QAAQ,CAArB,EAA0B,EACpDT,EAFW,EAKb,KAAKU,aAAe,CAAA,CACrB,CAODhQ,WAAWjD,EAAM,CACf,GAAM,CAAEjT,KAAAA,CAAF,EAAW,KAEjB,GAAIA,EAAKwB,SAAS,UAAd,EAA0B2D,iBAC5B,OAGF,GAAM,CAAE8gB,QAAAA,GAAYjmB,EAAKD,QACnB6X,EAAY3E,IAASnZ,OAAY,GAAQmZ,GAAQ,EACnDqB,EAGJ,IAAKA,EAAI,EAAGA,GAAK2R,EAAQ,CAAD,EAAK3R,IAC3B,KAAK6R,iBAAiBnmB,EAAKuD,WAAaqU,EAAYtD,EAAK,CAACA,EAA1D,EAIF,IAAKA,EAAI,EAAGA,GAAK2R,EAAQ,CAAD,EAAK3R,IAC3B,KAAK6R,iBAAiBnmB,EAAKuD,WAAaqU,EAAa,CAACtD,EAAKA,EAA3D,CAEH,CAKD6R,iBAAiBC,EAAc,CAC7B,IAAM3lB,EAAQ,KAAKT,KAAKiV,eAAemR,CAAzB,EAEVviB,EAAU,KAAKwiB,kBAAkB5lB,CAAvB,EACToD,IAEHA,EAAUgiB,GAAcplB,EAAO,KAAKT,IAAb,EAEnB6D,GACF,KAAKyiB,WAAWziB,CAAhB,EAGL,CAMDE,kBAAkB5C,EAAO,CACvB,IAAI0C,EAAU,KAAKwiB,kBAAkBllB,EAAMV,KAA7B,EACd,OAAKoD,IAEHA,EAAU,KAAK7D,KAAK0lB,sBAAsBvkB,EAAMS,KAAMT,EAAMV,KAAlD,EACV,KAAK6lB,WAAWziB,CAAhB,GAIFA,EAAQwgB,SAASljB,CAAjB,EAEO0C,CACR,CAKDyiB,WAAWziB,EAAS,CAKlB,GAHA,KAAK0iB,cAAc1iB,EAAQpD,KAA3B,EACA,KAAKylB,aAAatmB,KAAKiE,CAAvB,EAEI,KAAKqiB,aAAapT,OAAS,KAAKkT,MAAO,CAEzC,IAAMQ,EAAgB,KAAKN,aAAazT,UAAWgU,GAC1C,CAACA,EAAK1D,YAAc,CAAC0D,EAAKphB,QADb,EAGlBmhB,IAAkB,IACA,KAAKN,aAAatT,OAAO4T,EAAe,CAAxC,EAA2C,CAA3C,EACRphB,QAAZ,CAEH,CACF,CAODmhB,cAAc9lB,EAAO,CACnB,IAAM+lB,EAAgB,KAAKN,aAAazT,UAAUgU,GAAQA,EAAKhmB,QAAUA,CAAnD,EAClB+lB,IAAkB,IACpB,KAAKN,aAAatT,OAAO4T,EAAe,CAAxC,CAEH,CAMDH,kBAAkB5lB,EAAO,CACvB,OAAO,KAAKylB,aAAaQ,KAAK7iB,GAAWA,EAAQpD,QAAUA,CAApD,CACR,CAED2E,SAAU,CACR,KAAK8gB,aAAa9mB,QAAQyE,GAAWA,EAAQuB,QAAR,CAArC,EACA,KAAK8gB,aAAe,CAAA,CACrB,CAxHiB,EClEdS,GAAN,cAA6B3F,EAAU,CAMrCtM,aAAc,CAAA,IAAAkS,EACZ,IAAIC,EAAW,EACTC,GAAaF,EAAA,KAAK7mB,WAAR,MAAA6mB,IAAA,OAAA,OAAGA,EAAcE,WAE7BA,GAAc,WAAYA,EAE5BD,EAAWC,EAAWhU,OACbgU,GAAc,YAAaA,IAE/BA,EAAWpI,QACdoI,EAAWpI,MAAQ,KAAKqI,uBAAuBD,EAAWE,OAAvC,GAGjBF,EAAWpI,QACbmI,EAAWC,EAAWpI,MAAM5L,SAKhC,IAAM3F,EAAQ,KAAK3L,SAAS,WAAY,CACtCslB,WAAAA,EACAD,SAAAA,CAFsC,CAA1B,EAId,OAAO,KAAKvU,aAAa,WAAYnF,EAAM0Z,SAAUC,CAA9C,CACR,CAODpB,sBAAsB1iB,EAAWvC,EAAO,CACtC,OAAO,IAAImiB,GAAQ5f,EAAW,KAAMvC,CAA7B,CACR,CAYDqlB,YAAYrlB,EAAO,CAAA,IAAAwmB,EACjB,IAAMH,GAAaG,EAAA,KAAKlnB,WAAR,MAAAknB,IAAA,OAAA,OAAGA,EAAcH,WAE7BI,EAAiB,CAAA,EACjBxpB,MAAMC,QAAQmpB,CAAd,EAEFI,EAAiBJ,EAAWrmB,CAAD,EAClBqmB,GAAc,YAAaA,IAM/BA,EAAWpI,QACdoI,EAAWpI,MAAQ,KAAKqI,uBAAuBD,EAAWE,OAAvC,GAGrBE,EAAiBJ,EAAWpI,MAAMje,CAAjB,GAGnB,IAAID,EAAW0mB,EAEX1mB,aAAoBhD,UACtBgD,EAAW,KAAK2mB,sBAAsB3mB,CAA3B,GAKb,IAAM2M,EAAQ,KAAK3L,SAAS,WAAY,CACtChB,SAAUA,GAAY,CAAA,EACtBC,MAAAA,CAFsC,CAA1B,EAKd,OAAO,KAAK6R,aAAa,WAAYnF,EAAM3M,SAAUC,CAA9C,CACR,CASDsmB,uBAAuBK,EAAgB,CAAA,IAAAC,EAAAC,EACrC,OAAID,EAAA,KAAKtnB,WAAL,MAAAsnB,IAAA,QAAAA,EAAcE,WAAdD,EAA0B,KAAKvnB,WAA/B,MAAAunB,IAAA,QAA0BA,EAAcE,cACnCrqB,GACL,KAAK4C,QAAQwnB,SACb,KAAKxnB,QAAQynB,cACbJ,CAH0B,GAIvB,CAAA,EAGA,CAACA,CAAD,CACR,CAQDD,sBAAsBphB,EAAS,CAE7B,IAAMvF,EAAW,CACfuF,QAAAA,GAGI0hB,EACJ1hB,EAAQ5M,UAAY,IAChB4M,EACAA,EAAQ4a,cAAc,GAAtB,EAGN,GAAI8G,EAAQ,CAGVjnB,EAASiiB,IAAMgF,EAAO9C,QAAQ+C,SAAWD,EAAOE,KAE5CF,EAAO9C,QAAQiD,aACjBpnB,EAAS0jB,OAASuD,EAAO9C,QAAQiD,YAGnCpnB,EAAS9E,MAAQ+rB,EAAO9C,QAAQkD,UAAYhD,SAAS4C,EAAO9C,QAAQkD,UAAW,EAA3B,EAAiC,EACrFrnB,EAAS7E,OAAS8rB,EAAO9C,QAAQmD,WAAajD,SAAS4C,EAAO9C,QAAQmD,WAAY,EAA5B,EAAkC,EAGxFtnB,EAAShF,EAAIgF,EAAS9E,MACtB8E,EAAS/E,EAAI+E,EAAS7E,OAElB8rB,EAAO9C,QAAQoD,WACjBvnB,EAAS1B,KAAO2oB,EAAO9C,QAAQoD,UAGjC,IAAMC,EAAcjiB,EAAQ4a,cAAc,KAAtB,EAEpB,GAAIqH,EAAa,CAAA,IAAAC,EAGfznB,EAASmjB,KAAOqE,EAAYE,YAAcF,EAAYvF,IACtDjiB,EAASgiB,KAATyF,EAAeD,EAAYG,aAAa,KAAzB,KAAf,MAAAF,IAAA,OAAAA,EAAkD,EACnD,EAEGR,EAAO9C,QAAQyD,aAAeX,EAAO9C,QAAQ0D,WAC/C7nB,EAASogB,aAAe,GAE3B,CAED,OAAO,KAAKtO,aAAa,cAAe9R,EAAUuF,EAAS0hB,CAApD,CACR,CASDhC,aAAajlB,EAAUC,EAAO,CAC5B,OAAOglB,GAAajlB,EAAU,KAAMC,CAAjB,CACpB,CA1KoC,ECGjC6nB,EAAc,KAOdC,GAAN,KAAa,CAIX7pB,YAAYsB,EAAM,CAChB,KAAKA,KAAOA,EACZ,KAAKwoB,SAAW,GAChB,KAAK5kB,OAAS,GACd,KAAKyb,UAAY,GACjB,KAAKoJ,UAAY,GAKjB,KAAKC,UAAY5uB,OAEjB,KAAK6uB,cAAgB,GAErB,KAAKC,aAAe,GAEpB,KAAKC,oBAAsB,GAE3B,KAAKC,kBAAoB,GAKzB,KAAKC,aAAejvB,OAKpB,KAAKkvB,gBAAkBlvB,OAKvB,KAAKmvB,gBAAkBnvB,OAKvB,KAAKovB,gBAAkBpvB,OAMvB,KAAKqvB,aAAervB,OAGpB,KAAKsvB,aAAe,KAAKA,aAAapZ,KAAK,IAAvB,EAGpBhQ,EAAK4P,GAAG,eAAgB,KAAKwZ,YAA7B,CACD,CAEDC,MAAO,CACL,KAAKD,aAAL,EACA,KAAKhP,OAAL,CACD,CAEDjQ,OAAQ,CACN,GAAI,KAAKqe,UAAY,KAAKnJ,WAAa,KAAKoJ,UAI1C,OAGF,IAAMtnB,EAAQ,KAAKnB,KAAK6H,UAExB,KAAKjE,OAAS,GACd,KAAK6kB,UAAY,GACjB,KAAKpJ,UAAY,GACjB,KAAKqJ,UAAY,KAAK1oB,KAAKD,QAAQupB,sBAE/BnoB,GAASA,EAAMC,cAAgBD,EAAMzF,OAAS,KAAKsE,KAAKD,QAAQwpB,oBAClE,KAAKb,UAAY,GAGnB,KAAKc,iBAAL,EACAtX,WAAW,IAAM,CACf,KAAKkI,OAAL,CACD,EAAE,KAAKwO,aAAe,GAAK,CAFlB,CAGX,CAGDQ,cAAe,CAEb,GADA,KAAKppB,KAAKiiB,IAAI,eAAgB,KAAKmH,YAAnC,EACI,CAAC,KAAKX,UAAW,CACnB,IAAMtnB,EAAQ,KAAKnB,KAAK6H,UACxB,KAAK4gB,UAAY,GACjB,KAAKpJ,UAAY,GACjB,KAAKqJ,UAAY,KAAK1oB,KAAKD,QAAQ0pB,sBAC/BtoB,GAASA,EAAM4B,WAAWT,QAAUnB,EAAMzF,OAAS,KAAKsE,KAAKD,QAAQwpB,oBACvE,KAAKb,UAAY,GAEnB,KAAKc,iBAAL,CACD,CACF,CAGDA,kBAAmB,CACjB,GAAM,CAAExpB,KAAAA,CAAF,EAAW,KACXmB,EAAQ,KAAKnB,KAAK6H,UAClB,CAAE9H,QAAAA,CAAF,EAAcC,EAyBpB,GAvBID,EAAQ2pB,wBAA0B,QACpC3pB,EAAQ4pB,gBAAkB,GAC1B,KAAKR,aAAervB,QACXiG,EAAQ2pB,wBAA0B,QAC3C3pB,EAAQ4pB,gBAAkB,GAC1B,KAAKjB,UAAY,EACjB,KAAKS,aAAervB,QACX,KAAK2uB,WAAazoB,EAAK4pB,oBAEhC,KAAKT,aAAenpB,EAAK4pB,oBAEzB,KAAKT,aAAe,KAAKnpB,KAAKqgB,eAAV,EAGtB,KAAK0I,aAAe5nB,GAApB,KAAoBA,OAAAA,EAAOyE,sBAAP,EAEpB5F,EAAKsG,WAAWqC,QAAhB,EAGA,KAAKggB,cAAgBhhB,GAAQ,KAAK+gB,WAAa,KAAKA,UAAY,IAChE,KAAKmB,aAAeliB,EAAQ,KAAKwhB,eACVhoB,GADH,KAAA,OACGA,EAAO0C,QAAQyf,eAAf,KACC,CAAC,KAAKjE,WAAa,CAACrf,EAAKiF,WAAWC,UAAhB,GACxC,CAAC,KAAK2kB,aACR,KAAKhB,oBAAsB,GAEvB,KAAKJ,WAAatnB,IACpBA,EAAM4D,oBAAN,EACA5D,EAAM6D,oBAAN,OAEG,CAAA,IAAA8kB,EACL,KAAKjB,qBAAsB9oB,EAAAA,EAAQ4pB,mBAAnC,MAAAG,IAAA,OAAAA,EAAsD,EACvD,CAID,GAHA,KAAKhB,kBAAoB,CAAC,KAAKD,qBAAuB,KAAK7oB,KAAKD,QAAQmJ,UAAYof,EACpF,KAAKU,gBAAkB,KAAKH,oBAAsB7oB,EAAK+F,QAAU/F,EAAK+pB,GAElE,CAAC,KAAKpB,cAAe,CACvB,KAAKD,UAAY,EACjB,KAAKmB,aAAe,GACpB,KAAKf,kBAAoB,GACzB,KAAKD,oBAAsB,GACvB,KAAKJ,YACHzoB,EAAK+F,UACP/F,EAAK+F,QAAQhL,MAAMivB,QAAUjF,OAAOuD,CAAD,GAErCtoB,EAAKoJ,eAAe,CAApB,GAEF,MACD,CAED,GAAI,KAAKygB,cAAgB,KAAKV,cAAgB,KAAKA,aAAa/I,UAAW,CAAA,IAAA7U,EAEzE,KAAKqd,aAAe,GACpB,KAAKK,gBAAkB,KAAKjpB,KAAKgE,UACjC,KAAKklB,iBAAL3d,EAAuB,KAAKvL,KAAK6H,aAAjC,MAAA0D,IAAA,OAAA,OAAuBA,EAAqBtH,cAExCjE,EAAKgE,YACPhE,EAAKgE,UAAUjJ,MAAMkvB,SAAW,SAChCjqB,EAAKgE,UAAUjJ,MAAMW,MAAQsE,EAAKO,aAAa5G,EAAI,KAEtD,MACC,KAAKivB,aAAe,GAGlB,KAAKH,WAEH,KAAKI,qBACH7oB,EAAK+F,UACP/F,EAAK+F,QAAQhL,MAAMivB,QAAUjF,OAAOuD,CAAD,GAErCtoB,EAAKoJ,eAAe,CAApB,IAEI,KAAK0f,mBAAqB9oB,EAAK+pB,KACjC/pB,EAAK+pB,GAAGhvB,MAAMivB,QAAUjF,OAAOuD,CAAD,GAE5BtoB,EAAK+F,UACP/F,EAAK+F,QAAQhL,MAAMivB,QAAU,MAI7B,KAAKH,eACP,KAAKK,uBAAL,EACI,KAAKnB,eAEP,KAAKA,aAAahuB,MAAMovB,WAAa,YAIrC,KAAKpB,aAAahuB,MAAMivB,QAAUjF,OAAOuD,CAAD,KAGnC,KAAKjJ,YAGVrf,EAAKiF,WAAW6O,YAAY,CAA5B,IACF9T,EAAKiF,WAAW6O,YAAY,CAA5B,EAA+Bza,GAAG0B,MAAMyZ,QAAU,QAEhDxU,EAAKiF,WAAW6O,YAAY,CAA5B,IACF9T,EAAKiF,WAAW6O,YAAY,CAA5B,EAA+Bza,GAAG0B,MAAMyZ,QAAU,QAGhD,KAAKoU,cACH5oB,EAAKiF,WAAWtL,IAAM,IAExBqG,EAAKiF,WAAWmP,cAAhB,EACApU,EAAKiF,WAAWK,OAAhB,GAIP,CAGD8U,QAAS,CACH,KAAKqO,WACF,KAAKE,eACL,KAAKI,cACL,KAAKA,aAAa5vB,UAAY,MAOnC,IAAI+C,QAASC,GAAY,CACvB,IAAIiuB,EAAU,GACVC,EAAa,GACjBxuB,GAA6C,KAAKktB,YAAvC,EAAsDzD,QAAQ,IAAM,CAC7E8E,EAAU,GACLC,GACHluB,EAAQ,EAAD,EAHX,EAMA+V,WAAW,IAAM,CACfmY,EAAa,GACTD,GACFjuB,EAAQ,EAAD,GAER,EALO,EAMV+V,WAAW/V,EAAS,GAAV,CACX,CAhBD,EAgBGmpB,QAAQ,IAAM,KAAKgF,UAAL,CAhBjB,EAkBA,KAAKA,UAAL,CAEH,CAGDA,WAAY,CAAA,IAAAC,EAAAC,GACVD,EAAA,KAAKvqB,KAAK+F,WAAV,MAAAwkB,IAAA,QAAAA,EAAmBxvB,MAAM0vB,YAAY,6BAA8B,KAAK/B,UAAY,IAApF,EAEA,KAAK1oB,KAAKwB,SACR,KAAKinB,UAAY,wBAA0B,uBAD7C,EAKA,KAAKzoB,KAAKwB,SAEP,eAAiB,KAAKinB,UAAY,KAAO,MAF5C,GAKKzoB,EAAAA,KAAAA,KAAK+F,WAAS0H,MAAAA,IAAAA,QAAAA,EAAAA,UAAUY,OAAO,mBAAoB,KAAKoa,SAA7D,EAEI,KAAKA,WACH,KAAKM,eAEP,KAAKA,aAAahuB,MAAMivB,QAAU,KAEpC,KAAKU,oBAAL,GACS,KAAKrL,WACd,KAAKsL,sBAAL,EAGG,KAAKhC,eACR,KAAKiC,qBAAL,CAEH,CAGDA,sBAAuB,CACrB,GAAM,CAAE5qB,KAAAA,CAAF,EAAW,KAgBjB,GAfA,KAAK4D,OAAS,KAAK6kB,UACnB,KAAKD,SAAW,KAAKnJ,UACrB,KAAKoJ,UAAY,GACjB,KAAKpJ,UAAY,GAEjBrf,EAAKwB,SACH,KAAKoC,OAAS,sBAAwB,qBADxC,EAKA5D,EAAKwB,SAEF,eAAiB,KAAKoC,OAAS,QAAU,SAF5C,EAKI,KAAK4kB,SACPxoB,EAAKoF,QAAL,UACS,KAAKxB,OAAQ,CAAA,IAAAga,EAClB,KAAKiM,cAAgB7pB,EAAKgE,YAC5BhE,EAAKgE,UAAUjJ,MAAMkvB,SAAW,UAChCjqB,EAAKgE,UAAUjJ,MAAMW,MAAQ,SAE/BkiB,EAAA5d,EAAK6H,aAAL,MAAA+V,IAAA,QAAAA,EAAgB5Y,oBAAhB,CACD,CACF,CAGD0lB,qBAAsB,CACpB,GAAM,CAAE1qB,KAAAA,CAAF,EAAW,KACb,KAAK6pB,eACH,KAAKjB,cAAgB,KAAKK,iBAAmB,KAAKC,kBACpD,KAAK2B,WAAW,KAAK5B,gBAAiB,YAAa,oBAAnD,EACA,KAAK4B,WAAW,KAAK3B,gBAAiB,YAAa,MAAnD,GAGElpB,EAAK6H,YACP7H,EAAK6H,UAAU9C,oBAAf,EACA,KAAK8lB,WACH7qB,EAAK6H,UAAU7D,UACf,YACAhE,EAAK6H,UAAUb,oBAAf,CAHF,IAQA,KAAK8hB,mBAAqB9oB,EAAK+pB,IACjC,KAAKc,WAAW7qB,EAAK+pB,GAAI,UAAWhF,OAAO/kB,EAAKD,QAAQmJ,SAAd,CAA1C,EAGE,KAAK2f,qBAAuB7oB,EAAK+F,SACnC,KAAK8kB,WAAW7qB,EAAK+F,QAAS,UAAW,GAAzC,CAEH,CAGD4kB,uBAAwB,CACtB,GAAM,CAAE3qB,KAAAA,CAAF,EAAW,KAEb,KAAK6pB,cACP,KAAKK,uBAAuB,EAA5B,EAIE,KAAKpB,mBAAqB9oB,EAAKkJ,UAAY,KAAQlJ,EAAK+pB,IAC1D,KAAKc,WAAW7qB,EAAK+pB,GAAI,UAAW,GAApC,EAGE,KAAKlB,qBAAuB7oB,EAAK+F,SACnC,KAAK8kB,WAAW7qB,EAAK+F,QAAS,UAAW,GAAzC,CAEH,CAMDmkB,uBAAuBvV,EAAS,CAC9B,GAAI,CAAC,KAAKwU,aAAc,OAExB,GAAM,CAAEnpB,KAAAA,CAAF,EAAW,KACX,CAAEogB,UAAAA,CAAF,EAAgB,KAAK+I,aACrB,CAAEthB,UAAAA,EAAWtH,aAAAA,CAAb,EAA8BP,EAEpC,GAAI,KAAK4oB,cAAgBxI,GAAa,KAAK6I,iBAAmB,KAAKC,gBAAiB,CAClF,IAAM4B,EAAmB,CAACvqB,EAAa5G,GAAK,KAAKwvB,aAAaxvB,EAAIymB,EAAUzmB,GAAKymB,EAAU5kB,EACrFuvB,EAAmB,CAACxqB,EAAa3G,GAAK,KAAKuvB,aAAavvB,EAAIwmB,EAAUxmB,GAAKwmB,EAAU3kB,EACrFuvB,EAAmBzqB,EAAa5G,EAAIymB,EAAU5kB,EAC9CyvB,EAAmB1qB,EAAa3G,EAAIwmB,EAAU3kB,EAGhDkZ,GACF,KAAKkW,WACH,KAAK5B,gBACL,YACAtuB,EAAkBmwB,EAAkBC,CAAnB,CAHnB,EAMA,KAAKF,WACH,KAAK3B,gBACL,YACAvuB,EAAkBqwB,EAAkBC,CAAnB,CAHnB,IAMAnwB,EAAa,KAAKmuB,gBAAiB6B,EAAkBC,CAAzC,EACZjwB,EAAa,KAAKouB,gBAAiB8B,EAAkBC,CAAzC,EAEf,CAEGpjB,IACFrO,EAAeqO,EAAUpE,IAAK2c,GAAa,KAAK+I,YAAlC,EACdthB,EAAUzG,cAAgB,KAAK+nB,aAAa3tB,EAAIqM,EAAUnM,MACtDiZ,EACF,KAAKkW,WAAWhjB,EAAU7D,UAAW,YAAa6D,EAAUb,oBAAV,CAAlD,EAEAa,EAAU7C,oBAAV,EAGL,CAQD6lB,WAAWhsB,EAAQ1D,EAAMN,EAAW,CAClC,GAAI,CAAC,KAAK6tB,UAAW,CACnB7pB,EAAO9D,MAAMI,CAAb,EAAqBN,EACrB,MACD,CAED,GAAM,CAAEyL,WAAAA,CAAF,EAAiB,KAAKtG,KAEtBkrB,EAAY,CAChB9vB,SAAU,KAAKstB,UACfxhB,OAAQ,KAAKlH,KAAKD,QAAQmH,OAC1BD,WAAY,IAAM,CACXX,EAAW6T,iBAAiBrH,QAC/B,KAAK8X,qBAAL,GAGJ/rB,OAAAA,GAEFqsB,EAAU/vB,CAAD,EAASN,EAClByL,EAAWO,gBAAgBqkB,CAA3B,CACD,CAhbU,EC4MPC,GAAiB,CACrBlgB,eAAgB,GAChBgJ,QAAS,GACT4I,KAAM,GACNtQ,aAAc,GACdxD,oBAAqB,GACrBugB,sBAAuB,IACvBG,sBAAuB,IACvBriB,sBAAuB,IACvB0Q,OAAQ,GACRC,UAAW,GACXb,UAAW,GACXO,YAAa,GACb8R,kBAAmB,IACnBnb,wBAAyB,GACzBoR,iBAAkB,gBAClB4L,cAAe,QACfC,UAAW,kBACXpZ,gBAAiB,OACjBmM,kBAAmB,MACnBL,eAAgB,IAChB7U,UAAW,GAEXzI,MAAO,EACP2kB,SAAU,6BACVa,QAAS,CAAC,EAAG,CAAJ,EACT/e,OAAQ,0BA1Ba,EAgCjBokB,EAAN,cAAyB3E,EAAe,CAItCjoB,YAAYqB,EAAS,CACnB,MAAA,EAEA,KAAKA,QAAU,KAAKwrB,gBAAgBxrB,GAAW,CAAA,CAAhC,EAOf,KAAKqT,OAAS,CAAEzZ,EAAG,EAAGC,EAAG,GAMzB,KAAK4xB,kBAAoB,CAAE7xB,EAAG,EAAGC,EAAG,GAOpC,KAAK2G,aAAe,CAAE5G,EAAG,EAAGC,EAAG,GAK/B,KAAKsP,UAAY,EACjB,KAAK3F,UAAY,EACjB,KAAKuR,eAAiB,EACtB,KAAKlR,OAAS,GACd,KAAK6nB,aAAe,GACpB,KAAKC,SAAW,GAMhB,KAAKC,iBAAmB,CAAA,EAExB,KAAK/B,oBAAsB9vB,OAG3B,KAAK4iB,OAAS5iB,OAEd,KAAKiM,QAAUjM,OAEf,KAAKke,SAAWle,OAEhB,KAAKkK,UAAYlK,OAEjB,KAAKgW,WAAahW,OAElB,KAAK+N,UAAY/N,OAEjB,KAAK+V,OAAS,IAAIpR,EAClB,KAAK6H,WAAa,IAAI4T,GACtB,KAAKjV,WAAa,IAAIwO,GAAW,IAAf,EAClB,KAAKjL,SAAW,IAAIiG,GAAS,IAAb,EAChB,KAAK9K,OAAS,IAAI4kB,GAAO,IAAX,EACd,KAAKqD,SAAW,IAAI5U,GAAS,IAAb,EAChB,KAAKlT,cAAgB,IAAIiiB,GAAc,IAAlB,CACtB,CAGDnH,MAAO,CACL,GAAI,KAAKhb,QAAU,KAAK6nB,aACtB,MAAO,GAGT,KAAK7nB,OAAS,GACd,KAAKpC,SAAS,MAAd,EACA,KAAKA,SAAS,YAAd,EAEA,KAAKqqB,qBAAL,EAGA,IAAIC,EAAc,aAClB,OAAI,KAAKtjB,SAAS0G,gBAChB4c,GAAe,gBAEb,KAAK/rB,QAAQgsB,YACfD,GAAe,IAAM,KAAK/rB,QAAQgsB,WAEhC,KAAKhmB,UACP,KAAKA,QAAQ7M,WAAa,IAAM4yB,GAGlC,KAAKvoB,UAAY,KAAKxD,QAAQU,OAAS,EACvC,KAAKqU,eAAiB,KAAKvR,UAC3B,KAAK/B,SAAS,aAAd,EAGA,KAAKwqB,YAAc,IAAItR,GAAY,IAAhB,GAGf1Z,OAAOirB,MAAM,KAAK1oB,SAAlB,GACG,KAAKA,UAAY,GACjB,KAAKA,WAAa,KAAKmR,YAAL,KACvB,KAAKnR,UAAY,GAGd,KAAKiF,SAAS0G,eAEjB,KAAK6B,cAAL,EAIF,KAAKmb,WAAL,EAEA,KAAK9Y,OAAOxZ,EAAIwE,OAAO+tB,YAEvB,KAAKR,iBAAmB,KAAK7F,YAAY,KAAKviB,SAAtB,EACxB,KAAK/B,SAAS,cAAe,CAC3Bf,MAAO,KAAK8C,UACZ3B,KAAM,KAAK+pB,iBACXxqB,MAAOrH,MAHoB,CAA7B,EAOA,KAAK8vB,oBAAsB,KAAKvJ,eAAL,EAC3B,KAAK7e,SAAS,eAAd,EAEA,KAAKoO,GAAG,sBAAuB,IAAM,CACnC,GAAM,CAAEkE,YAAAA,GAAgB,KAAK7O,WAGzB6O,EAAY,CAAD,IACbA,EAAY,CAAD,EAAIza,GAAG0B,MAAMyZ,QAAU,QAClC,KAAKuB,WAAWjC,EAAY,CAAD,EAAK,KAAKvQ,UAAY,CAAjD,GAEEuQ,EAAY,CAAD,IACbA,EAAY,CAAD,EAAIza,GAAG0B,MAAMyZ,QAAU,QAClC,KAAKuB,WAAWjC,EAAY,CAAD,EAAK,KAAKvQ,UAAY,CAAjD,GAGF,KAAKuB,YAAL,EAEA,KAAKhB,cAAcoS,WAAnB,EAEA,KAAKrG,OAAOjR,IAAIR,OAAQ,SAAU,KAAKguB,kBAAkBpc,KAAK,IAA5B,CAAlC,EACA,KAAKH,OAAOjR,IAAIR,OAAQ,SAAU,KAAKiuB,wBAAwBrc,KAAK,IAAlC,CAAlC,EACA,KAAKxO,SAAS,YAAd,CACD,CApBD,EAuBI,KAAKyD,WAAW6O,YAAY,CAA5B,GACF,KAAKiC,WAAW,KAAK9Q,WAAW6O,YAAY,CAA5B,EAAgC,KAAKvQ,SAArD,EAEF,KAAK/B,SAAS,QAAd,EAEA,KAAKmC,OAAO0lB,KAAZ,EAEA,KAAK7nB,SAAS,WAAd,EAEO,EACR,CASDyT,eAAexU,EAAO,CACpB,IAAMsU,EAAY,KAAKL,YAAL,EAElB,OAAI,KAAK3U,QAAQ8c,OACXpc,EAAQsU,EAAY,IACtBtU,GAASsU,GAGPtU,EAAQ,IACVA,GAASsU,IAINxa,EAAMkG,EAAO,EAAGsU,EAAY,CAAvB,CACb,CAEDjQ,aAAc,CACZ,KAAKG,WAAW6O,YAAY1U,QAAS+U,GAAe,CAAA,IAAA0B,GAClDA,EAAA1B,EAAWhT,SAAX,MAAA0U,IAAA,QAAAA,EAAkB/Q,YAAlB,EADF,CAGD,CAMDwnB,KAAK7rB,EAAO,CACV,KAAKwE,WAAW0E,YACd,KAAKsL,eAAexU,CAApB,EAA6B,KAAKqU,cADpC,CAGD,CAKDyX,MAAO,CACL,KAAKD,KAAK,KAAKxX,eAAiB,CAAhC,CACD,CAKD0X,MAAO,CACL,KAAKF,KAAK,KAAKxX,eAAiB,CAAhC,CACD,CAOD9O,UAAU4b,EAAM,CAAA,IAAA6K,GACdA,EAAA,KAAK5kB,aAAL,MAAA4kB,IAAA,QAAAA,EAAgBzmB,OAAO,GAAG4b,CAA1B,CACD,CAKDza,YAAa,CAAA,IAAAulB,GACN7kB,EAAAA,KAAAA,aAAL,MAAA6kB,IAAA,QAAAA,EAAgBvlB,WAAhB,CACD,CAMDgD,OAAQ,CACF,CAAC,KAAKxG,OAAOC,QAAU,KAAK6nB,eAIhC,KAAKA,aAAe,GAEpB,KAAKjqB,SAAS,OAAd,EAEA,KAAKqO,OAAO1Q,UAAZ,EACA,KAAKwE,OAAOwG,MAAZ,EACD,CASD/E,SAAU,CAAA,IAAAsd,EACR,GAAI,CAAC,KAAK+I,aAAc,CACtB,KAAK1rB,QAAQ2pB,sBAAwB,OACrC,KAAKvf,MAAL,EACA,MACD,CAED,KAAK3I,SAAS,SAAd,EAEA,KAAKyf,WAAa,CAAA,EAEd,KAAKnR,aACP,KAAKA,WAAWI,YAAc,KAC9B,KAAKJ,WAAWK,WAAa,OAG1BpK,EAAAA,KAAAA,WAAL,MAAA2c,IAAA,QAAAA,EAAcxjB,OAAd,EAEA,KAAK+F,WAAW6O,YAAY1U,QAAS+U,GAAe,CAAA,IAAAwY,GAClDA,EAAAxY,EAAWhT,SAAX,MAAAwrB,IAAA,QAAAA,EAAkBvnB,QAAlB,EADF,EAIA,KAAKtB,cAAcsB,QAAnB,EACA,KAAKyK,OAAO1Q,UAAZ,CACD,CAODytB,oBAAoBC,EAAY,CAC9B,KAAK/oB,cAAcyiB,cAAcsG,CAAjC,EACA,KAAK5nB,WAAW6O,YAAY1U,QAAQ,CAAC+U,EAAYG,IAAM,CAAA,IAAAwY,EAAAC,EACrD,IAAIC,IAAwBF,GAAAC,EAAA,KAAKllB,aAAN,MAAAklB,IAAA,OAAA,OAACA,EAAgBtsB,SAAS,MAAAqsB,IAAA,OAAAA,EAAA,GAAK,EAAIxY,EAI9D,GAHI,KAAKU,QAAL,IACFgY,EAAuB,KAAK/X,eAAe+X,CAApB,GAErBA,IAAyBH,IAE3B,KAAK9W,WAAW5B,EAAY0Y,EAAY,EAAxC,EAGIvY,IAAM,GAAG,CAAA,IAAA2Y,EACX,KAAKplB,UAAYsM,EAAWhT,OAC5B8rB,EAAA9Y,EAAWhT,SAAOmD,MAAAA,IAAAA,QAAAA,EAAAA,YAAY,EAA9B,CACD,EAbL,EAiBA,KAAK9C,SAAS,QAAd,CACD,CAUDuU,WAAWmX,EAAQzsB,EAAO+E,EAAO,CAK/B,GAJI,KAAKwP,QAAL,IACFvU,EAAQ,KAAKwU,eAAexU,CAApB,GAGNysB,EAAO/rB,MAAO,CAChB,GAAI+rB,EAAO/rB,MAAMV,QAAUA,GAAS,CAAC+E,EAGnC,OAIF0nB,EAAO/rB,MAAMiE,QAAb,EACA8nB,EAAO/rB,MAAQrH,MAChB,CAGD,GAAI,CAAC,KAAKkb,QAAL,IAAmBvU,EAAQ,GAAKA,GAAS,KAAKiU,YAAL,GAC5C,OAGF,IAAMlU,EAAW,KAAKslB,YAAYrlB,CAAjB,EACjBysB,EAAO/rB,MAAQ,IAAIkC,EAAM7C,EAAUC,EAAO,IAA3B,EAGXA,IAAU,KAAK8C,YACjB,KAAKsE,UAAYqlB,EAAO/rB,OAG1B+rB,EAAO/rB,MAAMsD,OAAOyoB,EAAO7zB,EAA3B,CACD,CAGDiO,wBAAyB,CACvB,MAAO,CACL3N,EAAG,KAAK4G,aAAa5G,EAAI,EACzBC,EAAG,KAAK2G,aAAa3G,EAAI,EAE5B,CAQDsyB,WAAW1mB,EAAO,CAIhB,GAAI,KAAKimB,aAGP,OAMF,IAAMvrB,EAAkBJ,GAAgB,KAAKC,QAAS,IAAf,EAEnC,CAACyF,GAASlL,EAAY4F,EAAiB,KAAKsrB,iBAAvB,IAOzBhyB,EAAe,KAAKgyB,kBAAmBtrB,CAAzB,EAEd,KAAKsB,SAAS,cAAd,EAEAhI,EAAe,KAAK+G,aAAc,KAAKirB,iBAAzB,EAEd,KAAKa,wBAAL,EAEA,KAAK7qB,SAAS,cAAd,EAIA,KAAKyD,WAAWK,OAAO,KAAK3B,OAAOC,MAAnC,EAEI,CAAC,KAAK8nB,UAAYttB,OAAO+uB,WAAW,oBAAlB,EAAwCzM,SAC5D,KAAK3P,cAAL,EAGF,KAAKvP,SAAS,QAAd,EACD,CAKD4H,eAAe4gB,EAAS,CACtB,KAAK9gB,UAAYjP,KAAKS,IAAIsvB,EAAS,CAAlB,EACb,KAAKD,KACP,KAAKA,GAAGhvB,MAAMivB,QAAUjF,OAAO,KAAK7b,UAAY,KAAKnJ,QAAQmJ,SAA/B,EAEjC,CAKD6H,eAAgB,CACd,GAAI,CAAC,KAAK2a,SAAU,CAAA,IAAA0B,EAClB,KAAK1B,SAAW,IAChB0B,EAAA,KAAKrnB,WAAS0H,MAAAA,IAAAA,QAAAA,EAAAA,UAAU7O,IAAI,iBAA5B,CACD,CACF,CAODwtB,mBAAoB,CAClB,KAAKF,WAAL,EAOI,oBAAoBmB,KAAKjvB,OAAOJ,UAAUsvB,SAA1C,GACFpb,WAAW,IAAM,CACf,KAAKga,WAAL,GACC,GAFO,CAIb,CASDG,yBAA0B,CACxB,KAAKkB,gBAAgB,EAAGnvB,OAAO+tB,WAA/B,CACD,CAMDoB,gBAAgB5zB,EAAGC,EAAG,CACpB,KAAKwZ,OAAOzZ,EAAIA,EAChB,KAAKyZ,OAAOxZ,EAAIA,EAChB,KAAK4H,SAAS,oBAAd,CACD,CAQDqqB,sBAAuB,CAErB,KAAK9lB,QAAU9M,EAAc,OAAQ,KAAT,EAC5B,KAAK8M,QAAQwO,aAAa,WAAY,IAAtC,EACA,KAAKxO,QAAQwO,aAAa,OAAQ,QAAlC,EAGA,KAAKyD,SAAW,KAAKjS,QAIrB,KAAKgkB,GAAK9wB,EAAc,WAAY,MAAO,KAAK8M,OAAzB,EACvB,KAAK+J,WAAa7W,EAAc,oBAAqB,UAAW,KAAK8M,OAAtC,EAC/B,KAAK/B,UAAY/K,EAAc,kBAAmB,MAAO,KAAK6W,UAAhC,EAG9B,KAAKA,WAAWyE,aAAa,uBAAwB,UAArD,EACA,KAAKvQ,UAAUuQ,aAAa,YAAa,KAAzC,EACA,KAAKvQ,UAAUuQ,aAAa,KAAM,aAAlC,EAEA,KAAKtP,WAAWoP,cAAhB,EAEA,KAAK2J,GAAK,IAAIO,GAAG,IAAP,EACV,KAAKP,GAAGY,KAAR,GAGC,KAAK7e,QAAQ3G,YAAcE,SAASk0B,MAAMj0B,YAAY,KAAKwM,OAA5D,CACD,CAWDsa,gBAAiB,CACf,OAAOA,GACL,KAAK9c,UACL,KAAKsE,UAAY,KAAKA,UAAUjG,KAAO,KAAK+pB,iBAC5C,IAHmB,CAKtB,CAMD3W,SAAU,CACR,OAAQ,KAAKjV,QAAQ8c,MAAQ,KAAKnI,YAAL,EAAqB,CACnD,CAOD6W,gBAAgBxrB,EAAS,CACvB,OAAI3B,OAAO+uB,WAAW,0CAAlB,EAA8DzM,UAChE3gB,EAAQ2pB,sBAAwB,OAChC3pB,EAAQqH,sBAAwB,GAI3BqmB,IAAA,GACFtC,IACAprB,EAEN,CAhiBqC,ECzPjC,SAAS2tB,EAAcC,EAAWC,EAASC,EAAY,CAC5D,IAAMC,EAAKC,SAASL,cAAcE,CAAvB,EACX,OAAID,IACFG,EAAGH,UAAYA,GAEbE,GACFA,EAAWG,YAAYF,CAAvB,EAEKA,CACR,CAoEM,SAASG,GAAkBC,EAAGC,EAAGC,EAAO,CAC7C,IAAIC,EAAa,eAAcH,CAAE,MAAKC,GAAK,CAAE,QAE7C,OAAIC,IAAUE,SACZD,GAAc,YAAWD,CAAM,IAAGA,CAAM,OAGnCC,CACR,CAwCM,SAASE,GAAeT,EAAIU,EAAGC,EAAG,CACvCX,EAAGY,MAAMC,MAAS,OAAOH,GAAM,SAAa,GAAEA,CAAE,KAAMA,EACtDV,EAAGY,MAAME,OAAU,OAAOH,GAAM,SAAa,GAAEA,CAAE,KAAMA,CACxD,CA8BM,IAAMI,EAAa,CACxBC,KAAM,OACNC,QAAS,UACTC,OAAQ,SACRC,MAAO,OAJiB,EAenB,SAASC,GAAeC,EAAG,CAChC,MAAQ,WAAYA,GAAKA,EAAEC,SAAW,GAAMD,EAAEE,SAAWF,EAAEG,SAAWH,EAAEI,QAAUJ,EAAEK,QACrF,CAUM,SAASC,EAAsBC,EAAQC,EAAgBC,EAAS7B,SAAU,CAE/E,IAAI8B,EAAW,CAAA,EAEf,GAAIH,aAAkBI,QACpBD,EAAW,CAACH,CAAD,UACFA,aAAkBK,UAAYC,MAAMC,QAAQP,CAAd,EACvCG,EAAWG,MAAME,KAAKR,CAAX,MACN,CACL,IAAMS,EAAW,OAAOT,GAAW,SAAWA,EAASC,EACnDQ,IACFN,EAAWG,MAAME,KAAKN,EAAOQ,iBAAiBD,CAAxB,CAAX,EAEd,CAED,OAAON,CACR,CAQM,SAASQ,GAAYC,EAAI,CAC9B,OAAO,OAAOA,GAAO,YAChBA,EAAGC,WACHD,EAAGC,UAAUC,IACnB,CAOM,SAASC,IAAW,CACzB,MAAO,CAAC,EAAEC,UAAUC,QAAUD,UAAUC,OAAOC,MAAM,QAAvB,EAC/B,CCvBD,IAAMC,GAAN,KAAsB,CAKpBC,YAAYC,EAAMC,EAAS,CACzB,KAAKD,KAAOA,EACZ,KAAKE,iBAAmB,GACpBD,GACFE,OAAOC,OAAO,KAAMH,CAApB,CAEH,CAEDI,gBAAiB,CACf,KAAKH,iBAAmB,EACzB,CAfmB,EAsBhBI,GAAN,KAAgB,CACdP,aAAc,CAIZ,KAAKQ,WAAa,CAAA,EAKlB,KAAKC,SAAW,CAAA,EAGhB,KAAKC,KAAOlD,OAGZ,KAAKmD,QAAUnD,MAChB,CAQDoD,UAAUC,EAAMrB,EAAIsB,EAAW,IAAK,CAAA,IAAAC,EAAAC,EAAAC,EAC7B,KAAKR,SAASI,CAAd,IACH,KAAKJ,SAASI,CAAd,EAAsB,CAAA,IAGxBE,EAAA,KAAKN,SAASI,CAAd,KAAA,MAAAE,IAAA,QAAAA,EAAqBG,KAAK,CAAE1B,GAAAA,EAAIsB,SAAAA,EAAhC,GACAE,EAAA,KAAKP,SAASI,CAAd,KAAqBM,MAAAA,IAAAA,QAAAA,EAAAA,KAAK,CAACC,EAAIC,IAAOD,EAAGN,SAAWO,EAAGP,QAAvD,GAEKJ,EAAAA,KAAAA,QAAL,MAAAO,IAAA,QAAAA,EAAWL,UAAUC,EAAMrB,EAAIsB,CAA/B,CACD,CAODQ,aAAaT,EAAMrB,EAAI,CACjB,KAAKiB,SAASI,CAAd,IAEF,KAAKJ,SAASI,CAAd,EAAsB,KAAKJ,SAASI,CAAd,EAAoBU,OAAOA,GAAWA,EAAO/B,KAAOA,CAApD,GAGpB,KAAKkB,MACP,KAAKA,KAAKY,aAAaT,EAAMrB,CAA7B,CAEH,CAQDgC,aAAaX,KAASY,EAAM,CAAA,IAAAC,EAC1B,OAAAA,EAAA,KAAKjB,SAASI,CAAd,KAAA,MAAAa,IAAA,QAAAA,EAAqBC,QAASJ,GAAW,CAEvCE,EAAK,CAAD,EAAMF,EAAO/B,GAAGoC,MAAM,KAAMH,CAAtB,EAFZ,EAIOA,EAAK,CAAD,CACZ,CAODI,GAAGhB,EAAMrB,EAAI,CAAA,IAAAsC,EAAAC,EACN,KAAKvB,WAAWK,CAAhB,IACH,KAAKL,WAAWK,CAAhB,EAAwB,CAAA,IAErBL,EAAAA,KAAAA,WAAWK,CAAhB,KAAA,MAAAiB,IAAA,QAAAA,EAAuBZ,KAAK1B,CAA5B,GAKAuC,EAAA,KAAKrB,QAAMmB,MAAAA,IAAAA,QAAAA,EAAAA,GAAGhB,EAAMrB,CAApB,CACD,CAODwC,IAAInB,EAAMrB,EAAI,CAAA,IAAAyC,EACR,KAAKzB,WAAWK,CAAhB,IAEF,KAAKL,WAAWK,CAAhB,EAAwB,KAAKL,WAAWK,CAAhB,EAAsBU,OAAOW,GAAa1C,IAAO0C,CAAjD,IAG1BD,EAAA,KAAKvB,QAAMsB,MAAAA,IAAAA,QAAAA,EAAAA,IAAInB,EAAMrB,CAArB,CACD,CAQD2C,SAAStB,EAAMX,EAAS,CAAA,IAAAkC,EACtB,GAAI,KAAK1B,KACP,OAAO,KAAKA,KAAKyB,SAAStB,EAAMX,CAAzB,EAGT,IAAMmC,EAA0C,IAAItC,GAAgBc,EAAMX,CAA1B,EAEhD,OAAAkC,EAAA,KAAK5B,WAAWK,CAAhB,KAAA,MAAAuB,IAAA,QAAAA,EAAuBT,QAASO,GAAa,CAC3CA,EAASI,KAAK,KAAMD,CAApB,EADF,EAIOA,CACR,CAnHa,ECpOVE,GAAN,KAAkB,CAKhBvC,YAAYwC,EAAUC,EAAW,CAU/B,GANA,KAAKC,QAAU9F,EACb,mCACA4F,EAAW,MAAQ,MACnBC,CAH0B,EAMxBD,EAAU,CACZ,IAAMG,EAAyC,KAAKD,QACpDC,EAAMC,SAAW,QACjBD,EAAME,IAAM,GACZF,EAAMG,IAAMN,EACZG,EAAMI,aAAa,OAAQ,cAA3B,CACD,CAED,KAAKL,QAAQK,aAAa,cAAe,MAAzC,CACD,CAMDC,iBAAiBnF,EAAOC,EAAQ,CACzB,KAAK4E,UAIN,KAAKA,QAAQ5F,UAAY,OAI3BW,GAAe,KAAKiF,QAAS,IAAK,MAApB,EACd,KAAKA,QAAQ9E,MAAMqF,gBAAkB,MACrC,KAAKP,QAAQ9E,MAAMsF,UAAY/F,GAAkB,EAAG,EAAGU,EAAQ,GAAf,GAEhDJ,GAAe,KAAKiF,QAAS7E,EAAOC,CAAtB,EAEjB,CAEDqF,SAAU,CAAA,IAAAC,GACRA,EAAI,KAAKV,WAAL,MAAAU,IAAA,QAAAA,EAAcC,YAChB,KAAKX,QAAQY,OAAb,EAEF,KAAKZ,QAAU,IAChB,CApDe,ECMZa,GAAN,KAAc,CAMZvD,YAAYwD,EAAUC,EAAUC,EAAO,CACrC,KAAKD,SAAWA,EAChB,KAAKE,KAAOH,EACZ,KAAKE,MAAQA,EAGb,KAAKhB,QAAUlF,OAEf,KAAKoG,YAAcpG,OAEnB,KAAKqG,MAAQrG,OAEb,KAAKsG,oBAAsB,EAC3B,KAAKC,qBAAuB,EAE5B,KAAKlG,MAAQmG,OAAO,KAAKL,KAAKjG,CAAX,GAAiBsG,OAAO,KAAKL,KAAK9F,KAAX,GAAqB,EAC/D,KAAKC,OAASkG,OAAO,KAAKL,KAAKhG,CAAX,GAAiBqG,OAAO,KAAKL,KAAK7F,MAAX,GAAsB,EAEjE,KAAKmG,WAAa,GAClB,KAAKC,SAAW,GAChB,KAAKC,WAAa,GAElB,KAAKC,MAAQrG,EAAWC,KAEpB,KAAK2F,KAAK1D,KACZ,KAAKA,KAAO,KAAK0D,KAAK1D,KACb,KAAK0D,KAAKb,IACnB,KAAK7C,KAAO,QAEZ,KAAKA,KAAO,OAGd,KAAKwD,SAAStB,SAAS,cAAe,CAAEkC,QAAS,KAAjD,CACD,CAEDC,mBAAoB,CACd,KAAKV,aAAe,CAAC,KAAKW,gBAAL,GAEvBC,WAAW,IAAM,CACX,KAAKZ,cACP,KAAKA,YAAYT,QAAjB,EACA,KAAKS,YAAcpG,SAEpB,GALO,CAOb,CAQDiH,KAAKC,EAAQC,EAAQ,CACnB,GAAI,KAAKd,OAAS,KAAKe,eAAL,EAChB,GAAK,KAAKhB,YAYH,CACL,IAAMiB,EAAgB,KAAKjB,YAAYlB,QAEnCmC,GAAiB,CAACA,EAAcC,eAClC,KAAKjB,MAAMpB,UAAUsC,QAAQF,CAA7B,CAEH,KAlBsB,CACrB,IAAMG,EAAiB,KAAKvB,SAASjC,aACnC,iBAGC,KAAKmC,KAAKsB,MAAQ,KAAKpB,MAAMqB,aAAgB,KAAKvB,KAAKsB,KAAO,GAC/D,IALqB,EAOvB,KAAKrB,YAAc,IAAIrB,GACrByC,EACA,KAAKnB,MAAMpB,SAFM,CAIpB,CASC,KAAKC,SAAW,CAACiC,GAIjB,KAAKlB,SAAStB,SAAS,cAAe,CAAEkC,QAAS,KAAMK,OAAAA,EAAvD,EAAiEvE,mBAIjE,KAAKgF,eAAL,GACF,KAAKzC,QAAU9F,EAAc,YAAa,KAAd,EAGxB,KAAKkH,qBACP,KAAKsB,UAAUV,CAAf,IAGF,KAAKhC,QAAU9F,EAAc,gBAAiB,KAAlB,EAC5B,KAAK8F,QAAQ2C,UAAY,KAAK1B,KAAK2B,MAAQ,IAGzCX,GAAU,KAAKd,OACjB,KAAKA,MAAM0B,kBAAkB,EAA7B,EAEH,CAODH,UAAUV,EAAQ,CAAA,IAAAc,EAAAC,EAChB,GAAI,CAAC,KAAKN,eAAL,GACA,CAAC,KAAKzC,SACN,KAAKe,SAAStB,SAAS,mBAAoB,CAAEkC,QAAS,KAAMK,OAAAA,EAA5D,EAAsEvE,iBACzE,OAGF,IAAMuF,EAA8C,KAAKhD,QAEzD,KAAKiD,kBAAL,EAEI,KAAKhC,KAAKiC,SACZF,EAAaE,OAAS,KAAKjC,KAAKiC,QAGlCF,EAAa5C,KAAM0C,EAAA,KAAK7B,KAAKb,OAA7B,MAAA0C,IAAA,OAAAA,EAAoC,GACpCE,EAAa7C,KAAM4C,EAAA,KAAK9B,KAAKd,OAA7B,MAAA4C,IAAA,OAAAA,EAAoC,GAEpC,KAAKrB,MAAQrG,EAAWE,QAEpByH,EAAaG,SACf,KAAKC,SAAL,GAEAJ,EAAaK,OAAS,IAAM,CAC1B,KAAKD,SAAL,GAGFJ,EAAaM,QAAU,IAAM,CAC3B,KAAKC,QAAL,GAGL,CAODC,SAASrC,EAAO,CACd,KAAKA,MAAQA,EACb,KAAKK,SAAW,GAChB,KAAKT,SAAWI,EAAMnD,IAGvB,CAKDoF,UAAW,CACT,KAAK1B,MAAQrG,EAAWG,OAEpB,KAAK2F,OAAS,KAAKnB,UACrB,KAAKe,SAAStB,SAAS,eAAgB,CAAE0B,MAAO,KAAKA,MAAOQ,QAAS,IAA9B,CAAvC,EAGI,KAAKR,MAAMsC,UACR,KAAKtC,MAAMuC,eACX,CAAC,KAAK1D,QAAQW,aACnB,KAAKgD,OAAL,EACA,KAAKxC,MAAM0B,kBAAkB,EAA7B,IAGE,KAAKnB,QAAUrG,EAAWG,QAAU,KAAKkG,QAAUrG,EAAWI,QAChE,KAAKmG,kBAAL,EAGL,CAKD2B,SAAU,CACR,KAAK7B,MAAQrG,EAAWI,MAEpB,KAAK0F,QACP,KAAKyC,aAAL,EACA,KAAK7C,SAAStB,SAAS,eAAgB,CAAE0B,MAAO,KAAKA,MAAO0C,QAAS,GAAMlC,QAAS,KAApF,EACA,KAAKZ,SAAStB,SAAS,YAAa,CAAE0B,MAAO,KAAKA,MAAOQ,QAAS,KAAlE,EAEH,CAKDmC,WAAY,CACV,OAAO,KAAK/C,SAASjC,aACnB,mBACA,KAAK4C,QAAUrG,EAAWE,QAC1B,IAHK,CAKR,CAKDsI,SAAU,CACR,OAAO,KAAKnC,QAAUrG,EAAWI,KAClC,CAKDgH,gBAAiB,CACf,OAAO,KAAKlF,OAAS,OACtB,CAQD+C,iBAAiBnF,EAAOC,EAAQ,CAC9B,GAAK,KAAK4E,UAIN,KAAKkB,aACP,KAAKA,YAAYZ,iBAAiBnF,EAAOC,CAAzC,EAGE,MAAK2F,SAAStB,SAChB,gBACA,CAAEkC,QAAS,KAAMxG,MAAAA,EAAOC,OAAAA,EAFtB,EAEgCqC,mBAKpC1C,GAAe,KAAKiF,QAAS7E,EAAOC,CAAtB,EAEV,KAAKqH,eAAL,GAAyB,CAAC,KAAKoB,QAAL,IAAgB,CAC5C,IAAME,EAAuB,CAAC,KAAK3C,qBAAuBjG,EAE1D,KAAKiG,oBAAsBjG,EAC3B,KAAKkG,qBAAuBjG,EAExB2I,EACF,KAAKrB,UAAU,EAAf,EAEA,KAAKO,kBAAL,EAGE,KAAK9B,OACP,KAAKJ,SAAStB,SACZ,kBACA,CAAE0B,MAAO,KAAKA,MAAOhG,MAAAA,EAAOC,OAAAA,EAAQuG,QAAS,KAF/C,CAKH,CACF,CAKDqC,YAAa,CACX,OAAO,KAAKjD,SAASjC,aACnB,oBACA,KAAK2D,eAAL,GAA0B,KAAKf,QAAUrG,EAAWI,MACpD,IAHK,CAKR,CAKDwH,mBAAoB,CAMlB,GAAI,CAAC,KAAKR,eAAL,GAAyB,CAAC,KAAKzC,SAAW,CAAC,KAAKiB,KAAKiC,OACxD,OAGF,IAAMe,EAAuC,KAAKjE,QAC5CkE,EAAa,KAAKnD,SAASjC,aAC/B,mBACA,KAAKsC,oBACL,IAHiB,GAOjB,CAAC6C,EAAME,QAAQC,iBACZF,EAAaG,SAASJ,EAAME,QAAQC,gBAAiB,EAAhC,KAExBH,EAAMK,MAAQJ,EAAa,KAC3BD,EAAME,QAAQC,gBAAkBG,OAAOL,CAAD,EAEzC,CAKDhC,gBAAiB,CACf,OAAO,KAAKnB,SAASjC,aACnB,wBACA,KAAK2D,eAAL,EACA,IAHK,CAKR,CAKD+B,UAAW,CACL,KAAKzD,SAAStB,SAAS,kBAAmB,CAAEkC,QAAS,KAArD,EAA6DlE,kBAIjE,KAAKsE,KAAK,EAAV,CACD,CAKDF,iBAAkB,CAChB,OAAO,KAAKd,SAASjC,aACnB,uBACA,KAAKgF,UAAL,EACA,IAHK,CAKR,CAKDrD,SAAU,CACR,KAAKe,SAAW,GAChB,KAAKL,MAAQrG,OAET,MAAKiG,SAAStB,SAAS,iBAAkB,CAAEkC,QAAS,KAApD,EAA4DlE,mBAIhE,KAAKmD,OAAL,EAEI,KAAKM,cACP,KAAKA,YAAYT,QAAjB,EACA,KAAKS,YAAcpG,QAGjB,KAAK2H,eAAL,GAAyB,KAAKzC,UAChC,KAAKA,QAAQqD,OAAS,KACtB,KAAKrD,QAAQsD,QAAU,KACvB,KAAKtD,QAAUlF,QAElB,CAKD8I,cAAe,CACb,GAAI,KAAKzC,MAAO,CAAA,IAAAsD,EAAAC,EACd,IAAIC,EAAazK,EAAc,kBAAmB,KAApB,EAC9ByK,EAAWC,WAAXH,GAAAC,EAAuB,KAAK3D,SAAS9C,WAAd,MAAAyG,IAAA,OAAA,OAAAA,EAAuBG,YAA9C,MAAAJ,IAAA,OAAAA,EAA0D,GAC1DE,EAA4C,KAAK5D,SAASjC,aACxD,sBACA6F,EACA,IAH0C,EAK5C,KAAK3E,QAAU9F,EAAc,0CAA2C,KAA5C,EAC5B,KAAK8F,QAAQxF,YAAYmK,CAAzB,EACA,KAAKxD,MAAMpB,UAAU6E,UAAY,GACjC,KAAKzD,MAAMpB,UAAUvF,YAAY,KAAKwF,OAAtC,EACA,KAAKmB,MAAM0B,kBAAkB,EAA7B,EACA,KAAKjB,kBAAL,CACD,CACF,CAKD+B,QAAS,CACP,GAAI,KAAKpC,YAAc,CAAC,KAAKvB,QAC3B,OAKF,GAFA,KAAKuB,WAAa,GAEd,KAAKG,QAAUrG,EAAWI,MAAO,CACnC,KAAKmI,aAAL,EACA,MACD,CAED,GAAI,KAAK7C,SAAStB,SAAS,gBAAiB,CAAEkC,QAAS,KAAnD,EAA2DlE,iBAC7D,OAGF,IAAMqH,EAAkB,WAAY,KAAK9E,QAErC,KAAKyC,eAAL,EAaEqC,GAAkB,KAAK3D,QAAU,CAAC,KAAKA,MAAMsC,UAAYxG,GAAQ,IACnE,KAAKwE,WAAa,GAIjB,KAAKzB,QAAS+E,OAAf,EAAwBC,MAAM,IAAM,CAAA,CAApC,EAAwCC,QAAQ,IAAM,CACpD,KAAKxD,WAAa,GAClB,KAAKyD,YAAL,EAFF,GAKA,KAAKA,YAAL,EAEO,KAAK/D,OAAS,CAAC,KAAKnB,QAAQW,YACrC,KAAKQ,MAAMpB,UAAUvF,YAAY,KAAKwF,OAAtC,CAEH,CAODmF,UAAW,CACL,KAAKpE,SAAStB,SAAS,kBAAmB,CAAEkC,QAAS,IAAX,CAA1C,EAA6DlE,kBAC5D,CAAC,KAAK0D,QAIP,KAAKsB,eAAL,GAAyB,KAAKhB,YAAc,CAACxE,GAAQ,EAGvD,KAAKiI,YAAL,EACS,KAAKrB,QAAL,GACT,KAAK9B,KAAK,GAAO,EAAjB,EAGE,KAAKZ,MAAMiE,eACb,KAAKjE,MAAMiE,cAAc/E,aAAa,cAAe,OAArD,EAEH,CAKDgF,YAAa,CACX,KAAKtE,SAAStB,SAAS,oBAAqB,CAAEkC,QAAS,KAAvD,EACI,KAAKR,OAAS,KAAKA,MAAMiE,eAC3B,KAAKjE,MAAMiE,cAAc/E,aAAa,cAAe,MAArD,CAEH,CAMDO,QAAS,CACP,KAAKW,WAAa,GAEd,MAAKR,SAAStB,SAAS,gBAAiB,CAAEkC,QAAS,KAAnD,EAA2DlE,mBAI3D,KAAKuC,SAAW,KAAKA,QAAQW,YAC/B,KAAKX,QAAQY,OAAb,EAGE,KAAKM,aAAe,KAAKA,YAAYlB,SACvC,KAAKkB,YAAYlB,QAAQY,OAAzB,EAEH,CAKDsE,aAAc,CACP,KAAK3D,aAIN,KAAKR,SAAStB,SAAS,qBAAsB,CAAEkC,QAAS,KAAxD,EAAgElE,mBAKhE,KAAK0D,OAAS,KAAKnB,SAAW,CAAC,KAAKA,QAAQW,YAC9C,KAAKQ,MAAMpB,UAAUvF,YAAY,KAAKwF,OAAtC,GAGE,KAAK0B,QAAUrG,EAAWG,QAAU,KAAKkG,QAAUrG,EAAWI,QAChE,KAAKmG,kBAAL,GAEH,CA5fW,ECEP,SAAS0D,GAAgBrH,EAASD,EAAM,CAC7C,GAAIC,EAAQsH,kBAAmB,CAC7B,IAAMC,EAAkBvH,EAAQsH,kBAAkBtH,EAASD,CAAnC,EACxB,GAAIwH,EACF,OAAOA,CAEV,CAED,MAAO,CACL9K,EAAGH,SAASkL,gBAAgBC,YAM5B/K,EAAGgL,OAAOC,YAEb,CAqCM,SAASC,EAAmBC,EAAM7H,EAAS8H,EAAcjF,EAAUE,EAAO,CAC/E,IAAIgF,EAAe,EAEnB,GAAI/H,EAAQgI,UACVD,EAAe/H,EAAQgI,UAAUF,EAAcjF,EAAUE,CAA1C,EAAiD8E,CAAjD,UACN7H,EAAQiI,QACjBF,EAAe/H,EAAQiI,QAAQJ,CAAhB,MACV,CACL,IAAMK,EAAiB,UAAYL,EAAK,CAAD,EAAIM,YAAR,EAAwBN,EAAKO,MAAM,CAAX,EAEvDpI,EAAQkI,CAAD,IAETH,EAAe/H,EAAQkI,CAAD,EAEzB,CAED,OAAO7E,OAAO0E,CAAD,GAAkB,CAChC,CASM,SAASM,GAAerI,EAAS8H,EAAcjF,EAAUE,EAAO,CACrE,MAAO,CACLtG,EAAGqL,EAAarL,EACZmL,EAAmB,OAAQ5H,EAAS8H,EAAcjF,EAAUE,CAA1C,EAClB6E,EAAmB,QAAS5H,EAAS8H,EAAcjF,EAAUE,CAA3C,EACtBrG,EAAGoL,EAAapL,EACZkL,EAAmB,MAAO5H,EAAS8H,EAAcjF,EAAUE,CAAzC,EAClB6E,EAAmB,SAAU5H,EAAS8H,EAAcjF,EAAUE,CAA5C,EAEzB,CCnGD,IAAMuF,GAAkB,IAalBC,GAAN,KAAgB,CAOdlJ,YAAYW,EAAS6C,EAAUE,EAAOhD,EAAM,CAC1C,KAAKA,KAAOA,EACZ,KAAKC,QAAUA,EACf,KAAK6C,SAAWA,EAChB,KAAKE,MAAQA,EAEb,KAAKyF,YAAc,KAEnB,KAAKC,YAAc,KACnB,KAAKC,IAAM,EACX,KAAKC,KAAO,EACZ,KAAKC,MAAQ,EACb,KAAKC,QAAU,EACf,KAAKC,UAAY,EACjB,KAAKC,IAAM,EACX,KAAKC,IAAM,CACZ,CAWDC,OAAOC,EAAUC,EAAWX,EAAa,CAEvC,IAAMC,EAAc,CAAEhM,EAAGyM,EAAUxM,EAAGyM,GACtC,KAAKV,YAAcA,EACnB,KAAKD,YAAcA,EAEnB,IAAMY,EAASZ,EAAY/L,EAAIgM,EAAYhM,EACrC4M,EAASb,EAAY9L,EAAI+L,EAAY/L,EAE3C,KAAKgM,IAAMY,KAAKN,IAAI,EAAGI,EAASC,EAASD,EAASC,CAAvC,EACX,KAAKV,KAAOW,KAAKN,IAAI,EAAGI,EAASC,EAASD,EAASC,CAAvC,EAIZ,KAAKT,MAAQU,KAAKN,IAAI,EAAGK,CAAZ,EAEb,KAAKR,QAAU,KAAKU,YAAL,EACf,KAAKT,UAAY,KAAKU,cAAL,EACjB,KAAKT,IAAMO,KAAKP,IACd,KAAKF,QACL,KAAKC,UACL,KAAKW,QAAL,CAHS,EAMX,KAAKT,IAAMM,KAAKN,IACd,KAAKN,IACL,KAAKG,QACL,KAAKC,SAHI,EAMP,KAAK/I,MACP,KAAKA,KAAKyB,SAAS,mBAAoB,CAAEkI,WAAY,KAAMC,UAAW,KAAK9G,SAA3E,CAEH,CASD+G,sBAAsBC,EAAc,CAClC,IAAMC,EACJD,EAAe,YAEXE,EAAc,KAAK/J,QAAQ8J,CAAb,EAEpB,GAAKC,EAIL,OAAI,OAAOA,GAAgB,WAClBA,EAAY,IAAD,EAGhBA,IAAgB,OACX,KAAKpB,KAGVoB,IAAgB,MACX,KAAKrB,IAGPrF,OAAO0G,CAAD,CACd,CAWDP,eAAgB,CACd,IAAIQ,EAAgB,KAAKJ,sBAAsB,WAA3B,EAEpB,OAAII,IAKJA,EAAgBV,KAAKN,IAAI,EAAG,KAAKN,IAAM,CAAvB,EAEZ,KAAKD,aAAeuB,EAAgB,KAAKvB,YAAYhM,EAAI6L,KAC3D0B,EAAgB1B,GAAkB,KAAKG,YAAYhM,GAG9CuN,EACR,CAQDT,aAAc,CACZ,OAAO,KAAKK,sBAAsB,SAA3B,GAAyC,KAAKlB,GACtD,CAUDe,SAAU,CAGR,OAAO,KAAKG,sBAAsB,KAA3B,GAAqCN,KAAKP,IAAI,EAAG,KAAKL,IAAM,CAAvB,CAC7C,CArJa,ECQT,SAASuB,GAAapH,EAAUC,EAAUC,EAAO,CACtD,IAAMW,EAAUZ,EAASoH,sBAAsBrH,EAAUE,CAAzC,EAEZoH,EAEE,CAAEnK,QAAAA,GAAY8C,EAIpB,GAAI9C,EAAS,CACXmK,EAAY,IAAI5B,GAAUvI,EAAS6C,EAAU,EAAjC,EAEZ,IAAIiF,EACAhF,EAAS/C,KACX+H,EAAehF,EAAS/C,KAAK+H,aAE7BA,EAAeT,GAAgBrH,EAAS8C,CAAV,EAGhC,IAAM0F,EAAcH,GAAerI,EAAS8H,EAAcjF,EAAUE,CAAlC,EAClCoH,EAAUlB,OAAOvF,EAAQxG,MAAOwG,EAAQvG,OAAQqL,CAAhD,CACD,CAED9E,OAAAA,EAAQ6C,SAAR,EAEI4D,GACFzG,EAAQrB,iBACNiH,KAAKc,KAAK1G,EAAQxG,MAAQiN,EAAUtB,OAApC,EACAS,KAAKc,KAAK1G,EAAQvG,OAASgN,EAAUtB,OAArC,CAFF,EAMKnF,CACR,CAcM,SAAS2G,GAActH,EAAOD,EAAU,CAC7C,IAAMD,EAAWC,EAASwH,YAAYvH,CAArB,EAEjB,GAAID,CAAAA,EAAStB,SAAS,gBAAiB,CAAEuB,MAAAA,EAAOF,SAAAA,EAA5C,EAAwDrD,iBAI5D,OAAOyK,GAAapH,EAAUC,EAAUC,CAArB,CACpB,CChED,IAAMwH,GAAN,cAA6B3K,EAAU,CAMrC4K,aAAc,CAAA,IAAAC,EACZ,IAAIC,EAAW,EACTC,GAAaF,EAAA,KAAKzK,WAAR,MAAAyK,IAAA,OAAA,OAAGA,EAAcE,WAE7BA,GAAc,WAAYA,EAE5BD,EAAWC,EAAWC,OACbD,GAAc,YAAaA,IAE/BA,EAAWE,QACdF,EAAWE,MAAQ,KAAKC,uBAAuBH,EAAWI,OAAvC,GAGjBJ,EAAWE,QACbH,EAAWC,EAAWE,MAAMD,SAKhC,IAAMlJ,EAAQ,KAAKF,SAAS,WAAY,CACtCmJ,WAAAA,EACAD,SAAAA,CAFsC,CAA1B,EAId,OAAO,KAAK7J,aAAa,WAAYa,EAAMgJ,SAAUC,CAA9C,CACR,CAODT,sBAAsBP,EAAW5G,EAAO,CACtC,OAAO,IAAIH,GAAQ+G,EAAW,KAAM5G,CAA7B,CACR,CAYDuH,YAAYvH,EAAO,CAAA,IAAAiI,EACjB,IAAML,GAAaK,EAAA,KAAKhL,WAAR,MAAAgL,IAAA,OAAA,OAAGA,EAAcL,WAE7BM,EAAiB,CAAA,EACjB1M,MAAMC,QAAQmM,CAAd,EAEFM,EAAiBN,EAAW5H,CAAD,EAClB4H,GAAc,YAAaA,IAM/BA,EAAWE,QACdF,EAAWE,MAAQ,KAAKC,uBAAuBH,EAAWI,OAAvC,GAGrBE,EAAiBN,EAAWE,MAAM9H,CAAjB,GAGnB,IAAIF,EAAWoI,EAEXpI,aAAoBxE,UACtBwE,EAAW,KAAKqI,sBAAsBrI,CAA3B,GAKb,IAAMnB,EAAQ,KAAKF,SAAS,WAAY,CACtCqB,SAAUA,GAAY,CAAA,EACtBE,MAAAA,CAFsC,CAA1B,EAKd,OAAO,KAAKlC,aAAa,WAAYa,EAAMmB,SAAUE,CAA9C,CACR,CASD+H,uBAAuBK,EAAgB,CAAA,IAAAC,EAAAC,EACrC,OAAID,EAAA,KAAKpL,WAAL,MAAAoL,IAAA,QAAAA,EAAcE,WAAdD,EAA0B,KAAKrL,WAA/B,MAAAqL,IAAA,QAA0BA,EAAcE,cACnCvN,EACL,KAAKgC,QAAQsL,SACb,KAAKtL,QAAQuL,cACbJ,CAH0B,GAIvB,CAAA,EAGA,CAACA,CAAD,CACR,CAQDD,sBAAsBnJ,EAAS,CAE7B,IAAMc,EAAW,CACfd,QAAAA,GAGIyJ,EACJzJ,EAAQ5F,UAAY,IAChB4F,EACAA,EAAQ0J,cAAc,GAAtB,EAGN,GAAID,EAAQ,CAGV3I,EAASV,IAAMqJ,EAAOtF,QAAQwF,SAAWF,EAAOG,KAE5CH,EAAOtF,QAAQ0F,aACjB/I,EAASoC,OAASuG,EAAOtF,QAAQ0F,YAGnC/I,EAAS3F,MAAQsO,EAAOtF,QAAQ2F,UAAYzF,SAASoF,EAAOtF,QAAQ2F,UAAW,EAA3B,EAAiC,EACrFhJ,EAAS1F,OAASqO,EAAOtF,QAAQ4F,WAAa1F,SAASoF,EAAOtF,QAAQ4F,WAAY,EAA5B,EAAkC,EAGxFjJ,EAAS9F,EAAI8F,EAAS3F,MACtB2F,EAAS7F,EAAI6F,EAAS1F,OAElBqO,EAAOtF,QAAQ6F,WACjBlJ,EAASvD,KAAOkM,EAAOtF,QAAQ6F,UAGjC,IAAMC,EAAcjK,EAAQ0J,cAAc,KAAtB,EAEpB,GAAIO,EAAa,CAAA,IAAAC,EAGfpJ,EAASyB,KAAO0H,EAAYE,YAAcF,EAAY7J,IACtDU,EAASX,KAAT+J,EAAeD,EAAYG,aAAa,KAAzB,KAAf,MAAAF,IAAA,OAAAA,EAAkD,EACnD,EAEGT,EAAOtF,QAAQkG,aAAeZ,EAAOtF,QAAQmG,WAC/CxJ,EAASyJ,aAAe,GAE3B,CAED,OAAO,KAAKzL,aAAa,cAAegC,EAAUd,EAASyJ,CAApD,CACR,CASDvB,aAAapH,EAAUE,EAAO,CAC5B,OAAOkH,GAAapH,EAAU,KAAME,CAAjB,CACpB,CA1KoC,EC8BjCwJ,EAAN,cAAiChC,EAAe,CAI9ClL,YAAYW,EAAS,CACnB,MAAA,EAEA,KAAKA,QAAUA,GAAW,CAAA,EAC1B,KAAKwM,KAAO,EACZ,KAAKC,WAAa,GAKlB,KAAKC,kBAAoB7P,OAEzB,KAAK8P,kBAAoB,KAAKA,kBAAkBC,KAAK,IAA5B,CAC1B,CAMDC,MAAO,CAEL7O,EAAsB,KAAKgC,QAAQ+K,QAAS,KAAK/K,QAAQ8M,eAApC,EAClB9L,QAASmK,GAAmB,CAC3BA,EAAe4B,iBAAiB,QAAS,KAAKJ,kBAAmB,EAAjE,EAFJ,CAID,CAKDA,kBAAkBjP,EAAG,CAEnB,GAAID,GAAeC,CAAD,GACXgK,OAAO3H,KACZ,OAWF,IAAIiN,EAAe,CAAEvQ,EAAGiB,EAAEuP,QAASvQ,EAAGgB,EAAEwP,SAEpC,CAACF,EAAavQ,GAAK,CAACuQ,EAAatQ,IACnCsQ,EAAe,MAGjB,IAAIG,EAAe,KAAKC,gBAAgB1P,CAArB,EACnByP,EAAe,KAAKtM,aAAa,eAAgBsM,EAAczP,EAAG,IAAnD,EAEf,IAAMiN,EAAa,CACjBI,QAAqCrN,EAAE2P,eAGrCF,GAAgB,IAClBzP,EAAEiC,eAAF,EACA,KAAK2N,YAAYH,EAAcxC,EAAYqC,CAA3C,EAEH,CAQDI,gBAAgB1P,EAAG,CAEjB,GAAI,KAAKsC,QAAQuN,kBACf,OAAO,KAAKvN,QAAQuN,kBAAkB5L,KAAK,KAAMjE,CAA1C,EAGT,IAAM8P,EAA4C9P,EAAE+P,OAM9CC,EALgB1P,EACpB,KAAKgC,QAAQsL,SACb,KAAKtL,QAAQuL,cACe7N,EAAE2P,aAHW,EAKHM,UACtCC,GAASA,IAAUJ,GAAiBI,EAAMC,SAASL,CAAf,CADZ,EAI1B,OAAIE,IAAsB,GACjBA,EACE,KAAK1N,QAAQsL,UAAY,KAAKtL,QAAQuL,cAExC,GAIF,CACR,CAUD+B,YAAYvK,EAAO4H,EAAYqC,EAAc,CAE3C,GAAItF,OAAO3H,MAAQ,CAAC,KAAKC,QACvB,MAAO,GAIT,GAAI,CAAC2K,GAAc,KAAK3K,QAAQ+K,SAAW,KAAK/K,QAAQsL,SAAU,CAChE,IAAMwC,EAAkB9P,EAAsB,KAAKgC,QAAQ+K,OAAd,EACzC+C,EAAgB,CAAD,IACjBnD,EAAa,CACXI,QAAS+C,EAAgB,CAAD,GAG7B,CAGD,YAAK9N,QAAQ+C,MAAQA,EAGrB,KAAK/C,QAAQ+N,kBAAoBf,EAEjC,KAAKP,WAAa,GAClB,KAAKuB,QAAQjL,EAAO4H,CAApB,EACO,EACR,CAQDqD,QAAQjL,EAAO4H,EAAY,CACzB,GAAM,CAAE3K,QAAAA,CAAF,EAAc,KAEhB2K,IACF3K,EAAQ2K,WAAaA,GAKvB,IAAMsD,EAAe,CAAA,EAEfC,EAAiB,OAAOlO,EAAQmO,WACtC,GAAIvP,GAAYoB,EAAQmO,UAAT,EACbF,EAAa1N,KAAK6N,QAAQC,QAAyCrO,EAAQmO,UAAzD,CAAlB,MACK,IAAID,IAAmB,SAC5B,MAAM,IAAII,MAAM,6CAAV,EACD,GAAIJ,IAAmB,WAC5BD,EAAa1N,KAAqDP,EAAQmO,WAAT,CAAjE,MAEA,OAAM,IAAIG,MAAM,yBAAV,EAIJ,OAAOtO,EAAQuO,aAAgB,YAEjCN,EAAa1N,KAAKP,EAAQuO,YAAR,CAAlB,EAGEvO,EAAQwO,oBAAsB,IAASzL,GAAS,IAClD,KAAK2J,kBAAoBrC,GAActH,EAAO,IAAR,GAIxC,IAAM0L,EAAM,EAAE,KAAKjC,KACnB4B,QAAQM,IAAIT,CAAZ,EAA0BU,KAAMC,GAAoB,CAClD,GAAI,KAAKnC,WAAY,CACnB,IAAMoC,EAAaD,EAAgB,CAAD,EAClC,KAAKE,gBAAgBD,EAAYJ,CAAjC,CACD,EAJH,CAMD,CAODK,gBAAgBC,EAAQN,EAAK,CAa3B,GAPIA,IAAQ,KAAKjC,MAAQ,KAAKC,aAI9B,KAAKA,WAAa,GAGd/E,OAAO3H,MACT,OAQF,IAAMA,EAAO,OAAOgP,GAAW,SACzB,IAAIA,EAAOC,QAAQ,KAAKhP,OAAxB,EACA,IAAI+O,EAAO,KAAK/O,OAAhB,EAEN,KAAKD,KAAOA,EACZ2H,OAAO3H,KAAOA,EAIbN,OAAOwP,KAAK,KAAKpP,UAAjB,EAA8BmB,QAASd,GAAS,CAAA,IAAAiB,GAC/CA,EAAA,KAAKtB,WAAWK,CAAhB,KAAA,MAAAiB,IAAA,QAAAA,EAAuBH,QAASnC,GAAO,CACrCkB,EAAKmB,GAAGhB,EAAgDrB,CAAxD,EADF,CAGD,CAJD,EAQCY,OAAOwP,KAAK,KAAKnP,QAAjB,EAA4BkB,QAASd,GAAS,CAAA,IAAAE,GAC7CA,EAAA,KAAKN,SAASI,CAAd,KAAA,MAAAE,IAAA,QAAAA,EAAqBY,QAASJ,GAAW,CACvCb,EAAKE,UAAUC,EAAMU,EAAO/B,GAAI+B,EAAOT,QAAvC,EADF,EADF,EAMI,KAAKuM,oBACP3M,EAAKmP,cAAcC,WAAW,KAAKzC,iBAAnC,EACA,KAAKA,kBAAoB7P,QAG3BkD,EAAKmB,GAAG,UAAW,IAAM,CAEvB,KAAKnB,KAAOlD,OACZ,OAAO6K,OAAO3H,KAHhB,EAMAA,EAAK8M,KAAL,CACD,CAKDrK,SAAU,CAAA,IAAAlC,GACHP,EAAAA,KAAAA,QAAL,MAAAO,IAAA,QAAAA,EAAWkC,QAAX,EAEA,KAAKiK,WAAa,GAClB,KAAK5M,WAAa,CAAA,EAElB7B,EAAsB,KAAKgC,QAAQ+K,QAAS,KAAK/K,QAAQ8M,eAApC,EAClB9L,QAASmK,GAAmB,CAC3BA,EAAeiE,oBAAoB,QAAS,KAAKzC,kBAAmB,EAApE,EAFJ,CAID,CArQ6C,EC9BzC,SAAS0C,GAAYC,EAAmC,CAI3D,IAAMC,EAAMD,EAAS,cAAc,KAAK,EACxC,OAAAC,EAAI,UACA,kJAEGA,EAAI,cAAc,KAAK,CAClC,CAEO,SAASC,GAAcC,EAAmBC,EAAmC,CAChF,IAAIC,EAAQ,OAAOF,EAAM,aAAa,EAAI,OAAOA,EAAM,cAAc,EAErE,OAAIC,IACIA,EAAY,KAAOC,EAAQD,EAAY,IACvCC,EAAQD,EAAY,IACbA,EAAY,KAAOC,EAAQD,EAAY,MAC9CC,EAAQD,EAAY,MAIrBC,CACX,CAEO,SAASC,EAA0BH,EAAmBC,EAA2C,CACpG,IAAIC,EAAQ,OAAOF,EAAM,aAAa,EAAI,OAAOA,EAAM,cAAc,EACjEI,EAAU,GAEd,OAAIH,IACIA,EAAY,KAAOC,EAAQD,EAAY,KACvCC,EAAQD,EAAY,IACpBG,EAAU,IACHH,EAAY,KAAOC,EAAQD,EAAY,MAC9CC,EAAQD,EAAY,IACpBG,EAAU,KAIX,CAAC,MAAOF,EAAO,QAASE,CAAO,CAC1C,CAKO,SAASC,GAAaC,EAAkC,CAC3D,OAAOA,EAAOA,EAAK,QAAQ,2BAA4B,EAAE,EAAI,EACjE,CCxDO,IAAKC,QACRA,EAAA,MAAQ,QACRA,EAAA,MAAQ,QACRA,EAAA,OAAS,SAHDA,QAAA,IA+BCC,EAAN,KAA0C,CAkBtC,YACcC,EACAC,EACDC,EAClB,CAHmB,cAAAF,EACA,aAAAC,EACD,WAAAC,EATpB,KAAQ,WAAiC,KAkDzC,KAAQ,SAAW,GAcnB,KAAQ,UAAY,GArDhB,KAAK,eAAiBC,GAAaD,EAAM,KAAK,CAClD,CAOA,IAAI,KAAc,CACd,OAAO,KAAK,IAChB,CAEA,IAAI,IAAIE,EAAe,CACnB,KAAK,KAAOA,CAChB,CAOA,IAAI,OAAgB,CAChB,OAAO,KAAK,MAChB,CAEA,IAAI,MAAMA,EAAe,CACrB,KAAK,OAASA,CAClB,CAIA,IAAI,QAAiB,CACjB,OAAO,KAAK,OAChB,CAEA,IAAI,OAAOA,EAAe,CACtB,KAAK,QAAUA,CACnB,CAKA,IAAI,SAAmB,CACnB,OAAO,KAAK,QAChB,CAEA,IAAI,QAAQA,EAAgB,CACxB,KAAK,SAAWA,CACpB,CAQA,IAAI,UAAoB,CACpB,OAAO,KAAK,SAChB,CAQA,IAAI,aAA2B,CAC3B,OAAO,KAAK,YAChB,CAGA,IAAI,eAAwB,CACxB,OAAO,KAAK,MAAM,aACtB,CAGA,IAAI,gBAAyB,CACzB,OAAO,KAAK,MAAM,cACtB,CAgBO,MAAoB,CAEvB,IAAMC,EAAS,KAAK,UAAU,EACxBC,EAAU,KAAK,gBAAgB,EAC/BC,EAAQ,KAAK,SAAS,CAAC,CAACD,CAAO,EAGjCE,EAAO,KACLC,EAAO,KAAK,qBAAqB,EACnCC,EAAsC,KAGtC,KAAK,QAAQ,UAAYJ,GAAWG,GACpCD,EAAOH,EACPK,EAAkBH,EAClBE,EAAK,UAAY,KAAK,eACtBJ,EAAO,YAAYE,CAAK,EACxBD,EAAQ,YAAYG,CAAI,EACxBH,EAAQ,UAAU,IAAI,MAAM,GACrB,KAAK,QAAQ,UAAYA,GAAW,CAACG,GAC5CD,EAAOH,EACPC,EAAQ,UAAY,KAAK,eACzBD,EAAO,YAAYE,CAAK,EACxBG,EAAkBL,GACX,KAAK,QAAQ,UAAY,CAACC,GAAWG,GAC5CD,EAAOH,EACPK,EAAkBL,EAClBA,EAAO,YAAYE,CAAK,EACxB,QAAQ,KACJ,wHACJ,GACO,KAAK,QAAQ,UAAY,CAACD,GAAW,CAACG,GAC7CD,EAAOH,EACPK,EAAkBL,EAClBA,EAAO,YAAYE,CAAK,GACjB,CAAC,KAAK,QAAQ,UAAYD,GAAWG,GAC5CD,EAAOH,EACPA,EAAO,YAAYE,CAAK,EACxBD,EAAQ,YAAYG,CAAI,EACxBH,EAAQ,UAAU,IAAI,MAAM,EAC5BG,EAAK,UAAY,KAAK,gBACf,CAAC,KAAK,QAAQ,UAAYH,GAAW,CAACG,GAC7CD,EAAOH,EACPA,EAAO,YAAYE,CAAK,EACxBD,EAAQ,UAAY,KAAK,gBAClB,CAAC,KAAK,QAAQ,UAAY,CAACA,GAAWG,GAC7CD,EAAOC,EACPJ,EAAO,YAAYE,CAAK,EACxBE,EAAK,YAAYJ,CAAM,GAChB,CAAC,KAAK,QAAQ,UAAY,CAACC,GAAW,CAACG,IAC9CD,EAAOH,EACPA,EAAO,YAAYE,CAAK,GAG5B,KAAK,aAAeC,GAAQH,EAC5B,KAAK,aAAa,aAAa,OAAQ,OAAO,EAC9C,KAAK,aAAa,UAAU,IAAI,MAAM,EAEtC,IAAMM,EAAW,KAAK,YAAY,EAClC,OAACL,EAASK,CAAQ,EAAE,OAAOC,GAAK,CAAC,CAACA,CAAC,EAAE,QAAQA,GAAKP,EAAO,YAAYO,CAAC,CAAC,EACvE,KAAK,WAAWF,CAAe,EAC/B,KAAK,MAAM,EAEJ,KAAK,YAChB,CAEO,cAAcG,EAAyB,CAzNlD,IAAAC,EAAAC,EA0NQ,IAAMC,EAAY,QACdH,GACA,KAAK,QAAQ,gBAAkB,SAC/BC,EAAA,KAAK,aAAL,MAAAA,EAAiB,UAAU,IAAIE,KAE/B,KAAK,QAAQ,gBAAkB,UAC/BD,EAAA,KAAK,aAAL,MAAAA,EAAiB,UAAU,OAAOC,GAE1C,CAMO,OAAc,CACZ,KAAK,eAIV,KAAK,aAAa,MAAM,MAAe,KAAK,MAAQ,KACpD,KAAK,aAAa,MAAM,OAAgB,KAAK,OAAS,KAC1D,CAEQ,iBAAwB,CAC5B,IAAMC,EAAQ,IAAI,YAAyB,SAAU,CAAC,OAAQ,IAAI,CAAC,EACnE,KAAK,aAAa,cAAcA,CAAK,CACzC,CAEO,cAAqB,CACpB,KAAK,UACL,KAAK,SAAS,EAEd,KAAK,OAAO,CAEpB,CAEQ,yBAAgC,CACpC,GAAI,CAAC,KAAK,QAAQ,WACd,MAAM,MAAM,2BAA2B,CAE/C,CAEO,QAAe,CAClB,KAAK,wBAAwB,EAC7B,KAAK,UAAY,GACjB,KAAK,aAAa,UAAU,IAAI,UAAU,EAC1C,KAAK,yBAAyB,EAC9B,KAAK,gBAAgB,CACzB,CAEO,UAAiB,CACpB,KAAK,wBAAwB,EAC7B,KAAK,UAAY,GACjB,KAAK,aAAa,UAAU,OAAO,UAAU,EAC7C,KAAK,yBAAyB,EAC9B,KAAK,gBAAgB,CACzB,CAEO,QAAe,CApR1B,IAAAH,GAqRQA,EAAA,KAAK,aAAa,aAAlB,MAAAA,EAA8B,YAAY,KAAK,aACnD,CAEQ,0BAAiC,CACrC,KAAK,UAAU,aAAa,eAAgB,OAAO,KAAK,SAAS,CAAC,EAClE,KAAK,UAAU,aAAa,aAAc,KAAK,UAAY,WAAa,QAAQ,CACpF,CAEQ,sBAA+D,CACnE,GAAI,KAAK,MAAM,KAAM,CACjB,IAAML,EAAO,KAAK,SAAS,cAAc,GAAG,EAC5C,OAAAA,EAAK,aAAa,OAAQ,KAAK,MAAM,IAAI,EAErC,KAAK,MAAM,YACXA,EAAK,aAAa,SAAU,KAAK,MAAM,UAAU,EAG9CA,CACX,SAAW,KAAK,QAAQ,UAAW,CAC/B,IAAMS,EAAS,KAAK,SAAS,cAAc,QAAQ,EACnD,OAAAA,EAAO,UAAU,IAAI,YAAY,EACjCA,EAAO,aAAa,WAAY,GAAG,EACnC,KAAK,iBAAiBA,CAAM,EAErBA,CACX,CAEA,OAAO,IACX,CAMQ,WAAqB,CACzB,IAAIC,EAAY,GAEVC,EAAkB,CAAC,SAAwB,OAAqB,EACtE,OACI,KAAK,gBACL,KAAK,QAAQ,iBACbA,EAAgB,SAAS,KAAK,QAAQ,eAAe,IAErDD,EAAY,IAGTA,CACX,CAEQ,WAAyB,CAC7B,IAAMd,EAAS,KAAK,SAAS,cAAc,QAAQ,EACnD,OAAAA,EAAO,UAAU,IAAI,QAAQ,EAC7BA,EAAO,aAAa,OAAQ,OAAO,EAE/B,KAAK,MAAM,QACXA,EAAO,MAAM,gBAAkB,KAAK,MAAM,MAAQ,MAG/CA,CACX,CAEQ,SAASgB,EAAuC,CACpD,IAAMd,EAAQ,KAAK,SAAS,cAAc,KAAK,EAC/C,OAAAA,EAAM,aAAa,MAAO,KAAK,MAAM,YAAY,EACjDA,EAAM,MAAM,UAAY,KAAK,MAAM,WAAa,QAChDA,EAAM,MAAM,eAAiB,KAAK,MAAM,gBAAkB,SAC1DA,EAAM,UAAU,IAAI,OAAO,EAC3BA,EAAM,aAAa,UAAW,MAAM,EACpCA,EAAM,iBAAiB,OAAQ,IAAM,KAAK,aAAa,UAAU,IAAI,QAAQ,CAAC,EAI1E,KAAK,MAAM,KAAO,KAAK,MAAM,MAAQ,KAAK,eAC1CA,EAAM,aAAa,MAAO,KAAK,MAAM,GAAG,EACjC,CAACc,GAAc,KAAK,gBAC3Bd,EAAM,aAAa,MAAO,KAAK,cAAc,EAG1CA,CACX,CAEQ,iBAAsC,CAC1C,GAAI,CAAC,KAAK,UAAU,EAChB,OAAO,KAGX,IAAMD,EAAU,KAAK,SAAS,cAAc,YAAY,EACxD,OAAAA,EAAQ,UAAU,IAAI,SAAS,EAC/BA,EAAQ,UAAU,IAAI,OAAO,EAEzB,KAAK,QAAQ,kBAAoB,SACjCA,EAAQ,UAAU,IAAI,OAAO,EAGjC,KAAK,WAAaA,EACXA,CACX,CAEQ,aAAwC,CAC5C,GAAI,CAAC,KAAK,QAAQ,WACd,OAAO,KAGX,IAAMK,EAAW,KAAK,SAAS,cAAc,QAAQ,EACrDA,EAAS,SAAW,EACpBA,EAAS,UAAU,IAAI,YAAY,EACnCA,EAAS,aAAa,OAAQ,UAAU,EAExC,IAAMW,EAAS,KAAK,SAAS,cAAc,KAAK,EAChDA,EAAO,UAAU,IAAI,QAAQ,EAC7BX,EAAS,YAAYW,CAAM,EAE3B,IAAMC,EAAwBC,GAAa,CACvCA,EAAE,gBAAgB,EAClBA,EAAE,eAAe,EACjB,KAAK,aAAa,CACtB,EAEA,OAAAb,EAAS,iBAAiB,QAASY,CAAoB,EACvDZ,EAAS,iBAAiB,UAAWa,GAAK,EAClCA,EAAE,MAAQ,SAAWA,EAAE,MAAQ,MAC/BD,EAAqBC,CAAC,CAE9B,CAAC,EACD,KAAK,UAAYb,EACjB,KAAK,yBAAyB,EAE1B,KAAK,MAAM,SACX,KAAK,OAAO,EAEZ,KAAK,SAAS,EAGXA,CACX,CAEQ,iBAAiBc,EAA4B,CACjDA,EAAQ,aAAa,aAAc,eAAe,EAClD,IAAMZ,EAAYa,GAAmC,CACjD,IAAMC,EAAuC,CAAC,KAAM,KAAM,MAAOD,CAAE,EAC7DE,EAAiB,IAAI,YAA4C,WAAY,CAAC,OAAQD,CAAI,CAAC,EACjG,KAAK,aAAa,cAAcC,CAAc,CAClD,EACAH,EAAQ,iBAAiB,QAASZ,CAAQ,EAC1CY,EAAQ,iBAAiB,UAAWD,GAAK,EACjCA,EAAE,MAAQ,SAAWA,EAAE,MAAQ,MAC/BX,EAASW,CAAC,CAElB,CAAC,CACL,CAEQ,WAAWC,EAAmC,CAClD,GAAKA,GAIDA,EAAS,CACTA,EAAQ,SAAW,EACnBA,EAAQ,aAAa,aAAc,MAAM,EACzCA,EAAQ,aAAa,OAAQ,QAAQ,EACrCA,EAAQ,UAAU,IAAI,UAAU,EAChC,IAAMI,EAAa,IAAM,CACrB,IAAMZ,EAAQ,IAAI,YAAyB,OAAQ,CAAC,OAAQ,IAAI,CAAC,EACjE,KAAK,aAAa,cAAcA,CAAK,CACzC,EAEAQ,EAAQ,iBAAiB,QAASI,CAAU,EAC5CJ,EAAQ,iBAAiB,UAAWD,GAAK,EACjCA,EAAE,MAAQ,SAAWA,EAAE,MAAQ,OAC/BA,EAAE,eAAe,EACjBK,EAAW,EAEnB,CAAC,CACL,CACJ,CACJ,EC/TO,IAAeC,EAAf,KAAgF,CAsEnF,YACcC,EACVC,EACUC,EACZ,CAHY,gBAAAF,EAEA,sBAAAE,EArEd,KAAU,QAAoC,CAC1C,IAAK,EACL,YAAa,EACb,wBACA,SAAU,GACV,eAAgB,EAChB,WAAY,GACZ,UAAW,GACX,qBAAsB,EACtB,kBAAmB,CACf,KAAM,EACV,EACA,wBAAyB,KACzB,IAAK,CACD,aAAc,GAClB,CACJ,EAUA,KAAU,oBAAqC,CAAC,EAahD,KAAU,cAAgB,EAK1B,KAAU,WAAwC,KAKlD,KAAQ,eAAiB,EAKzB,KAAQ,oBAAgC,CAAC,EA2GzC,KAAU,YAA6B,CAAC,EAWxC,KAAU,eAAgC,CAAC,EArT/C,IAAAC,EAgNQ,KAAK,SAAW,KAAK,WAAW,cAChC,KAAK,QAAUC,EAAaH,EAAS,KAAK,OAAO,EAGjD,KAAK,mBAAqBI,EAAS,IAAM,CAOrC,GANA,KAAK,oBAAoB,QAAQC,GAAQ,CACrC,KAAK,cAAc,iBAAkBA,CAAI,CAC7C,CAAC,EAED,KAAK,oBAAsB,CAAC,EAExB,EAAC,KAAK,eAON,KAAK,oBAAoB,QAAQ,KAAK,WAAW,MAAM,EAAI,EAAG,CAC9D,IAAMC,EAAS,KAAK,WAAW,OAC/B,KAAK,cAAc,aAAc,CAAC,OAAAA,EAAQ,MAAO,KAAK,aAAa,CAAC,EACpE,KAAK,oBAAoB,KAAKA,CAAM,EACpC,KAAK,cAAgB,CACzB,CACJ,EAAG,GAAG,EAEN,KAAK,WAAW,UAAU,IAAI,oBAAoB,EAClD,KAAK,WAAW,UAAU,IAAI,KAAK,cAAc,CAAC,EAGlD,KAAK,WAAa,KAAK,SAAS,cAAc,KAAK,EACnD,KAAK,WAAW,UAAU,IAAI,sBAAsB,EACpD,KAAK,WAAW,YAAYC,GAAY,KAAK,QAAQ,CAAC,EACtD,KAAK,WAAW,MAAM,QAAU,OAChC,KAAK,WAAW,iBAAiB,QAASC,GAAK,CAC3CA,EAAE,eAAe,EACjB,KAAK,UAAU,CACnB,CAAC,EAED,KAAK,eAAiB,KAAK,SAAS,cAAc,KAAK,EACvD,KAAK,eAAe,UAAU,IAAI,sBAAsB,EACxD,KAAK,qBAAqB,EAG1B,IAAMC,EAAS,KAAK,SAAS,cAAc,QAAQ,EACnD,KAAK,WAAW,YAAYA,CAAM,EAGlC,IAAMC,EAAyB,IACzBC,EAAcP,EAAS,IAAM,KAAK,YAAY,EAAGM,EAAwB,CAAC,MAAO,CAAC,SAAS,CAAC,CAAC,EAC7FE,EAAYR,EAAS,IAAM,KAAK,UAAU,EAAGM,CAAsB,GACzER,EAAAO,EAAO,gBAAP,MAAAP,EAAsB,iBAAiB,SAAU,IAAM,CACnDU,EAAU,EACVD,EAAY,CAChB,GAEA,KAAK,WAAW,YAAY,KAAK,cAAc,EAC/C,KAAK,WAAW,YAAY,KAAK,UAAU,EAEtC,KAAK,QAAQ,aACd,KAAK,WAAW,KAAK,kBAAoB,KAAK,QAAQ,EAG1D,KAAK,aAAa,EAEd,KAAK,QAAQ,UACb,KAAK,eAAe,CAE5B,CAMA,IAAI,YAAwC,CACxC,OAAO,KAAK,UAChB,CAMA,IAAI,uBAAsC,CAlS9C,IAAAT,EAAAW,EAAAC,EAmSQ,QAAOA,EAAA,KAAK,aAAWD,GAAAX,EAAA,KAAK,aAAL,YAAAA,EAAiB,OAAjB,YAAAW,EAAuB,YAAa,CAAC,IAArD,YAAAC,EAAwD,QAAS,IAC5E,CAQA,IAAI,YAA4B,CAC5B,OAAO,KAAK,WAChB,CASA,IAAI,eAA+B,CAC/B,OAAO,KAAK,cAChB,CAEA,IAAI,eAAyB,CACzB,OAAO,KAAK,cAAc,OAAOT,GAAQA,EAAK,QAAQ,EAAE,IAAIA,GAAQA,EAAK,KAAK,CAClF,CAEA,IAAI,OAAgB,CA/TxB,IAAAH,EAAAW,EAAAC,EAkUQ,OAAO,KAAK,OAAMA,GAAAD,GAAAX,EAAA,KAAK,YAAW,wBAAhB,YAAAW,EAAA,KAAAX,GAA0C,QAA1C,KAAAY,EAAmD,KAAK,QAAQ,IAAI,YAAY,CACtG,CAEO,8BAA8BT,EAAmB,CACpD,IAAMU,EAAe,KAAK,cAAc,OAAS,EAGjDV,EAAK,YAAY,iBAAiB,OAAQ,IAAM,CAzUxD,IAAAH,GA0UYA,EAAA,KAAK,aAAL,MAAAA,EAAiB,YAAYa,EACjC,CAAC,CACL,CAOO,SAASC,EAAuB,CAEnC,IAAMC,EAAW,KAAK,WAAW,SAAW,KAAK,cAAc,OACzDC,EAAiB,KAAK,WAAW,OAGvCF,EAAO,QAASG,GAAiB,CAC7B,IAAMC,EAAcC,EAAK,KAAK,QAAS,CAAC,WAAY,aAAc,YAAa,MAAO,iBAAiB,CAAC,EAClGhB,EAAO,IAAIiB,EAAY,KAAK,SAAUF,EAAaD,CAAK,EAC9D,KAAK,YAAY,KAAKd,CAAI,CAC9B,CAAC,EAEGY,GAAYC,IAAmB,EAE/B,KAAK,UAAU,EACRD,GAAYC,EAAiB,GAEpC,KAAK,SAAS,CAEtB,CAEO,cAAcK,EAAyB,CAC1C,KAAK,QAAQ,gBAAkBA,mBAC/B,KAAK,WAAW,QAAQlB,GAAQ,CAC5BA,EAAK,cAAckB,CAAQ,CAC/B,CAAC,CACL,CAMO,qBAA+B,CAClC,GAAI,CAAC,KAAK,QAAQ,WACd,MAAM,MAAM,2BAA2B,EAG3C,YAAK,cAAc,QAAQlB,GAAQA,EAAK,OAAO,CAAC,EACzC,KAAK,aAChB,CAKO,kBAAyB,CAC5B,KAAK,cAAc,QAAQA,GAAQA,EAAK,SAAS,CAAC,CACtD,CAoBO,iBACHmB,EACAC,EACAzB,EACI,CACJ,KAAK,WAAW,iBAAiBwB,EAAMC,EAAUzB,CAAO,EAEpDwB,IAAS,cACT,KAAK,aAAa,CAE1B,CAMO,OAAc,CACjB,KAAK,MAAM,EACX,KAAK,aAAa,CACtB,CAKO,YAA6B,CAChC,OAAO,KAAK,OAChB,CAMO,SAASE,EAAsB,CAClC,KAAK,MAAM,EACX,KAAK,SAASA,CAAK,CACvB,CAUU,gBAAiB,CACvB,KAAK,WAAa,IAAIC,EAAmBC,GAAAC,EAAA,GAClC,KAAK,QAAQ,mBADqB,CAErC,WAAYC,CAChB,EAAC,EAGD,KAAK,WAAW,UAAU,WAAY,IAC3B,KAAK,cAAc,MAE7B,EAGD,KAAK,WAAW,UAAU,WAAY,CAACC,EAAsBC,IAA6B,CACtF,IAAM3B,EAAO,KAAK,WAAW2B,CAAK,EAClC,MAAO,CACH,GAAIA,EACJ,IAAK3B,EAAK,MAAM,YAChB,EAAGA,EAAK,MAAM,cACd,EAAGA,EAAK,MAAM,eACd,KAAMA,EAAK,MAAM,aACjB,QAASA,EAAK,YACd,aAAcA,EAAK,QACnB,IAAKA,EAAK,cACd,CACJ,CAAC,EAGG,KAAK,QAAQ,yBACb,KAAK,QAAQ,wBAAwB,KAAK,UAAU,EAGxD,KAAK,WAAW,KAAK,EAIrB,KAAK,WAAW,GAAG,SAAU,IAAM,CAte3C,IAAAH,GAyegBA,EAAA,KAAK,aAAL,MAAAA,EAAiB,MAAQ,KAAK,WAAW,KAAK,UAAY,KAAK,cAAc,OAAS,IACtF,KAAK,UAAU,CAEvB,CAAC,EAID,KAAK,WAAW,GAAG,UAAW,IAAM,CAhf5C,IAAAA,GAifaA,EAAA,KAAK,SAAS,gBAAd,MAAAA,EAA6C,MAClD,CAAC,CACL,CAmCU,cAAqB,CAK3B,IAAM+B,EAJkB,KAAK,0BAA0B,EAIvB,KAAK,eAAe,EAAI,EACxD,KAAK,cAAc,aAAc,CAAC,OAAQ,KAAK,WAAW,OAAQ,MAAOA,CAAK,CAAC,CACnF,CAOU,gBAAyB,CAC/B,GAAI,KAAK,QAAQ,YAAc,EAC3B,OAAO,KAAK,QAAQ,YAGxB,IAAMC,EAAa,KAAK,wBAAwB,EAChD,OAAOA,EAAa,KAAK,QAAQ,eAAiB,KAAK,QAAQ,eAAiBA,CACpF,CAOU,aAAa7B,EAAmB8B,EAA2B,KAAK,eAAsB,CAC5F,KAAK,cAAc,KAAK9B,CAAI,EAE5B8B,EAAY,YAAY9B,EAAK,KAAK,CAAC,EAEnC,KAAK,oBAAoB,KAAKA,CAAI,EAClC,KAAK,gBACL,KAAK,cAAc,oBAAqBA,CAAI,EAG5CA,EAAK,YAAY,iBAAiB,SAAU,IAAM,CAC9C,KAAK,cACD,SACA,KAAK,cAAc,OAAO,GAAK,EAAE,QAAQ,CAC7C,CACJ,CAAC,EAGDA,EAAK,YAAY,iBAAiB,WAAa+B,GAAoD,CAC/F,KAAK,cAAc,WAAY,CAAC,KAAA/B,EAAM,MAAO+B,EAAG,OAAO,KAAK,CAAC,CACjE,CAAC,EAEG,KAAK,QAAQ,UACb,KAAK,8BAA8B/B,CAAI,CAE/C,CAEU,4BAAmC,CACrC,KAAK,cAAc,SAAW,KAAK,WAAW,OAC9C,KAAK,WAAW,MAAM,QAAU,OAEhC,KAAK,WAAW,MAAM,QAAU,OAExC,CAOU,sBAA6B,CAC/B,KAAK,QAAQ,cAIjB,KAAK,WAAW,MAAM,UAAY,KAAK,wBAAwB,EAAI,GAAK,KAC5E,CAKU,yBAAkC,CACxC,OAAI,KAAK,SAAS,YACP,KAAK,SAAS,YAAY,YAAc,KAAK,WAAW,UAG5D,CACX,CAEU,aAAoB,CA7mBlC,IAAAH,GA8mBQA,EAAA,KAAK,iBAAL,MAAAA,EAAqB,UAAU,IAAI,WACvC,CAEU,WAAkB,CAjnBhC,IAAAA,GAknBQA,EAAA,KAAK,iBAAL,MAAAA,EAAqB,UAAU,OAAO,WAC1C,CAEU,cACNsB,EACAa,EACI,CACJ,GAAI,CACA,IAAMC,EAAQ,IAAI,YAAYd,EAAM,CAAC,OAAQa,CAAI,CAAC,EAClD,KAAK,WAAW,cAAcC,CAAK,CACvC,OAAQ9B,EAAA,CAER,CACJ,CAKU,OAAc,CACpB,KAAK,eAAe,UAAY,GAChC,KAAK,oBAAoB,OAAS,EAClC,KAAK,eAAiB,CAAC,EACvB,KAAK,YAAc,CAAC,CACxB,CAMQ,WAAW+B,EAAiC,CAChD,IAAMC,EAAaD,EACbE,EAAuBF,aAAmB,SAAWA,EAAQ,gBAAkBA,EAE/EG,EAActC,EAAS,IAAM,KAAK,WAAW,UAAU,IAAI,WAAW,EAAG,IAAK,CAAC,MAAO,CAAC,SAAS,CAAC,CAAC,EAClGuC,EAAYvC,EAAS,IAAM,KAAK,WAAW,UAAU,OAAO,WAAW,EAAG,GAAG,EAEnFoC,EAAW,iBAAiB,SAAU,IAAM,CACxCE,EAAY,EACZC,EAAU,EAEV,IAAMC,EACF,KAAK,WAAW,UAAY,KAAK,WAAW,aAAe,KAAK,QAAQ,qBAGtEC,EAAqBJ,EAAQ,WAAaA,EAAQ,WAAa,GAC/DK,EAAgBL,EAAQ,aACxBM,EAAeF,EAAqB,KAAK,eAC/C,KAAK,eAAiBA,EAGlBE,EAAe,GAAKF,EAAqBC,GAAiBF,GAE1D,KAAK,SAAS,CAEtB,CAAC,CACL,CAEA,IAAI,aAA2B,CAC3B,OAAO,KAAK,UAChB,CAEA,IAAI,aAA2B,CAC3B,OAAO,KAAK,cAChB,CACJ,EChrBO,IAAeI,EAAf,cAEGC,CAAuB,CACnB,YACIC,EACVC,EACUC,EACZ,CACE,MAAMF,EAAYC,EAASC,CAAgB,EAJjC,gBAAAF,EAEA,sBAAAE,EAGV,KAAK,eAAgB,MAAM,OAAS,KAAK,QAAQ,IAAM,IAC3D,CAEU,UAAiB,CACvB,KAAK,QAAQ,CAAC,CAClB,CAEU,WAAkB,CACxB,KAAK,QAAQ,KAAK,eAAe,CAAC,CACtC,CAMU,QAAQC,EAAoB,CAClC,IAAMC,EAAkB,KAAK,cAAc,OAGrCC,EAAU,KAAK,cAAc,OAAS,KAAK,cAAcD,EAAkB,CAAC,EAAE,IAAM,EAAI,EACxFE,EAAgBD,EAAUF,EAAO,EAGjCI,EAAgB,KAAK,WAAW,MAAMH,CAAe,EAC3D,KAAK,cAAcG,EAAeF,EAASC,CAAa,EAErCC,EAAc,OAAOC,GAAKA,EAAE,KAAOF,CAAa,EACxD,QAAQE,GAAK,KAAK,aAAaA,CAAC,CAAC,EAE5C,KAAK,mBAAmB,EACxB,KAAK,2BAA2B,CACpC,CAEU,WAAkB,CACxB,MAAM,UAAU,EAEX,KAAK,cAAc,QAKxB,KAAK,cAAc,KAAK,aAAa,CACzC,CACJ,EC5CO,IAAMC,GAAN,MAAMC,UAAiEC,CAA0B,CAMpG,YAAYC,EAAyBC,EAAgCC,EAAuC,CAExG,GADA,MAAMF,EAAYC,EAASC,CAAgB,EACvC,CAACD,EAAQ,WAAaA,EAAQ,WAAa,EAC3C,MAAM,IAAI,MAAM,mCAAmC,CAE3D,CAEA,OAAc,cACVE,EACAC,EACAC,EAAU,EACVC,EAAuB,KACvBC,EAA4B,KACxB,CACCA,IACDA,EAAaF,GAAoB,GAGrC,IAAMJ,EAAUE,EAAQ,QAExB,QAASK,EAAY,EAAGA,GAAaJ,EAAM,OAAQI,IAAa,CAC5D,IAAMC,EAAQL,EAAM,MAAM,EAAGI,CAAS,EAQtC,GAPiB,KAAK,YAClBC,EAAM,IAAIC,GAAKA,EAAE,KAAK,EACtBT,EAAQ,UACRA,EAAQ,IACRA,EAAQ,UACZ,GAEgBE,EAAQ,MAAO,CAG3B,KAAK,aAAaM,EAAON,EAAQ,MAAOF,EAAQ,IAAKM,EAAY,KAAMN,EAAQ,UAAU,EAEzF,IAAMU,EAAUJ,EAAa,GACzBD,IAAU,MAAQK,GAAWL,IAC7BR,EAAQ,cAAcK,EAASC,EAAM,MAAMI,CAAS,EAAGH,EAASC,EAAOK,CAAO,EAGlF,KACJ,SAAWH,IAAcJ,EAAM,OAAQ,CAInC,KAAK,aAAaK,EAAO,KAAMR,EAAQ,IAAKM,EAAYN,EAAQ,UAAWA,EAAQ,UAAU,EAC7F,KACJ,CACJ,CACJ,CAMA,OAAc,aACVQ,EACAG,EACAC,EACAC,EACAC,EAA8B,KAC9BC,EACI,CACJ,IAAMC,EAAcR,EAAM,IAAIC,GAAKA,EAAE,KAAK,EACpCQ,EAAYN,EACZ,KAAK,aAAaK,EAAaL,EAAgBC,EAAQG,CAAW,EACjED,GAAA,KAAAA,EAAgB,EAIjBI,GAHW,KAAK,YAAYF,EAAaC,EAAWL,EAAQG,CAAW,GAG9CJ,GAAA,KAAAA,EAAkB,IAAMH,EAAM,OACvDW,EAASR,EAAiBO,EAAY,EACxCE,EAAW,EAEf,QAASC,EAAI,EAAGA,EAAIb,EAAM,OAAQa,IAAK,CACnC,IAAMC,EAAOd,EAAMa,CAAC,EACd,CAAC,MAAAE,EAAO,QAAAC,CAAO,EAAIC,EAA0BH,EAAK,MAAOP,CAAW,EACtEW,EAAQH,EAAQN,EAAYE,EAChCC,GAAYM,EAAQ,KAAK,MAAMA,CAAK,EACpCA,EAAQ,KAAK,MAAMA,CAAK,GAEpBN,GAAY,GAAMC,IAAMb,EAAM,OAAS,GAAK,KAAK,MAAMY,CAAQ,IAAM,KACrEM,IACAN,KAGJE,EAAK,MAAQI,EACbJ,EAAK,OAAS,KAAK,MAAML,CAAS,EAClCK,EAAK,QAAUE,EACfF,EAAK,IAAMT,EACXS,EAAK,MAAM,CACf,CACJ,CAEA,OAAc,YACVK,EACAb,EACAF,EACAG,EACM,CACN,OAAOH,GAAUe,EAAO,OAAS,GAAK,KAAK,UAAUA,EAAQZ,CAAW,EAAID,CAChF,CAEA,OAAc,aACVa,EACAhB,EACAC,EACAG,EACM,CACN,OAAQJ,EAAiBC,GAAUe,EAAO,OAAS,IAAM,KAAK,UAAUA,EAAQZ,CAAW,CAC/F,CAKA,OAAc,UAAUY,EAAsBZ,EAAmC,CAC7E,OAAOY,EAAO,OAAO,CAACC,EAAOC,IAAUD,EAAQE,GAAcD,EAAOd,CAAW,EAAG,CAAC,CACvF,CAEO,QAAQgB,EAAoB,CAC/B,KAAK,gBAAgB,EACrB,MAAM,QAAQA,CAAI,CACtB,CAEO,cAAc5B,EAAsBC,EAAkBC,EAAsB,CAC/ER,EAAQ,cAAc,KAAMM,EAAOC,EAASC,CAAK,CACrD,CAEU,eAAwB,CAC9B,MAAO,gBACX,CAEU,WAAkB,CACxB,MAAM,UAAU,EAChB,KAAK,gBAAgB,EACrB,KAAK,mBAAmB,CAC5B,CAEU,2BAAoC,CAC1C,IAAIkB,EAAQ,EAGZ,OAAI,KAAK,QAAQ,YAAc,KAAK,QAAQ,WAAW,MACnDA,EAAQ,KAAK,QAAQ,WAAW,KAG7B,KAAK,MAAO,EAAIA,EAAS,KAAK,MAAQ,KAAK,QAAQ,MAAQ,KAAK,QAAQ,UAAY,KAAK,QAAQ,IAAI,CAChH,CAEU,yBAAkC,CACxC,OAAO,KAAK,KAAK,KAAK,wBAAwB,GAAK,KAAK,QAAQ,UAAY,KAAK,QAAQ,IAAI,EAAI,CACrG,CAEQ,iBAAwB,CAC5B,GAAI,CAAC,KAAK,cAAc,OACpB,OAIJ,IAAMS,EAAiB,KAAK,cAAc,KAAK,cAAc,OAAS,CAAC,EAAE,IAGnEC,EAAwB,KAAK,cAAc,OAAOZ,GAAKA,EAAE,MAAQW,CAAc,EAAE,OAGjFE,EAA+B,KAAK,WAAW,MAAM,KAAK,cAAc,OAASD,CAAqB,EAC5G,KAAK,cACDC,EACAA,EAA6B,CAAC,EAAE,IAChCA,EAA6B,CAAC,EAAE,GACpC,EACmBA,EACd,MAAMD,CAAqB,EAC3B,OAAOZ,GAAKA,EAAE,KAAOa,EAA6B,CAAC,EAAE,GAAG,EAElD,QAAQb,GAAK,KAAK,aAAaA,CAAC,CAAC,CAChD,CACJ,ECxLO,IAAMc,EAAN,KAA4C,CAKxC,YACHC,EACQC,EACV,CADU,aAAAA,EANZ,KAAiB,WAA4B,CAAC,EAQ1C,KAAK,YAAcD,EAAS,cAAc,KAAK,EAC/C,KAAK,YAAY,UAAU,IAAI,QAAQ,EACvC,KAAK,YAAY,MAAM,MAAQ,KAAK,QAAQ,MAAQ,KACpD,KAAK,YAAY,MAAM,IAAM,KAAK,QAAQ,IAAM,IACpD,CAEA,IAAI,QAAiB,CACjB,OAAO,KAAK,YAAY,YAC5B,CAEA,IAAI,QAAiB,CACjB,OAAO,KAAK,WAAW,MAC3B,CAEA,IAAI,YAA0B,CAC1B,OAAO,KAAK,WAChB,CAEO,QAAQE,EAAyB,CACpC,KAAK,WAAW,KAAKA,CAAI,CAC7B,CACJ,EC5BO,IAAMC,GAAN,MAAMC,UAAiEC,CAAuB,CAWjG,YAAYC,EAAyBC,EAAgCC,EAAuC,CACxG,MAAMF,EAAYC,EAASC,CAAgB,EAH/C,KAAU,QAA2B,CAAC,EAK9B,IAACD,EAAQ,aAAeA,EAAQ,aAAe,EAC/C,MAAM,IAAI,MAAM,qCAAqC,EAQzD,GALA,KAAK,WAAW,EAKZ,CAAC,KAAK,QAAQ,qBAAsB,CACpC,IAAIE,EAAQ,GAGR,KAAK,QAAQ,YAAc,KAAK,QAAQ,WAAW,MACnDA,EAAQ,KAAK,QAAQ,WAAW,KAGpC,IAAMC,EAAc,KAAK,eAAe,EACxC,KAAK,QAAQ,qBAAwB,GAAKA,EAAeD,CAC7D,CACJ,CAKA,OAAc,cACVE,EACAC,EACAC,EAAY,EACZC,EAAyB,KACrB,CACJ,IAAMC,EAAcJ,EAAQ,0BAA0B,EAGhDD,EAAcC,EAAQ,eAAe,EAEvCK,EAAYF,EAAUC,GAAeD,EAAUD,EAAY,GAAKD,EAAM,OAC1EI,EAAYA,EAAYJ,EAAM,OAASA,EAAM,OAASI,EAEtD,QAASC,EAAI,EAAGA,EAAID,EAAWC,IAAK,CAChC,IAAMC,EAAON,EAAMK,CAAC,EACd,CAAC,MAAAR,EAAO,QAAAU,CAAO,EAAIC,EAA0BF,EAAK,MAAOP,EAAQ,QAAQ,UAAU,EAEzFO,EAAK,MAAQ,KAAK,MAAMR,CAAW,EACnCQ,EAAK,OAASA,EAAK,MAAQT,EAC3BS,EAAK,QAAUC,EACfD,EAAK,MAAM,CACf,CACJ,CAEO,cAAcN,EAAsBS,EAAkBC,EAAsB,CAC/ElB,EAAQ,cAAc,KAAMQ,EAAOS,EAASC,CAAK,CACrD,CAEU,UAAiB,CACvB,KAAK,aAAa,CACtB,CAEU,WAAkB,CACxB,KAAK,aAAa,CACtB,CAEU,eAAwB,CAC9B,MAAO,gBACX,CAEU,2BAAoC,CAC1C,OAAO,KAAK,MAAM,KAAK,MAAQ,KAAK,QAAQ,MAAQ,KAAK,QAAQ,YAAc,KAAK,QAAQ,IAAI,CACpG,CAEU,yBAAkC,CACxC,IAAIb,EAAQ,KAGR,KAAK,QAAQ,YAAc,KAAK,QAAQ,WAAW,MACnDA,EAAQ,KAAK,QAAQ,WAAW,KAIpC,IAAMc,EADc,KAAK,eAAe,EACGd,EAC3C,OAAO,KAAK,KAAK,KAAK,wBAAwB,EAAIc,CAAoB,CAC1E,CAKU,cAAqB,CAC3B,GACI,KAAK,cAAc,CAAC,QACf,KAAK,oBAAoB,GAAK,KAAK,cAAc,OAAS,KAAK,WAAW,OACvF,CAEU,aAAaL,EAAyB,CAC5C,IAAMM,EAAiB,KAAK,kBAAkB,EAC9CA,EAAe,QAAQN,CAAI,EAC3B,MAAM,aAAaA,EAAMM,EAAe,UAAU,CACtD,CAEU,WAAkB,CACxB,MAAM,UAAU,EAEX,KAAK,cAAc,SAKxB,KAAK,cAAc,OAAS,EAC5B,KAAK,WAAW,EAChB,KAAK,aAAa,EACtB,CAEU,YAAmB,CACzB,KAAK,eAAe,UAAY,GAChC,KAAK,QAAU,CAAC,EAChB,IAAMd,EAAc,KAAK,eAAe,EACxC,QAAS,EAAI,EAAG,EAAI,KAAK,0BAA0B,EAAG,IAAK,CACvD,IAAMe,EAAY,IAAIC,EAAc,KAAK,SAAU,CAAC,MAAOhB,EAAa,IAAK,KAAK,QAAQ,GAAG,CAAC,EAC9F,KAAK,QAAQ,KAAKe,CAAS,EAC3B,KAAK,eAAe,YAAYA,EAAU,UAAU,CACxD,CACJ,CAEU,OAAc,CACpB,MAAM,MAAM,EACZ,KAAK,WAAW,CACpB,CAKQ,qBAA+B,CACnC,OAAO,KAAK,QAAQ,KAChBE,GAAKA,EAAE,WAAW,sBAAsB,EAAE,OAAS,KAAK,SAAS,gBAAgB,YACrF,CACJ,CAEQ,cAAcC,EAAiB,CACnC,IAAMC,EAAkB,KAAK,cAAc,OAGrCC,EAAa,KAAK,cAAc,OAASD,EAAkB,EAC3DE,EAAkBD,EAAaF,EAAU,EAG/C,KAAK,cAAc,KAAK,WAAW,MAAMC,CAAe,EAAGC,EAAYC,CAAe,EAEtF,QAASd,EAAIY,EAAiBZ,EAAI,KAAK,WAAW,OAAQA,IAAK,CAC3D,IAAMC,EAAO,KAAK,WAAWD,CAAC,EAC9B,GAAIA,GAAKc,EACL,KAAK,aAAab,CAAI,MAEtB,MAER,CAEA,KAAK,mBAAmB,EACxB,KAAK,2BAA2B,CACpC,CAKQ,gBAAyB,CAC7B,IAAMH,EAAc,KAAK,0BAA0B,EACnD,OAAO,KAAK,OAAO,KAAK,OAASA,EAAc,GAAK,KAAK,QAAQ,KAAOA,CAAW,CACvF,CAEQ,mBAAmC,CACvC,OAAO,KAAK,QAAQ,OAAO,CAACS,EAAgBQ,IACnCR,EAIEQ,EAAO,OAASR,EAAe,OAASQ,EAASR,EAH7CQ,CAId,CACL,CACJ,EChMO,IAAMC,GAAN,MAAMC,UAAgEC,CAA0B,CAMnG,YAAYC,EAAyBC,EAA+BC,EAAuC,CAGvG,GAFA,MAAMF,EAAYC,EAASC,CAAgB,EAEvC,CAACD,EAAQ,aAAeA,EAAQ,aAAe,EAC/C,MAAM,IAAI,MAAM,qCAAqC,CAE7D,CAKA,OAAc,cACVE,EACAC,EACAC,EAAgB,EAChBC,EAAuB,KACnB,CACJ,IAAMC,EAAWJ,EAAQ,gBAAgB,EACrCK,EAAYF,EAAQH,EAAQ,QAAQ,aAAeG,EAAQD,EAAgB,GAAKD,EAAM,OAC1FI,EAAYA,EAAYJ,EAAM,OAASA,EAAM,OAASI,EAEtD,QAASC,EAAI,EAAGA,EAAID,EAAWC,IAAK,CAChC,IAAMC,EAAON,EAAMK,CAAC,EACpBC,EAAK,MAAQ,KAAK,MAAMH,CAAQ,EAChCG,EAAK,OAAS,KAAK,MAAMH,CAAQ,EACjCG,EAAK,QAAU,GACfA,EAAK,IAAM,KAAK,MAAMD,EAAIN,EAAQ,QAAQ,WAAW,EAAIE,EACzDK,EAAK,MAAM,CACf,CACJ,CAEO,cAAcN,EAAsBO,EAAkBL,EAAsB,CAC/ER,EAAO,cAAc,KAAMM,EAAOO,EAASL,CAAK,CACpD,CAEU,2BAAoC,CAC1C,OAAO,KAAK,QAAQ,WACxB,CAEU,yBAAkC,CACxC,OAAO,KAAK,KAAK,KAAK,wBAAwB,EAAI,KAAK,gBAAgB,CAAC,CAC5E,CAKU,iBAA0B,CAChC,IAAMM,EAAc,KAAK,0BAA0B,EACnD,OAAQ,KAAK,OAASA,EAAc,GAAK,KAAK,QAAQ,KAAOA,CACjE,CAEU,eAAwB,CAC9B,MAAO,eACX,CACJ","names":["debounce","func","debounceMs","signal","edges","pendingThis","pendingArgs","leading","trailing","invoke","onTimerEnd","cancel","timeoutId","schedule","cancelTimer","flush","debounced","args","isFirstCall","pick","obj","keys","result","key","isPlainObject","object","_a","tag","proto","defaultsDeep","target","sources","i","source","defaultsDeepRecursive","stack","key","sourceValue","targetValue","isPlainObject","newObj","inStack","createElement","className","tagName","appendToEl","el","document","appendChild","equalizePoints","p1","p2","x","y","id","undefined","roundPoint","p","Math","round","getDistanceBetween","abs","sqrt","pointsEqual","clamp","val","min","max","toTransformString","scale","propValue","setTransform","style","transform","defaultCSSEasing","setTransitionStyle","prop","duration","ease","transition","setWidthHeight","w","h","width","height","removeTransitionStyle","decodeImage","img","decode","catch","complete","Promise","resolve","reject","onload","onerror","LOAD_STATE","IDLE","LOADING","LOADED","ERROR","specialKeyUsed","e","button","ctrlKey","metaKey","altKey","shiftKey","getElementsFromOption","option","legacySelector","parent","elements","Element","NodeList","Array","isArray","from","selector","querySelectorAll","isSafari","navigator","vendor","match","supportsPassive","window","addEventListener","Object","defineProperty","get","DOMEvents","constructor","_pool","add","target","type","listener","passive","_toggleListener","remove","removeAll","forEach","poolItem","unbind","skipPool","methodName","split","eType","filter","push","eventOptions","getViewportSize","options","pswp","getViewportSizeFn","newViewportSize","documentElement","clientWidth","innerHeight","parsePaddingOption","viewportSize","itemData","index","paddingValue","paddingFn","padding","legacyPropName","toUpperCase","slice","Number","getPanAreaSize","PanBounds","slide","currZoomLevel","center","update","_updateAxis","dispatch","reset","axis","elSize","data","panAreaSize","correctPan","panOffset","MAX_IMAGE_WIDTH","ZoomLevel","elementSize","fit","fill","vFill","initial","secondary","maxWidth","maxHeight","hRatio","vRatio","_getInitial","_getSecondary","_getMax","zoomLevels","slideData","_parseZoomLevelOption","optionPrefix","optionName","optionValue","Slide","isActive","currIndex","currentResolution","pan","isFirstSlide","opener","isOpen","content","contentLoader","getContentBySlide","container","holderElement","heavyAppended","bounds","prevDisplayedWidth","prevDisplayedHeight","setIsActive","activate","deactivate","append","transformOrigin","calculateSize","load","updateContentSize","appendHeavy","zoomAndPanToInitial","applyCurrentZoomPan","mainScroll","isShifted","defaultPrevented","destroy","hasSlide","resize","panTo","force","scaleMultiplier","sizeChanged","setDisplayedSize","getPlaceholderElement","_this$content$placeho","placeholder","element","zoomTo","destZoomLevel","centerPoint","transitionDuration","ignoreBounds","isZoomable","animations","stopAllPan","prevZoomLevel","setZoomLevel","calculateZoomToPanOffset","finishTransition","_setResolution","startTransition","isPan","name","getCurrentTransform","onComplete","easing","toggleZoom","zoomAnimationDuration","point","getViewportCenterPoint","zoomFactor","panX","panY","isPannable","Boolean","_applyZoomTransform","currSlide","zoom","newResolution","PAN_END_FRICTION","VERTICAL_DRAG_FRICTION","MIN_RATIO_TO_CLOSE","MIN_NEXT_SLIDE_SPEED","project","initialVelocity","decelerationRate","DragHandler","gestures","startPan","start","stopAll","change","prevP1","dragAxis","closeOnVerticalDrag","isMultitouch","_setPanWithFriction","bgOpacity","_getVerticalDragRatio","applyBgOpacity","_panOrMoveMainScroll","end","velocity","indexDiff","currentSlideVisibilityRatio","getCurrSlideX","moveIndexBy","correctZoomPan","_finishPanGestureForAxis","panPos","restoreBgOpacity","projectedPosition","vDragRatio","projectedVDragRatio","close","correctedPanPosition","dampingRatio","initialBgOpacity","totalPanDist","startSpring","onUpdate","pos","animationProgressRatio","floor","delta","newMainScrollX","moveTo","newPan","allowPanToNext","currSlideMainScrollX","mainScrollShiftDiff","isLeftToRight","isRightToLeft","_this$pswp$currSlide$","_this$pswp$currSlide","potentialPan","customFriction","UPPER_ZOOM_FRICTION","LOWER_ZOOM_FRICTION","getZoomPointsCenter","ZoomHandler","_startPan","_startZoomPoint","_zoomPoint","_wasOverFitZoomLevel","_startZoomLevel","startP1","startP2","minZoomLevel","maxZoomLevel","pinchToClose","_calculatePanForZoomLevel","ignoreGesture","destinationZoomLevel","currZoomLevelNeedsChange","initialPan","destinationPan","panNeedsChange","naturalFrequency","now","newZoomLevel","didTapOnMainContent","event","closest","TapHandler","click","originalEvent","targetClassList","classList","isImageClick","contains","isBackgroundClick","_doClickOrTapAction","tap","doubleTap","actionName","_this$gestures$pswp$e","actionFullName","call","clickToCloseNonZoomable","toggle","AXIS_SWIPE_HYSTERISIS","DOUBLE_TAP_DELAY","MIN_TAP_DISTANCE","Gestures","prevP2","_lastStartP1","_intervalP1","_numActivePoints","_ongoingPointers","_touchEventEnabled","_pointerEventEnabled","PointerEvent","supportsTouch","maxTouchPoints","_intervalTime","_velocityCalculated","isDragging","isZooming","raf","_tapTimer","drag","tapHandler","on","events","scrollWrap","_onClick","bind","_bindEvents","ontouchmove","ontouchend","pref","down","up","cancel","cancelEvent","onPointerDown","onPointerMove","onPointerUp","isMousePointer","pointerType","preventDefault","mouseDetected","_preventPointerEventBehaviour","_updatePoints","_clearTapTimer","_calculateDragDirection","_updateStartPoints","Date","_rafStopLoop","_rafRenderLoop","_finishDrag","_updateVelocity","_finishTap","_updatePrevPoints","requestAnimationFrame","time","_getVelocity","indexOf","tapDelay","doubleTapAction","setTimeout","clearTimeout","displacement","cancelAnimationFrame","applyFilters","pointerEvent","pointerIndex","findIndex","ongoingPointer","pointerId","splice","_convertEventPosToPoint","length","touchEvent","touches","diff","axisToCheck","pageX","offset","pageY","identifier","stopPropagation","MAIN_SCROLL_END_FRICTION","MainScroll","slideWidth","_currPositionIndex","_prevPositionIndex","_containerShiftIndex","itemHolders","resizeSlides","newSlideWidth","spacing","slideWidthChanged","itemHolder","resetPosition","appendHolders","i","setAttribute","display","canBeSwiped","getNumItems","animate","velocityX","newIndex","potentialIndex","numSlides","canLoop","getLoopedIndex","distance","stopMainScroll","destinationX","updateCurrItem","isMainScroll","currDiff","currDistance","_this$itemHolders$","positionDifference","diffAbs","tempHolder","_itemHolder$slide","shift","setContent","pop","unshift","updateLazy","dragging","newSlideIndexOffset","KeyboardKeyCodesMap","Escape","z","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Tab","getKeyboardEventKey","key","isKeySupported","Keyboard","_wasFocused","trapFocus","initialPointerPos","_focusRoot","_onFocusIn","_onKeyDown","lastActiveElement","activeElement","returnFocus","focus","keydownAction","isForward","keyCode","escKey","arrowKeys","template","DEFAULT_EASING","CSSAnimation","props","_props$prop","onFinish","_target","_onComplete","_finished","_onTransitionEnd","_helperTimeout","_finalizeAnimation","removeEventListener","DEFAULT_NATURAL_FREQUENCY","DEFAULT_DAMPING_RATIO","SpringEaser","_dampingRatio","_naturalFrequency","_dampedFrequency","easeFrame","deltaPosition","deltaTime","coeff","naturalDumpingPow","E","dumpedFCos","cos","dumpedFSin","sin","SpringAnimation","_raf","easer","prevTime","animationLoop","Animations","activeAnimations","_start","isSpring","animation","stop","isPanRunning","some","ScrollWheel","_onWheel","deltaX","deltaY","wheelToZoom","deltaMode","__pow","clientX","clientY","addElementHTML","htmlData","isCustomSVG","svgData","out","join","size","outlineID","inner","UIElement","_container","elementHTML","html","isButton","toLowerCase","title","ariaLabel","ariaText","innerHTML","onInit","onClick","onclick","appendTo","topBar","initArrowButton","isNextButton","loop","disabled","arrowPrev","order","arrowNext","closeButton","zoomButton","loadingIndicator","indicatorElement","isVisible","delayTimeout","toggleIndicatorClass","setIndicatorVisibility","visible","updatePreloaderVisibility","_pswp$currSlide","isLoading","_pswp$currSlide2","preloaderDelay","ui","counterIndicator","counterElement","innerText","indexIndicatorSep","setZoomedIn","isZoomedIn","UI","isRegistered","uiElementsData","items","_lastUpdatedZoomLevel","init","sort","a","b","uiElementData","registerElement","_pswp$element","_onZoomPanUpdate","elementData","isClosing","currZoomLevelDiff","potentialZoomLevel","imageClickAction","getBoundsByElement","thumbAreaRect","getBoundingClientRect","left","top","getCroppedBoundsByElement","imageWidth","imageHeight","fillZoomLevel","offsetX","offsetY","innerRect","getThumbBounds","instance","thumbBounds","thumbnail","thumbSelector","matches","querySelector","thumbCropped","PhotoSwipeEvent","details","assign","Eventable","_listeners","_filters","addFilter","fn","priority","_this$_filters$name","_this$_filters$name2","_this$pswp","f1","f2","removeFilter","args","_this$_filters$name3","apply","_this$_listeners$name","_this$pswp2","off","_this$pswp3","_this$_listeners$name2","Placeholder","imageSrc","imgEl","decoding","alt","src","_this$element","parentNode","Content","displayedImageWidth","displayedImageHeight","isAttached","isDecoding","state","removePlaceholder","keepPlaceholder","isLazy","reload","usePlaceholder","placeholderEl","parentElement","prepend","placeholderSrc","msrc","isImageContent","loadImage","_this$data$src","_this$data$alt","imageElement","updateSrcsetSizes","srcset","onLoaded","onError","setSlide","displayError","isError","isInitialSizeUpdate","image","sizesWidth","dataset","largestUsedSize","parseInt","sizes","String","lazyLoad","_this$instance$option","_this$instance$option2","errorMsgEl","errorMsg","supportsDecode","finally","appendImage","MIN_SLIDES_TO_CACHE","lazyLoadData","createContentFromData","zoomLevel","ceil","lazyLoadSlide","getItemData","ContentLoader","limit","preload","_cachedItems","loadSlideByIndex","initialIndex","getContentByIndex","addToCache","removeByIndex","indexToRemove","item","find","PhotoSwipeBase","_this$options","numItems","dataSource","_getGalleryDOMElements","gallery","_this$options2","dataSourceItem","_domElementToItemData","galleryElement","_this$options3","_this$options4","children","childSelector","linkEl","pswpSrc","href","pswpSrcset","pswpWidth","pswpHeight","pswpType","thumbnailEl","_thumbnailEl$getAttri","currentSrc","getAttribute","pswpCropped","cropped","MIN_OPACITY","Opener","isClosed","isOpening","_duration","_useAnimation","_croppedZoom","_animateRootOpacity","_animateBgOpacity","_placeholder","_opacityElement","_cropContainer1","_cropContainer2","_thumbBounds","_prepareOpen","open","hideAnimationDuration","maxWidthToAnimate","_applyStartProps","showAnimationDuration","showHideAnimationType","showHideOpacity","_initialThumbBounds","_animateZoom","_options$showHideOpac","bg","opacity","overflow","_setClosedStateZoomPan","willChange","decoded","isDelaying","_initiate","_this$pswp$element","_this$pswp$element2","setProperty","_animateToOpenState","_animateToClosedState","_onAnimationComplete","_animateTo","containerOnePanX","containerOnePanY","containerTwoPanX","containerTwoPanY","animProps","defaultOptions","bgClickAction","tapAction","PhotoSwipe","_prepareOptions","_prevViewportSize","isDestroying","hasMouse","_initialItemData","keyboard","_createMainStructure","rootClasses","mainClass","scrollWheel","isNaN","updateSize","pageYOffset","_handlePageResize","_updatePageScrollOffset","goTo","next","prev","_this$currSlide","_this$currSlide2","_itemHolder$slide2","refreshSlideContent","slideIndex","_this$currSlide$index","_this$currSlide3","potentialHolderIndex","_itemHolder$slide3","holder","matchMedia","_this$element2","test","userAgent","setScrollOffset","body","__spreadValues","createElement","className","tagName","appendToEl","el","document","appendChild","toTransformString","x","y","scale","propValue","undefined","setWidthHeight","w","h","style","width","height","LOAD_STATE","IDLE","LOADING","LOADED","ERROR","specialKeyUsed","e","button","ctrlKey","metaKey","altKey","shiftKey","getElementsFromOption","option","legacySelector","parent","elements","Element","NodeList","Array","isArray","from","selector","querySelectorAll","isPswpClass","fn","prototype","goTo","isSafari","navigator","vendor","match","PhotoSwipeEvent","constructor","type","details","defaultPrevented","Object","assign","preventDefault","Eventable","_listeners","_filters","pswp","options","addFilter","name","priority","_this$_filters$name","_this$_filters$name2","_this$pswp","push","sort","f1","f2","removeFilter","filter","applyFilters","args","_this$_filters$name3","forEach","apply","on","_this$_listeners$name","_this$pswp2","off","_this$pswp3","listener","dispatch","_this$_listeners$name2","event","call","Placeholder","imageSrc","container","element","imgEl","decoding","alt","src","setAttribute","setDisplayedSize","transformOrigin","transform","destroy","_this$element","parentNode","remove","Content","itemData","instance","index","data","placeholder","slide","displayedImageWidth","displayedImageHeight","Number","isAttached","hasSlide","isDecoding","state","content","removePlaceholder","keepPlaceholder","setTimeout","load","isLazy","reload","usePlaceholder","placeholderEl","parentElement","prepend","placeholderSrc","msrc","isFirstSlide","isImageContent","loadImage","innerHTML","html","updateContentSize","_this$data$src","_this$data$alt","imageElement","updateSrcsetSizes","srcset","complete","onLoaded","onload","onerror","onError","setSlide","isActive","heavyAppended","append","displayError","isError","isLoading","isInitialSizeUpdate","isZoomable","image","sizesWidth","dataset","largestUsedSize","parseInt","sizes","String","lazyLoad","_this$instance$option","_this$instance$option2","errorMsgEl","innerText","errorMsg","supportsDecode","decode","catch","finally","appendImage","activate","holderElement","deactivate","getViewportSize","getViewportSizeFn","newViewportSize","documentElement","clientWidth","window","innerHeight","parsePaddingOption","prop","viewportSize","paddingValue","paddingFn","padding","legacyPropName","toUpperCase","slice","getPanAreaSize","MAX_IMAGE_WIDTH","ZoomLevel","panAreaSize","elementSize","fit","fill","vFill","initial","secondary","max","min","update","maxWidth","maxHeight","hRatio","vRatio","Math","_getInitial","_getSecondary","_getMax","zoomLevels","slideData","_parseZoomLevelOption","optionPrefix","optionName","optionValue","currZoomLevel","lazyLoadData","createContentFromData","zoomLevel","ceil","lazyLoadSlide","getItemData","PhotoSwipeBase","getNumItems","_this$options","numItems","dataSource","length","items","_getGalleryDOMElements","gallery","_this$options2","dataSourceItem","_domElementToItemData","galleryElement","_this$options3","_this$options4","children","childSelector","linkEl","querySelector","pswpSrc","href","pswpSrcset","pswpWidth","pswpHeight","pswpType","thumbnailEl","_thumbnailEl$getAttri","currentSrc","getAttribute","pswpCropped","cropped","thumbCropped","PhotoSwipeLightbox","_uid","shouldOpen","_preloadedContent","onThumbnailsClick","bind","init","gallerySelector","addEventListener","initialPoint","clientX","clientY","clickedIndex","getClickedIndex","currentTarget","loadAndOpen","getClickedIndexFn","clickedTarget","target","clickedChildIndex","findIndex","child","contains","galleryElements","initialPointerPos","preload","promiseArray","pswpModuleType","pswpModule","Promise","resolve","Error","openPromise","preloadFirstSlide","uid","all","then","iterableModules","mainModule","_openPhotoswipe","module","default","keys","contentLoader","addToCache","removeEventListener","getNextIcon","document","div","getImageRatio","model","ratioLimits","ratio","getImageRatioAndIfCropped","cropped","sanitizeHtml","term","LabelVisibility","Item","document","options","model","sanitizeHtml","value","figure","caption","image","root","link","zoomableElement","checkbox","c","activate","_a","_b","className","event","button","showLabel","showLabelValues","hasCaption","marker","handleCheckboxAction","e","element","ev","data","activableEvent","handleZoom","AbstractGallery","elementRef","options","scrollElementRef","_a","defaultsDeep","debounce","item","offset","getNextIcon","e","iframe","resizeDebounceDuration","startResize","endResize","_b","_c","photoSwipeId","models","addToDom","collectionSize","model","itemOptions","pick","Item","activate","name","callback","items","PhotoSwipeLightbox","__spreadProps","__spreadValues","PhotoSwipe","_itemData","index","limit","estimation","destination","ev","data","event","element","scrollable","wrapper","startScroll","endScroll","endOfGalleryAt","current_scroll_top","wrapperHeight","scroll_delta","AbstractRowGallery","AbstractGallery","elementRef","options","scrollElementRef","rows","nbVisibleImages","nextRow","lastWantedRow","bufferedItems","i","Natural","_Natural","AbstractRowGallery","elementRef","options","scrollElementRef","gallery","items","fromRow","toRow","currentRow","chunkSize","chunk","c","nextRow","containerWidth","margin","row","maxRowHeight","ratioLimits","chunkModels","rowHeight","apportion","excess","decimals","i","item","ratio","cropped","getImageRatioAndIfCropped","width","models","total","model","getImageRatio","rows","lastVisibleRow","visibleItemsInLastRow","collectionFromLastVisibleRow","Column","document","options","item","Masonry","_Masonry","AbstractGallery","elementRef","options","scrollElementRef","ratio","columnWidth","gallery","items","fromIndex","toIndex","itemsPerRow","lastIndex","i","item","cropped","getImageRatioAndIfCropped","fromRow","toRow","estimatedImageHeight","shortestColumn","columnRef","Column","c","nbItems","nbVisibleImages","firstIndex","lastWantedIndex","column","Square","_Square","AbstractRowGallery","elementRef","options","scrollElementRef","gallery","items","firstRowIndex","toRow","sideSize","lastIndex","i","item","fromRow","itemsPerRow"]}